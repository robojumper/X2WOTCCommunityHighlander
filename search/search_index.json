{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"X2WOTCCommunityHighlander Documentation Current status of the Documentation The documentation is freshly introduced. It will take us a while to document all old features, but it is expected that new features all come with their documentation page. How to read The nav bar has a list of features. Click on a feature to view that feature's documentation. Every feature has: A GitHub tracking issue for discussion A documented way to use it, for example with an event tuple Code references that link to HL source code where the documentation is Documentation for the documentation tool We place our documentation inside of the source code next to where the main change for the given feature is. make_docs.py extracts this documentation and renders MarkDown pages, which MkDocs in turn renders to a web page. You can run the documentation tool locally by installing Python (recommended version 3.7) and running python .\\.scripts\\make_docs.py .\\X2WOTCCommunityHighlander\\Src\\ .\\X2WOTCCommunityHighlander\\Config\\ --outdir .\\target\\ --docsdir .\\docs_src\\ --dumpelt .\\target\\CHL_Event_Compiletest.uc or the makeDocs task in VS Code. This creates Markdown files for the documentation; rendering HTML documentation requires MkDocs : pip install mkdocs cd .\\target\\ mkdocs serve Whenever the master branch is committed to, the documentation is built and deployed here. Additionally, upon opening or updating a Pull Request, the documentation is built and uploaded as a GitHub artifact. This can be used to easily check the resulting documentation for a Pull Request. Inline Documentation The core concept of the documentation script is \"features\". Documentation always relates to a given feature, and usually the feature name is the name of the function or event that is added. Every feature needs exactly one definition , and may have additional documentation scattered throughout other source files. Syntax Every block of comments starting with triple comment characters ( /// for UnrealScript files and ;;; for Ini files) and an optional whitespace character (space or tab) will be considered for documentation. Additionally, the first line must begin with HL-Docs: . All directly following lines that start with the same triple comment will be included until the first line that does not have that triple comment. Standard MarkDown syntax is expected and supported. You may include source code fragments directly from the game code by placing a single HL-Include: in an otherwise empty triple comment line; all following lines until the next triple comment line will be included as source code in the documentation. Feature definitions A feature definition has the following syntax: HL-Docs: feature:<string>; issue:<int>; tags:<string>,<string>... Feature references If you have defined a feature somewhere but want to reference other parts of the source code, or want to spread the documentation for a feature across different files, you may place a reference: HL-Docs: ref:<string> All text from the reference block will be appended to the main documentation as well. Complete example (Taken from ArmorEquipRollDLCPartChance ) XComGameState_Unit.uc : /// HL-Docs: feature:ArmorEquipRollDLCPartChance; issue:155; tags:customization,compatibility /// When a unit equips new armor, the game rolls from all customization options, even the ones where /// the slider for the `DLCName` is set to `0`. The HL change fixes this, but if your custom armor only /// has customization options with a `DLCName` set, the game may discard that `DLCName` (default: in 85% of cases) /// which results in soldiers without torsos. If you want to keep having `DLCName`-only armor /// (for example to display mod icons in `UICustomize`), you must disable that behavior /// by creating the following lines in `XComGame.ini`: /// /// ```ini /// [XComGame.CHHelpers] /// +CosmeticDLCNamesUnaffectedByRoll=MyDLCName /// ``` XComGame.ini : ;;; HL-Docs: ref:ArmorEquipRollDLCPartChance Tags You may tag your documentation with a number of built-in and custom tags. strategy and tactical are built-in tags used to categorize features in the navigation bar. If a feature has one tag and not the other, it'll land in that category. Otherwise, it'll land in the misc category. Custom tags can be used, but need a custom page that serves as an index page for that tag; for example the compatibility tag has a page docs_src/compatibility.md that describes what the tag is supposed to mean and (automatically generated) links to all features with that tag. Bugfixes The Bugfixes feature is owned by the documentation script and as such has no definition in the game code. It is used for generating a page listing all bugfixes that can be explained by a single line. It uses a slightly modified reference syntax: HL-Docs: ref:Bugfixes; issue:<int> <string> for example: /// HL-Docs: ref:Bugfixes; issue:70 /// `CharacterPoolManager:CreateCharacter` now honors ForceCountry Events The Highlander triggers some events to pass data to and receive data from mods. We document these events with a special syntax and automatically generate a copy-pasteable listener template that developers can simply copy into their mod and fill out. Additionally, that listener template is printed into a CHL source file so that it can be tested whether it successfully compiles. The syntax for events is the following ```event EventID: OverridePromotionUIClass, EventData: [in enum[CHLPromotionScreenType] PromotionScreenType, inout class[class<UIArmory_Promotion>] PromotionUIClass], EventSource: XComHQPresentationLayer (Pres), NewGameState: none ``` Entries need to be comma-separated EventData or EventSource specify the type, and then optionally in parentheses the variable name. EventData can be an XComLWTuple. In that case, use [ inout int a, ... ] Tuple parameters can be in , out , or inout In the template, in parameters will be copied from the tuple into a local property out parameters will be copied from a local property into the tuple inout parameters do both All XComLWTuple types are supported enum s can be typed with enum[EnumType] class es can be typed with class[class<Type>] If the type is not a primitive, it's assumed to be an object NewGameState needs to be one of three values: yes , maybe or none The above example generates the following code static function EventListenerReturn OnOverridePromotionUIClass(Object EventData, Object EventSource, XComGameState GameState, Name EventID, Object CallbackObject) { local XComHQPresentationLayer Pres; local XComLWTuple Tuple; local CHLPromotionScreenType PromotionScreenType; local class<UIArmory_Promotion> PromotionUIClass; Pres = XComHQPresentationLayer(EventSource); Tuple = XComLWTuple(EventData); PromotionScreenType = CHLPromotionScreenType(Tuple.Data[0].i); PromotionUIClass = class<UIArmory_Promotion>(Tuple.Data[1].o); // Your code here Tuple.Data[1].o = PromotionUIClass; return ELR_NoInterrupt; } All generated listeners will be dumped into CHL_Event_Compiletest.uc , which will only be included in normal compilation in \"compiletest\" tasks. CI automatically determines the changes your PR would make to that file and posts a comment containing the diff for reviewers (and you). This comment will be updated whenever the PR is updated. If you provide a better example listener, you can simply opt out of the template with ```event,notemplate .","title":"X2WOTCCommunityHighlander Documentation"},{"location":"#x2wotccommunityhighlander-documentation","text":"","title":"X2WOTCCommunityHighlander Documentation"},{"location":"#current-status-of-the-documentation","text":"The documentation is freshly introduced. It will take us a while to document all old features, but it is expected that new features all come with their documentation page.","title":"Current status of the Documentation"},{"location":"#how-to-read","text":"The nav bar has a list of features. Click on a feature to view that feature's documentation. Every feature has: A GitHub tracking issue for discussion A documented way to use it, for example with an event tuple Code references that link to HL source code where the documentation is","title":"How to read"},{"location":"#documentation-for-the-documentation-tool","text":"We place our documentation inside of the source code next to where the main change for the given feature is. make_docs.py extracts this documentation and renders MarkDown pages, which MkDocs in turn renders to a web page. You can run the documentation tool locally by installing Python (recommended version 3.7) and running python .\\.scripts\\make_docs.py .\\X2WOTCCommunityHighlander\\Src\\ .\\X2WOTCCommunityHighlander\\Config\\ --outdir .\\target\\ --docsdir .\\docs_src\\ --dumpelt .\\target\\CHL_Event_Compiletest.uc or the makeDocs task in VS Code. This creates Markdown files for the documentation; rendering HTML documentation requires MkDocs : pip install mkdocs cd .\\target\\ mkdocs serve Whenever the master branch is committed to, the documentation is built and deployed here. Additionally, upon opening or updating a Pull Request, the documentation is built and uploaded as a GitHub artifact. This can be used to easily check the resulting documentation for a Pull Request.","title":"Documentation for the documentation tool"},{"location":"#inline-documentation","text":"The core concept of the documentation script is \"features\". Documentation always relates to a given feature, and usually the feature name is the name of the function or event that is added. Every feature needs exactly one definition , and may have additional documentation scattered throughout other source files.","title":"Inline Documentation"},{"location":"#syntax","text":"Every block of comments starting with triple comment characters ( /// for UnrealScript files and ;;; for Ini files) and an optional whitespace character (space or tab) will be considered for documentation. Additionally, the first line must begin with HL-Docs: . All directly following lines that start with the same triple comment will be included until the first line that does not have that triple comment. Standard MarkDown syntax is expected and supported. You may include source code fragments directly from the game code by placing a single HL-Include: in an otherwise empty triple comment line; all following lines until the next triple comment line will be included as source code in the documentation.","title":"Syntax"},{"location":"#feature-definitions","text":"A feature definition has the following syntax: HL-Docs: feature:<string>; issue:<int>; tags:<string>,<string>...","title":"Feature definitions"},{"location":"#feature-references","text":"If you have defined a feature somewhere but want to reference other parts of the source code, or want to spread the documentation for a feature across different files, you may place a reference: HL-Docs: ref:<string> All text from the reference block will be appended to the main documentation as well.","title":"Feature references"},{"location":"#complete-example","text":"(Taken from ArmorEquipRollDLCPartChance ) XComGameState_Unit.uc : /// HL-Docs: feature:ArmorEquipRollDLCPartChance; issue:155; tags:customization,compatibility /// When a unit equips new armor, the game rolls from all customization options, even the ones where /// the slider for the `DLCName` is set to `0`. The HL change fixes this, but if your custom armor only /// has customization options with a `DLCName` set, the game may discard that `DLCName` (default: in 85% of cases) /// which results in soldiers without torsos. If you want to keep having `DLCName`-only armor /// (for example to display mod icons in `UICustomize`), you must disable that behavior /// by creating the following lines in `XComGame.ini`: /// /// ```ini /// [XComGame.CHHelpers] /// +CosmeticDLCNamesUnaffectedByRoll=MyDLCName /// ``` XComGame.ini : ;;; HL-Docs: ref:ArmorEquipRollDLCPartChance","title":"Complete example"},{"location":"#tags","text":"You may tag your documentation with a number of built-in and custom tags. strategy and tactical are built-in tags used to categorize features in the navigation bar. If a feature has one tag and not the other, it'll land in that category. Otherwise, it'll land in the misc category. Custom tags can be used, but need a custom page that serves as an index page for that tag; for example the compatibility tag has a page docs_src/compatibility.md that describes what the tag is supposed to mean and (automatically generated) links to all features with that tag.","title":"Tags"},{"location":"#bugfixes","text":"The Bugfixes feature is owned by the documentation script and as such has no definition in the game code. It is used for generating a page listing all bugfixes that can be explained by a single line. It uses a slightly modified reference syntax: HL-Docs: ref:Bugfixes; issue:<int> <string> for example: /// HL-Docs: ref:Bugfixes; issue:70 /// `CharacterPoolManager:CreateCharacter` now honors ForceCountry","title":"Bugfixes"},{"location":"#events","text":"The Highlander triggers some events to pass data to and receive data from mods. We document these events with a special syntax and automatically generate a copy-pasteable listener template that developers can simply copy into their mod and fill out. Additionally, that listener template is printed into a CHL source file so that it can be tested whether it successfully compiles. The syntax for events is the following ```event EventID: OverridePromotionUIClass, EventData: [in enum[CHLPromotionScreenType] PromotionScreenType, inout class[class<UIArmory_Promotion>] PromotionUIClass], EventSource: XComHQPresentationLayer (Pres), NewGameState: none ``` Entries need to be comma-separated EventData or EventSource specify the type, and then optionally in parentheses the variable name. EventData can be an XComLWTuple. In that case, use [ inout int a, ... ] Tuple parameters can be in , out , or inout In the template, in parameters will be copied from the tuple into a local property out parameters will be copied from a local property into the tuple inout parameters do both All XComLWTuple types are supported enum s can be typed with enum[EnumType] class es can be typed with class[class<Type>] If the type is not a primitive, it's assumed to be an object NewGameState needs to be one of three values: yes , maybe or none The above example generates the following code static function EventListenerReturn OnOverridePromotionUIClass(Object EventData, Object EventSource, XComGameState GameState, Name EventID, Object CallbackObject) { local XComHQPresentationLayer Pres; local XComLWTuple Tuple; local CHLPromotionScreenType PromotionScreenType; local class<UIArmory_Promotion> PromotionUIClass; Pres = XComHQPresentationLayer(EventSource); Tuple = XComLWTuple(EventData); PromotionScreenType = CHLPromotionScreenType(Tuple.Data[0].i); PromotionUIClass = class<UIArmory_Promotion>(Tuple.Data[1].o); // Your code here Tuple.Data[1].o = PromotionUIClass; return ELR_NoInterrupt; } All generated listeners will be dumped into CHL_Event_Compiletest.uc , which will only be included in normal compilation in \"compiletest\" tasks. CI automatically determines the changes your PR would make to that file and posts a comment containing the diff for reviewers (and you). This comment will be updated whenever the PR is updated. If you provide a better example listener, you can simply opt out of the template with ```event,notemplate .","title":"Events"},{"location":"Bugfixes/","text":"Bugfixes This page accomodates all bug fixes that do not deserve their own documentation page, as they are simple enough to be entirely explained by a single line. #20 - X2Ability.uc:1447-1448 : Reaper's Banish now properly visualizes subsequent shots. #33 - XGUnitNativeBase.uc:543-544 : Gremlins owned by AI units now correctly use fast walk animations even if their owner is in Red Alert #36 - X2TacticalGameRuleset.uc:4734-4735 : Do not clear Reinforcements' \"Summoning Sickness\" when interrupted by Skirmisher, denying them an erronous bonus turn. #39 - UIArmory_WeaponUpgrade.uc:558-559 : Create weapon pawn before setting PawnLocationTag so that the weapon can rotate when previewing weapon upgrades. #51 - XComGameState_AdventChosen.uc:264-265 : Prevent Assassin from gaining perks incompatible with forced \"Shadowstep\" in Lost and Abandoned #55 - CHItemSlot.uc:349-350 : Check a soldier's NeedsSecondaryWeapon everywhere instead of hardcoding based on Rookie rank #70 - CharacterPoolManager.uc:447-448 : CharacterPoolManager:CreateCharacter now honors ForceCountry #95 - XComGameState_Unit.uc:13589-13590 : ResetRankToRookie now correctly applies Beta Strike HP bonuses #160 - UIOptionsPCScreen.uc:3145-3146 : UIOptionsPCScreen now shows all part pack sliders, adding a scroll bar if needed #215 - XGUnit.uc:1496-1497 : Units are now allowed to have personality speech (affected by personality) even below \"Veteran\" rank #269 - XComIdleAnimationStateMachine.uc:1090-1091 : Fix some edge cases in XComIdleAnimationStateMachine regarding idle animations, targeting, and step-outs #273 - X2Ability.uc:1501-1502 : Fix an issue causing Rapid Fire/Chain Shot/Banish/... entering cover early #303 - UITooltipInfoList.uc:98-99 : UITooltipInfoList no longer displays stale data like weapon upgrades from other units #318 - X2Camera_Cinescript.uc:528-529 : Fix Cinescript CutAfterPrevious not working in combination with MatineeReplacements , breaking Spark BIT hack camera #326 - X2Action_ApplyWeaponDamageToUnit.uc:187-188 : Allow damage flyovers from weapon-less Psi abilities to use the Psi damage popup #376 - XGUnit.uc:3688-3689 : Gremlins (and other Cosmetic Units) are now correctly tinted and patterned #384 - XComHumanPawn.uc:2369-2370 : Remove cosmetics from separate Left and Right Arm slots when updating Appearance to one that includes a cosmetic body part for both Arms in one slot. #384 - XComHumanPawn.uc:2436-2437 : Allow bForcedAppearance to work with new deco slots added with Anarchy Children and WOTC. #384 - XGCharacterGenerator.uc:713-714 : Randomize deco slots only if the character template is not using bForceAppearance . #426 - X2AbilityToHitCalc_StandardAim.uc:196-197 : Fix X2AbilityToHitCalc_StandardAim discarding unfavorable (for XCOM) changes to hit results from effects #493 - X2AbilityToHitCalc_StandardAim.uc:702-703 : Allow REACTION_DASHING_FINALMOD to reduce reaction fire hit chance against dashing targets #503 - XGAIBehavior.uc:9658-9659 : \"Flying\" pod leaders now patrol despite non-flat tiles on their paths #508 - XComGameState_AIGroup.uc:422-423 : Patrol logic now ensures units do not attempt to patrol outside of the map which would cause them to stop patrolling #520 - X2MeleePathingPawn.uc:174-175 : Controller input now allows choosing melee attack destination tile despite floor differences #531 - X2Ability_ChosenAssassin.uc:565-566 : Assassin gains a temporary instead of permanently stacking mobility boost from performing a melee attack #551 - X2Action_SwapTeams.uc:48-49 : Rescue rings no longer disappear on other rescuable units after a neutral unit swaps to team XCom #557 - XComGameState_Unit.uc:2398-2399 : Soldiers that have been carried out of a mission are no longer unable to be carried out of a later mission #608 - XComGameState_Unit.uc:4319-4320 : MergeAmmoAsNeeded now also works for units spawned from the Avenger #613 - UIX2PanelHeader.uc:53-54 : SetText now sends text to flash instead of requiring calling SetHeaderWidth #617 - X2TargetingMethod_RocketLauncher.uc:44-45 : Ray trace from the peek tile to the target, not from the unit tile to the peek tile. #637 - XComGameState_Unit.uc:14482-14483 : Will recovery project and soldier mental state are now consistent with each other, fixing Shaken/Tired soldiers occasionally recovering instantly #638 - UIScanButton.uc:278-279 : UIScanButton can now work properly when it's a grandchild of UIStrategyMapItem, not only when direct child #644 - X2Ability_DefaultAbilitySet.uc:426-427 : Allow patrolling units to occupy the same tile instead of teleporting to (0,0,0) when out of space, potentially revealing XCOM #648 - UIHackingScreen.uc:410-411 : Cancelling a hack in progress using Esc no longer bypasses Haywire's cooldown #682 - XComGameState_Unit.uc:6834-6836 : Zombies will no longer drop loot. Only affects mods that destroy loot when killing units with explosives. #701 - UIArmory_LoadoutItem.uc:73-74 : Allows armory UI to highlight the item the player needs to build during the tutorial even if it's not the item with the exact template name 'Medikit' #775 - XGBase.uc:263-264 : Applying facility upgrades before the facility map is loaded no longer crashes the game. #824 - XComGameState_Unit.uc:2545-2547 : Units that are still stunned when a mission ends no longer lose action points at the start of their next mission. #861 - UIStaffSlot.uc:223-227 : By default, UIStaffSlot removes highlighting when a personnel is selected. However, the slot still has navigator focus, and should remain highlighted. This only affects controllers since the mouse has moved off the button at this point. If a controller is active, don't let the game un-highlight it. #862 - UIStaffSlot.uc:405-408 : By default, UIStaffSlot will blink on and off a staff slot that \"loses\" focus when focus doesn't belong to it in the first place. Make sure to only change focus if the element is not already in the destination focus state #866 - UIStaffContainer.uc:58-60 : By default, UIStaffContainer tries to shortcut which UIPanel should receive focus, but the shortcut is often wrong and the time it saves is negligible, so this bypasses it. #879 - X2Ability.uc:768-769 : Use HistoryIndex to access the AbilityState as it was when the ability was activated rather than getting the most recent version. #879 - X2Ability.uc:787-788 : Use HistoryIndex to access the WeaponState as it was when the ability was activated rather than getting the most recent version. #896 - X2Effect_ApplyWeaponDamage.uc:471-473 : Call the (hopefully) relevant delegate, if this weapon upgrade has it. This makes the guaranteed damage on missed shots added by Stocks properly benefit from Insider Knowledge #896 - X2Effect_ApplyWeaponDamage.uc:820-822 : Call the (hopefully) relevant delegate, if this weapon upgrade has it. This makes the guaranteed damage on missed shots added by Stocks properly benefit from Insider Knowledge #896 - X2Effect_LaserSight.uc:28-29 : Add bonus crit if Insider Knowledge is present. #924 - UIChoosePsiAbility.uc:211-212 : Prevent the psi ability training screen from showing duplicate abilities #927 - XComGameState_GeoscapeEntity.uc:311-314 : When cancelling out of squad select or mission launch, the selected map item will now return back to the mission rather than the Avenger (affects controller users).","title":"Bugfixes"},{"location":"Bugfixes/#bugfixes","text":"This page accomodates all bug fixes that do not deserve their own documentation page, as they are simple enough to be entirely explained by a single line. #20 - X2Ability.uc:1447-1448 : Reaper's Banish now properly visualizes subsequent shots. #33 - XGUnitNativeBase.uc:543-544 : Gremlins owned by AI units now correctly use fast walk animations even if their owner is in Red Alert #36 - X2TacticalGameRuleset.uc:4734-4735 : Do not clear Reinforcements' \"Summoning Sickness\" when interrupted by Skirmisher, denying them an erronous bonus turn. #39 - UIArmory_WeaponUpgrade.uc:558-559 : Create weapon pawn before setting PawnLocationTag so that the weapon can rotate when previewing weapon upgrades. #51 - XComGameState_AdventChosen.uc:264-265 : Prevent Assassin from gaining perks incompatible with forced \"Shadowstep\" in Lost and Abandoned #55 - CHItemSlot.uc:349-350 : Check a soldier's NeedsSecondaryWeapon everywhere instead of hardcoding based on Rookie rank #70 - CharacterPoolManager.uc:447-448 : CharacterPoolManager:CreateCharacter now honors ForceCountry #95 - XComGameState_Unit.uc:13589-13590 : ResetRankToRookie now correctly applies Beta Strike HP bonuses #160 - UIOptionsPCScreen.uc:3145-3146 : UIOptionsPCScreen now shows all part pack sliders, adding a scroll bar if needed #215 - XGUnit.uc:1496-1497 : Units are now allowed to have personality speech (affected by personality) even below \"Veteran\" rank #269 - XComIdleAnimationStateMachine.uc:1090-1091 : Fix some edge cases in XComIdleAnimationStateMachine regarding idle animations, targeting, and step-outs #273 - X2Ability.uc:1501-1502 : Fix an issue causing Rapid Fire/Chain Shot/Banish/... entering cover early #303 - UITooltipInfoList.uc:98-99 : UITooltipInfoList no longer displays stale data like weapon upgrades from other units #318 - X2Camera_Cinescript.uc:528-529 : Fix Cinescript CutAfterPrevious not working in combination with MatineeReplacements , breaking Spark BIT hack camera #326 - X2Action_ApplyWeaponDamageToUnit.uc:187-188 : Allow damage flyovers from weapon-less Psi abilities to use the Psi damage popup #376 - XGUnit.uc:3688-3689 : Gremlins (and other Cosmetic Units) are now correctly tinted and patterned #384 - XComHumanPawn.uc:2369-2370 : Remove cosmetics from separate Left and Right Arm slots when updating Appearance to one that includes a cosmetic body part for both Arms in one slot. #384 - XComHumanPawn.uc:2436-2437 : Allow bForcedAppearance to work with new deco slots added with Anarchy Children and WOTC. #384 - XGCharacterGenerator.uc:713-714 : Randomize deco slots only if the character template is not using bForceAppearance . #426 - X2AbilityToHitCalc_StandardAim.uc:196-197 : Fix X2AbilityToHitCalc_StandardAim discarding unfavorable (for XCOM) changes to hit results from effects #493 - X2AbilityToHitCalc_StandardAim.uc:702-703 : Allow REACTION_DASHING_FINALMOD to reduce reaction fire hit chance against dashing targets #503 - XGAIBehavior.uc:9658-9659 : \"Flying\" pod leaders now patrol despite non-flat tiles on their paths #508 - XComGameState_AIGroup.uc:422-423 : Patrol logic now ensures units do not attempt to patrol outside of the map which would cause them to stop patrolling #520 - X2MeleePathingPawn.uc:174-175 : Controller input now allows choosing melee attack destination tile despite floor differences #531 - X2Ability_ChosenAssassin.uc:565-566 : Assassin gains a temporary instead of permanently stacking mobility boost from performing a melee attack #551 - X2Action_SwapTeams.uc:48-49 : Rescue rings no longer disappear on other rescuable units after a neutral unit swaps to team XCom #557 - XComGameState_Unit.uc:2398-2399 : Soldiers that have been carried out of a mission are no longer unable to be carried out of a later mission #608 - XComGameState_Unit.uc:4319-4320 : MergeAmmoAsNeeded now also works for units spawned from the Avenger #613 - UIX2PanelHeader.uc:53-54 : SetText now sends text to flash instead of requiring calling SetHeaderWidth #617 - X2TargetingMethod_RocketLauncher.uc:44-45 : Ray trace from the peek tile to the target, not from the unit tile to the peek tile. #637 - XComGameState_Unit.uc:14482-14483 : Will recovery project and soldier mental state are now consistent with each other, fixing Shaken/Tired soldiers occasionally recovering instantly #638 - UIScanButton.uc:278-279 : UIScanButton can now work properly when it's a grandchild of UIStrategyMapItem, not only when direct child #644 - X2Ability_DefaultAbilitySet.uc:426-427 : Allow patrolling units to occupy the same tile instead of teleporting to (0,0,0) when out of space, potentially revealing XCOM #648 - UIHackingScreen.uc:410-411 : Cancelling a hack in progress using Esc no longer bypasses Haywire's cooldown #682 - XComGameState_Unit.uc:6834-6836 : Zombies will no longer drop loot. Only affects mods that destroy loot when killing units with explosives. #701 - UIArmory_LoadoutItem.uc:73-74 : Allows armory UI to highlight the item the player needs to build during the tutorial even if it's not the item with the exact template name 'Medikit' #775 - XGBase.uc:263-264 : Applying facility upgrades before the facility map is loaded no longer crashes the game. #824 - XComGameState_Unit.uc:2545-2547 : Units that are still stunned when a mission ends no longer lose action points at the start of their next mission. #861 - UIStaffSlot.uc:223-227 : By default, UIStaffSlot removes highlighting when a personnel is selected. However, the slot still has navigator focus, and should remain highlighted. This only affects controllers since the mouse has moved off the button at this point. If a controller is active, don't let the game un-highlight it. #862 - UIStaffSlot.uc:405-408 : By default, UIStaffSlot will blink on and off a staff slot that \"loses\" focus when focus doesn't belong to it in the first place. Make sure to only change focus if the element is not already in the destination focus state #866 - UIStaffContainer.uc:58-60 : By default, UIStaffContainer tries to shortcut which UIPanel should receive focus, but the shortcut is often wrong and the time it saves is negligible, so this bypasses it. #879 - X2Ability.uc:768-769 : Use HistoryIndex to access the AbilityState as it was when the ability was activated rather than getting the most recent version. #879 - X2Ability.uc:787-788 : Use HistoryIndex to access the WeaponState as it was when the ability was activated rather than getting the most recent version. #896 - X2Effect_ApplyWeaponDamage.uc:471-473 : Call the (hopefully) relevant delegate, if this weapon upgrade has it. This makes the guaranteed damage on missed shots added by Stocks properly benefit from Insider Knowledge #896 - X2Effect_ApplyWeaponDamage.uc:820-822 : Call the (hopefully) relevant delegate, if this weapon upgrade has it. This makes the guaranteed damage on missed shots added by Stocks properly benefit from Insider Knowledge #896 - X2Effect_LaserSight.uc:28-29 : Add bonus crit if Insider Knowledge is present. #924 - UIChoosePsiAbility.uc:211-212 : Prevent the psi ability training screen from showing duplicate abilities #927 - XComGameState_GeoscapeEntity.uc:311-314 : When cancelling out of squad select or mission launch, the selected map item will now return back to the mission rather than the Avenger (affects controller users).","title":"Bugfixes"},{"location":"compatibility/","text":"Compatibility Because the Highlander is a core mod that many different mods on the workshop depend on, it strives to not make any observable changes to the base game (save for bug fixes and features that mods explicitly make use of). However, everything can potentially be a breaking change because the existing behavior rarely has any documentation in the game. Additionally, ModClassOverrides in mods occasionally override functions that were changed in the Highlander, essentially reverting the change and breaking a Highlander feature. As a result, sometimes modders need to pay special attention to Highlander features. This page is a list of pages tagged compatibility , indicating a potential incompatibility. Every page listed here has an section Compatibility that describes the issue and how modders can fix it. #155 - ArmorEquipRollDLCPartChance #257 - OverrideUnitFocusUI #290 - ScreenStackSubClasses #313 - GetStatModifiersFixed #724 - DisplayCustomOverwatchActionPointOnUnitFlag #749 - OverrideAbilityIconColorImproved #763 - CustomTargetStyles #783 - ModifyGeneratedUnitAppearance #854 - OverrideCameraRotationAngle","title":"Compatibility"},{"location":"compatibility/#compatibility","text":"Because the Highlander is a core mod that many different mods on the workshop depend on, it strives to not make any observable changes to the base game (save for bug fixes and features that mods explicitly make use of). However, everything can potentially be a breaking change because the existing behavior rarely has any documentation in the game. Additionally, ModClassOverrides in mods occasionally override functions that were changed in the Highlander, essentially reverting the change and breaking a Highlander feature. As a result, sometimes modders need to pay special attention to Highlander features. This page is a list of pages tagged compatibility , indicating a potential incompatibility. Every page listed here has an section Compatibility that describes the issue and how modders can fix it. #155 - ArmorEquipRollDLCPartChance #257 - OverrideUnitFocusUI #290 - ScreenStackSubClasses #313 - GetStatModifiersFixed #724 - DisplayCustomOverwatchActionPointOnUnitFlag #749 - OverrideAbilityIconColorImproved #763 - CustomTargetStyles #783 - ModifyGeneratedUnitAppearance #854 - OverrideCameraRotationAngle","title":"Compatibility"},{"location":"customization/","text":"Customization This is a list of all pages tagged \"customization\". #155 - ArmorEquipRollDLCPartChance #169 - UpdateHumanPawnMeshMaterial #216 - UpdateHumanPawnMeshComponent #219 - ModAddedHeads #317 - PersonalitySpeech #328 - BodyPartTemplateNames #356 - TintMaterialConfigs #397 - ChangeDefaultWeaponColor #783 - ModifyGeneratedUnitAppearance #832 - AdjustPositionOfWeaponPawn","title":"Customization"},{"location":"customization/#customization","text":"This is a list of all pages tagged \"customization\". #155 - ArmorEquipRollDLCPartChance #169 - UpdateHumanPawnMeshMaterial #216 - UpdateHumanPawnMeshComponent #219 - ModAddedHeads #317 - PersonalitySpeech #328 - BodyPartTemplateNames #356 - TintMaterialConfigs #397 - ChangeDefaultWeaponColor #783 - ModifyGeneratedUnitAppearance #832 - AdjustPositionOfWeaponPawn","title":"Customization"},{"location":"dlc2/","text":"DLC2 DLC2 (also known as DLC_2, DLC_60, AH and Alien Hunters) is the DLC that introduces Alien Rulers into the game. This page contains a list of features that allow mods to control the behaviour of various features included in DLC2.","title":"DLC2"},{"location":"dlc2/#dlc2","text":"DLC2 (also known as DLC_2, DLC_60, AH and Alien Hunters) is the DLC that introduces Alien Rulers into the game. This page contains a list of features that allow mods to control the behaviour of various features included in DLC2.","title":"DLC2"},{"location":"events/","text":"Events Many of the Highlander's features utilize Event Hooks . Mods can subscribe to any event by name, and then Read some of the data passed with the event Perform actions in response to the event Send data back to the sender of the event Especially the last option is something many Highlander hooks expect mods to do. This is done with the XComLWTuple class. It can contain arbitrary tagged data, can be read and written to by mods. Consider it a polymorphic tuple that is compatible with any event trigger/listener signature. HL Event documentation All Highlander-triggered events use a specification that looks like the following: OverridePromotionUIClass event Param Value EventID OverridePromotionUIClass EventData XComLWTuple EventSource XComHQPresentationLayer NewGameState none Tuple contents Index Name Type Direction 0 PromotionScreenType enum (CHLPromotionScreenType) in 1 PromotionUIClass class (class<UIArmory_Promotion>) inout Listener template static function EventListenerReturn OnOverridePromotionUIClass(Object EventData, Object EventSource, XComGameState GameState, Name EventID, Object CallbackObject) { local XComHQPresentationLayer Pres; local XComLWTuple Tuple; local CHLPromotionScreenType PromotionScreenType; local class<UIArmory_Promotion> PromotionUIClass; Pres = XComHQPresentationLayer(EventSource); Tuple = XComLWTuple(EventData); PromotionScreenType = CHLPromotionScreenType(Tuple.Data[0].i); PromotionUIClass = class<UIArmory_Promotion>(Tuple.Data[1].o); // Your code here Tuple.Data[1].o = PromotionUIClass; return ELR_NoInterrupt; } The \"$event_name event\" paragraph describes which values a listener receives. EventID is the event name, EventData and EventSource list the types of the objects passed along, and NewGameState describes whether there is a NewGameState provided in the TriggerEvent call. If the EventData is an XComLWTuple , the \"Tuple contents\" paragraph lists the type and name of every variable passed using the tuple, along with its direction: An in variable has a meaningful value when the event is triggered, and mods may read it, usually to inspect the default value the game has determined. If a variable is not in , it may not be initialized when read from. An out variable will be read from by the game after all event listeners have been executed, usually with the expectation that a mod may have changed it to control some behaviors of the game. If a variable is not out , assigning to it is a no-op. An inout variable has a meaningful default value and will be read from after the event listeners have been executed. Note that exchanging data through an XComLWTuple requires subscribing to the event with the ELD_Immediate deferral. The \"Listener template\" is a copy-pasteable function that you can copy into your own mod as a starting point for using the event. Note: It is highly recommended that you use the CHEventListenerTemplate to subscribe to such events, as it is robust against history changes and allows you to provide the ELD_Immediate deferral. For this event, you would subscribe like this: Template.RegisterInStrategy = true; Template.AddCHEvent('OverridePromotionUIClass', OnOverridePromotionUIClass, ELD_Immediate, 50); Event-relevant pages The following is a list of all pages tagged \"Events\" due to their relevance to or use of the event system. #4 - CHEventListenerTemplate #93 - OverrideNumUpgradeSlots #106 - DynamicSoldierClassDisplay #110 - OnGetPCSImage #172 - OverrideHasHeavyWeapon #257 - OverrideUnitFocusUI #289 - ItemUpgraded #365 - Geoscape_ResInfoButtonVisible #365 - UIStrategyPolicy_ShowCovertActionsOnClose #368 - UIAvengerShortcuts_ShowCQResistanceOrders #391 - GetCovertActionEvents_Settings #393 - OverrideClipSize #400 - OverrideAbilityIconColor #408 - DynamicSoldierRankDisplay #420 - UpdateNavHelp #448 - OverrideDisableReinforcementsFlare #500 - OverrideEncounterZoneAnchorPoint #507 - OverridePatrolBehavior #534 - PsiProjectCompleted #561 - SitRepCheckAdditionalRequirements #562 - OnDistributeTacticalGameEndXp #562 - OverrideKillXp #562 - OverrideTotalNumKills #564 - AllowInteractHack #600 - OverridePromotionBlueprintTagPrefix #600 - OverridePromotionUIClass #624 - OverrideRespecSoldierProjectPoints #631 - OverrideShowPromoteIcon #633 - CanTechBeInspired #635 - OverrideMissionImage #650 - WillRecoveryTimeModifier #663 - UIResistanceReport_ShowCouncil #666 - ShouldCivilianRun #667 - OverrideNextRetaliationDisplay #676 - OnBestGearLoadoutApplied #694 - ItemAddedOrRemovedToSlot #711 - OverrideDarkEventCount #735 - OverrideHasAmmoPocket #735 - OverrideHasExtraUtilitySlot #735 - OverrideHasGrenadePocket #749 - OverrideAbilityIconColorImproved #752 - AllowOnCovertActionCompleteAnalytics #753 - PreDarkEventDeactivated #754 - XComLWTuple #774 - OverrideAllowStartingRegionLink #785 - PreCompleteStrategyFromTacticalTransfer #800 - PostInventoryLoadoutApplied #801 - FirstPromotionOverrideClass #807 - CovertAction_OverrideCostScalar #807 - CovertAction_OverrideRewardScalar #814 - ValidateGTSClassTraining #825 - OverrideHitEffects #829 - OverrideProjectileInstance #837 - KismetGameStateMatinee #842 - OverrideHasInfiniteAmmo #844 - ShowItemInLockerList #864 - WorldRegionGetMeshScale #864 - WorldRegionGetStaticMesh #871 - HeadquartersUnitFired #875 - OverrideCanTakeFacilityMission #903 - OverrideDamageRemovesReserveActionPoints #921 - OverrideWeaponScale #932 - StrategyMap_NavHelpUpdated #986 - UIStrategyPolicy_MiscEvents","title":"Events"},{"location":"events/#events","text":"Many of the Highlander's features utilize Event Hooks . Mods can subscribe to any event by name, and then Read some of the data passed with the event Perform actions in response to the event Send data back to the sender of the event Especially the last option is something many Highlander hooks expect mods to do. This is done with the XComLWTuple class. It can contain arbitrary tagged data, can be read and written to by mods. Consider it a polymorphic tuple that is compatible with any event trigger/listener signature.","title":"Events"},{"location":"events/#hl-event-documentation","text":"All Highlander-triggered events use a specification that looks like the following:","title":"HL Event documentation"},{"location":"events/#overridepromotionuiclass-event","text":"Param Value EventID OverridePromotionUIClass EventData XComLWTuple EventSource XComHQPresentationLayer NewGameState none","title":"OverridePromotionUIClass event"},{"location":"events/#tuple-contents","text":"Index Name Type Direction 0 PromotionScreenType enum (CHLPromotionScreenType) in 1 PromotionUIClass class (class<UIArmory_Promotion>) inout","title":"Tuple contents"},{"location":"events/#listener-template","text":"static function EventListenerReturn OnOverridePromotionUIClass(Object EventData, Object EventSource, XComGameState GameState, Name EventID, Object CallbackObject) { local XComHQPresentationLayer Pres; local XComLWTuple Tuple; local CHLPromotionScreenType PromotionScreenType; local class<UIArmory_Promotion> PromotionUIClass; Pres = XComHQPresentationLayer(EventSource); Tuple = XComLWTuple(EventData); PromotionScreenType = CHLPromotionScreenType(Tuple.Data[0].i); PromotionUIClass = class<UIArmory_Promotion>(Tuple.Data[1].o); // Your code here Tuple.Data[1].o = PromotionUIClass; return ELR_NoInterrupt; } The \"$event_name event\" paragraph describes which values a listener receives. EventID is the event name, EventData and EventSource list the types of the objects passed along, and NewGameState describes whether there is a NewGameState provided in the TriggerEvent call. If the EventData is an XComLWTuple , the \"Tuple contents\" paragraph lists the type and name of every variable passed using the tuple, along with its direction: An in variable has a meaningful value when the event is triggered, and mods may read it, usually to inspect the default value the game has determined. If a variable is not in , it may not be initialized when read from. An out variable will be read from by the game after all event listeners have been executed, usually with the expectation that a mod may have changed it to control some behaviors of the game. If a variable is not out , assigning to it is a no-op. An inout variable has a meaningful default value and will be read from after the event listeners have been executed. Note that exchanging data through an XComLWTuple requires subscribing to the event with the ELD_Immediate deferral. The \"Listener template\" is a copy-pasteable function that you can copy into your own mod as a starting point for using the event. Note: It is highly recommended that you use the CHEventListenerTemplate to subscribe to such events, as it is robust against history changes and allows you to provide the ELD_Immediate deferral. For this event, you would subscribe like this: Template.RegisterInStrategy = true; Template.AddCHEvent('OverridePromotionUIClass', OnOverridePromotionUIClass, ELD_Immediate, 50);","title":"Listener template"},{"location":"events/#event-relevant-pages","text":"The following is a list of all pages tagged \"Events\" due to their relevance to or use of the event system. #4 - CHEventListenerTemplate #93 - OverrideNumUpgradeSlots #106 - DynamicSoldierClassDisplay #110 - OnGetPCSImage #172 - OverrideHasHeavyWeapon #257 - OverrideUnitFocusUI #289 - ItemUpgraded #365 - Geoscape_ResInfoButtonVisible #365 - UIStrategyPolicy_ShowCovertActionsOnClose #368 - UIAvengerShortcuts_ShowCQResistanceOrders #391 - GetCovertActionEvents_Settings #393 - OverrideClipSize #400 - OverrideAbilityIconColor #408 - DynamicSoldierRankDisplay #420 - UpdateNavHelp #448 - OverrideDisableReinforcementsFlare #500 - OverrideEncounterZoneAnchorPoint #507 - OverridePatrolBehavior #534 - PsiProjectCompleted #561 - SitRepCheckAdditionalRequirements #562 - OnDistributeTacticalGameEndXp #562 - OverrideKillXp #562 - OverrideTotalNumKills #564 - AllowInteractHack #600 - OverridePromotionBlueprintTagPrefix #600 - OverridePromotionUIClass #624 - OverrideRespecSoldierProjectPoints #631 - OverrideShowPromoteIcon #633 - CanTechBeInspired #635 - OverrideMissionImage #650 - WillRecoveryTimeModifier #663 - UIResistanceReport_ShowCouncil #666 - ShouldCivilianRun #667 - OverrideNextRetaliationDisplay #676 - OnBestGearLoadoutApplied #694 - ItemAddedOrRemovedToSlot #711 - OverrideDarkEventCount #735 - OverrideHasAmmoPocket #735 - OverrideHasExtraUtilitySlot #735 - OverrideHasGrenadePocket #749 - OverrideAbilityIconColorImproved #752 - AllowOnCovertActionCompleteAnalytics #753 - PreDarkEventDeactivated #754 - XComLWTuple #774 - OverrideAllowStartingRegionLink #785 - PreCompleteStrategyFromTacticalTransfer #800 - PostInventoryLoadoutApplied #801 - FirstPromotionOverrideClass #807 - CovertAction_OverrideCostScalar #807 - CovertAction_OverrideRewardScalar #814 - ValidateGTSClassTraining #825 - OverrideHitEffects #829 - OverrideProjectileInstance #837 - KismetGameStateMatinee #842 - OverrideHasInfiniteAmmo #844 - ShowItemInLockerList #864 - WorldRegionGetMeshScale #864 - WorldRegionGetStaticMesh #871 - HeadquartersUnitFired #875 - OverrideCanTakeFacilityMission #903 - OverrideDamageRemovesReserveActionPoints #921 - OverrideWeaponScale #932 - StrategyMap_NavHelpUpdated #986 - UIStrategyPolicy_MiscEvents","title":"Event-relevant pages"},{"location":"loadoutslots/","text":"Loadout Slots The Highlander has a number of features to add new loadout slots, change existing loadout slot availability, or modify which items can be equipped under which conditions. This is a list of pages tagged \"Loadoutslots\". #118 - CustomInventorySlots #171 - GetNumHeavyWeaponSlotsOverride #172 - OverrideHasHeavyWeapon #735 - OverrideHasAmmoPocket #735 - OverrideHasExtraUtilitySlot #735 - OverrideHasGrenadePocket #881 - ExtendHasHeavyWeapon","title":"Loadout Slots"},{"location":"loadoutslots/#loadout-slots","text":"The Highlander has a number of features to add new loadout slots, change existing loadout slot availability, or modify which items can be equipped under which conditions. This is a list of pages tagged \"Loadoutslots\". #118 - CustomInventorySlots #171 - GetNumHeavyWeaponSlotsOverride #172 - OverrideHasHeavyWeapon #735 - OverrideHasAmmoPocket #735 - OverrideHasExtraUtilitySlot #735 - OverrideHasGrenadePocket #881 - ExtendHasHeavyWeapon","title":"Loadout Slots"},{"location":"pawns/","text":"Pawns In the context of XCOM 2, Pawns are the Unreal-3D representation of units and weapons. These Pawns define the 3D meshes and materials, their attachments, animations, and state. A pawn always has an archetype that is usually specified in the template. When a unit or weapon is spawned, a clone of the archetype is created and placed in the 3D world. This leaves mods that want to make modifications with two options: Modify the archetype: The archetype can be dynamically loaded ( RequestGameArchetype / DynamicLoadObject ) by mods for modification. This can, especially with many mods, take a fair while as some mods would have to load every archetype they want to modify. It also interacts badly with the garbage collector, as unused archetypes will be removed from memory and have their changes reverted. Additionally, these changes are static; all future instances will be affected the same and different instances cannot receive individual changes. Modify the instance: The mod finds a way to modify the instance that was just created as a clone. This allows mods to change things that are considered properties of the archetype on a per-instance basis. However, it is difficult to reliably receive a notification when an archetype is cloned and a new instance is created. The Highlander can help with this by triggering events and calling DLC hooks whenever mods may need to change instance properties. This page contains a list of features that can help with pawn modification on a per-instance basis. #169 - UpdateHumanPawnMeshMaterial #216 - UpdateHumanPawnMeshComponent #219 - ModAddedHeads #281 - DLCAppendWeaponSockets #356 - TintMaterialConfigs #885 - DisplayMultiSlotItems #921 - OverrideWeaponScale","title":"Pawns"},{"location":"pawns/#pawns","text":"In the context of XCOM 2, Pawns are the Unreal-3D representation of units and weapons. These Pawns define the 3D meshes and materials, their attachments, animations, and state. A pawn always has an archetype that is usually specified in the template. When a unit or weapon is spawned, a clone of the archetype is created and placed in the 3D world. This leaves mods that want to make modifications with two options: Modify the archetype: The archetype can be dynamically loaded ( RequestGameArchetype / DynamicLoadObject ) by mods for modification. This can, especially with many mods, take a fair while as some mods would have to load every archetype they want to modify. It also interacts badly with the garbage collector, as unused archetypes will be removed from memory and have their changes reverted. Additionally, these changes are static; all future instances will be affected the same and different instances cannot receive individual changes. Modify the instance: The mod finds a way to modify the instance that was just created as a clone. This allows mods to change things that are considered properties of the archetype on a per-instance basis. However, it is difficult to reliably receive a notification when an archetype is cloned and a new instance is created. The Highlander can help with this by triggering events and calling DLC hooks whenever mods may need to change instance properties. This page contains a list of features that can help with pawn modification on a per-instance basis. #169 - UpdateHumanPawnMeshMaterial #216 - UpdateHumanPawnMeshComponent #219 - ModAddedHeads #281 - DLCAppendWeaponSockets #356 - TintMaterialConfigs #885 - DisplayMultiSlotItems #921 - OverrideWeaponScale","title":"Pawns"},{"location":"ui/","text":"User Interface The XCOM 2 user interface is mostly built in flash, but offers custom components that can be used to produce quite sophisticated screens and UI elements. For documentation on base game features, see XCOM 2 War of the Chosen SDK/Documentation/Tech/XCOM2Mods_UserInterface.pdf . However, extending existing UI screens can prove quite difficult, as UI screens do not expose any hooks for extending input handling or navigation help additions. The following features can help with making UI more extensible. #106 - DynamicSoldierClassDisplay #110 - OnGetPCSImage #198 - SubscribeToOnInput #365 - Geoscape_ResInfoButtonVisible #365 - UIStrategyPolicy_ShowCovertActionsOnClose #368 - UIAvengerShortcuts_ShowCQResistanceOrders #391 - GetCovertActionEvents_Settings #408 - DynamicSoldierRankDisplay #440 - UIStrategyPolicy_ScreenInit #483 - UIScanButtonOnMouseEvent #491 - OverrideImageForItemAvaliable #501 - SubscribeToOnInputForScreen #600 - OverridePromotionBlueprintTagPrefix #600 - OverridePromotionUIClass #635 - OverrideMissionImage #663 - UIResistanceReport_ShowCouncil #875 - OverrideCanTakeFacilityMission #932 - StrategyMap_NavHelpUpdated #986 - UIStrategyPolicy_MiscEvents","title":"User Interface"},{"location":"ui/#user-interface","text":"The XCOM 2 user interface is mostly built in flash, but offers custom components that can be used to produce quite sophisticated screens and UI elements. For documentation on base game features, see XCOM 2 War of the Chosen SDK/Documentation/Tech/XCOM2Mods_UserInterface.pdf . However, extending existing UI screens can prove quite difficult, as UI screens do not expose any hooks for extending input handling or navigation help additions. The following features can help with making UI more extensible. #106 - DynamicSoldierClassDisplay #110 - OnGetPCSImage #198 - SubscribeToOnInput #365 - Geoscape_ResInfoButtonVisible #365 - UIStrategyPolicy_ShowCovertActionsOnClose #368 - UIAvengerShortcuts_ShowCQResistanceOrders #391 - GetCovertActionEvents_Settings #408 - DynamicSoldierRankDisplay #440 - UIStrategyPolicy_ScreenInit #483 - UIScanButtonOnMouseEvent #491 - OverrideImageForItemAvaliable #501 - SubscribeToOnInputForScreen #600 - OverridePromotionBlueprintTagPrefix #600 - OverridePromotionUIClass #635 - OverrideMissionImage #663 - UIResistanceReport_ShowCouncil #875 - OverrideCanTakeFacilityMission #932 - StrategyMap_NavHelpUpdated #986 - UIStrategyPolicy_MiscEvents","title":"User Interface"},{"location":"misc/AdjustPositionOfWeaponPawn/","text":"AdjustPositionOfWeaponPawn Tracking Issue: #832 Tags: customization When a weapon pawn is displayed in the weapon upgrade view it sets the position to the root bone of the mesh at the center of the screen. Some weapon models simply do not fit correctly on the screen and obscure the UI. This fix aims to adjust that. It moves the position of the created pawn by specified offset values from a config entry in the XComUI.ini . x is left/right with moving left being positive y is fore/aft with moving aft being positive (zoom level) z is up/down with moving up being positive Use this feature by creating the following lines in XComUI.ini : [XComGame.UIArmory_WeaponUpgrade] ;template ;+WeaponViewOffsets=(Template=, offset_x=0.0, offset_y=0.0, offset_z=0.0) ;example that shifts the sniper rifles to the left, up a little and slightly smaller +WeaponViewOffsets=(Template=SniperRifle_CV, offset_x=20, offset_y=10, offset_z=10) +WeaponViewOffsets=(Template=SniperRifle_MG, offset_x=20, offset_y=10, offset_z=10) +WeaponViewOffsets=(Template=SniperRifle_BM, offset_x=20, offset_y=10, offset_z=10) Source code references UIArmory_WeaponUpgrade.uc:1200-1217","title":"AdjustPositionOfWeaponPawn"},{"location":"misc/AdjustPositionOfWeaponPawn/#adjustpositionofweaponpawn","text":"Tracking Issue: #832 Tags: customization When a weapon pawn is displayed in the weapon upgrade view it sets the position to the root bone of the mesh at the center of the screen. Some weapon models simply do not fit correctly on the screen and obscure the UI. This fix aims to adjust that. It moves the position of the created pawn by specified offset values from a config entry in the XComUI.ini . x is left/right with moving left being positive y is fore/aft with moving aft being positive (zoom level) z is up/down with moving up being positive Use this feature by creating the following lines in XComUI.ini : [XComGame.UIArmory_WeaponUpgrade] ;template ;+WeaponViewOffsets=(Template=, offset_x=0.0, offset_y=0.0, offset_z=0.0) ;example that shifts the sniper rifles to the left, up a little and slightly smaller +WeaponViewOffsets=(Template=SniperRifle_CV, offset_x=20, offset_y=10, offset_z=10) +WeaponViewOffsets=(Template=SniperRifle_MG, offset_x=20, offset_y=10, offset_z=10) +WeaponViewOffsets=(Template=SniperRifle_BM, offset_x=20, offset_y=10, offset_z=10)","title":"AdjustPositionOfWeaponPawn"},{"location":"misc/AdjustPositionOfWeaponPawn/#source-code-references","text":"UIArmory_WeaponUpgrade.uc:1200-1217","title":"Source code references"},{"location":"misc/ArmorEquipRollDLCPartChance/","text":"ArmorEquipRollDLCPartChance Tracking Issue: #155 Tags: customization , compatibility When a unit equips new armor, the game rolls from all customization options, even the ones where the slider for the DLCName is set to 0 . The HL change fixes this. Compatibility If your custom armor only has customization options with a DLCName set, the game may discard that DLCName (default: in 85% of cases) which results in soldiers without torsos. If you want to keep having DLCName -only armor (for example to display mod icons in UICustomize ), you must disable that behavior by creating the following lines in XComGame.ini : [XComGame.CHHelpers] +CosmeticDLCNamesUnaffectedByRoll=MyDLCName Source code references XComGameState_Unit.uc:7928-7942 XComGame.ini:32","title":"ArmorEquipRollDLCPartChance"},{"location":"misc/ArmorEquipRollDLCPartChance/#armorequiprolldlcpartchance","text":"Tracking Issue: #155 Tags: customization , compatibility When a unit equips new armor, the game rolls from all customization options, even the ones where the slider for the DLCName is set to 0 . The HL change fixes this.","title":"ArmorEquipRollDLCPartChance"},{"location":"misc/ArmorEquipRollDLCPartChance/#compatibility","text":"If your custom armor only has customization options with a DLCName set, the game may discard that DLCName (default: in 85% of cases) which results in soldiers without torsos. If you want to keep having DLCName -only armor (for example to display mod icons in UICustomize ), you must disable that behavior by creating the following lines in XComGame.ini : [XComGame.CHHelpers] +CosmeticDLCNamesUnaffectedByRoll=MyDLCName","title":"Compatibility"},{"location":"misc/ArmorEquipRollDLCPartChance/#source-code-references","text":"XComGameState_Unit.uc:7928-7942 XComGame.ini:32","title":"Source code references"},{"location":"misc/BodyPartTemplateNames/","text":"BodyPartTemplateNames Tracking Issue: #328 Tags: customization Allows Torso, Arms and Legs customization pieces to be uniquely localized. For templates, localization (i.e. providing strings for in-game display like names or descriptions) is handled using the object name that is the same as the template name. For example, given a template name of 'Female_LongStraight' , the template is created by giving the X2BodyPartTemplate that name: // Object name -------vvvvvvvvvvvvvvvvvvv Template = new(None, \"Female_LongStraight\") class'X2BodyPartTemplate'; Template.SetTemplateName('Female_LongStraight'); // Template name ---------^^^^^^^^^^^^^^^^^^^ On the localization side, the object name is used to localize the DisplayName : ;vvvvvvvvvvvvvvvvvvv--- Object name [Female_LongStraight X2BodyPartTemplate] DisplayName=\"Long Straight\" Body part templates are different from normal templates in that templates for different customization categories are allowed to have the same name. In vanilla, there are collisions for Torso , Arms and Legs so there is a Conventional Medium Male Torso, an Arms piece, and a Legs piece with the name CnvMed_Std_A_M . However, in order for localization to work, there must be no object name collisions. As a result, the game opts to not assign any object name to Torsos, Arms, and Legs, and instead simply shows them as \"Torso 1\", \"Torso 2\" and so on. Because mods may want to localize their pieces, this Highlander change gives all armor pieces a unique object name. This happens using the following algorithm for every BodyPartTemplateConfig entry: If the PartType is not \"Torso\" , \"Arms\" , \"Legs\" , the object name and the template name are taken from TemplateName in the config entry (vanilla behavior). If the PartType is \"Torso\" , \"Arms\" , or \"Legs\" : If TemplateName contains that part type, then the object name and the template name are taken from TemplateName in the config entry. If TemplateName does not contain that part type, then the template name is taken from TemplateName , and the object name is created by appending an underscore and the part type to the template name. Additionally, the UI is changed to use the DisplayName for Torso/Arms/Legs, and fall back to numbered vanilla display if no DisplayName is provided. A table with some examples: Config PartType Config TemplateName Resulting Template Name Resulting Object Name \"Torso\" \"CnvMed_Std_A_M\" 'CnvMed_Std_A_M' \"CnvMed_Std_A_M_Torso\" \"Helmets\" \"Reaper_Hood_A_M\" 'Reaper_Hood_A_M' \"Reaper_Hood_A_M\" \"Torso\" \"DLC_30_Torso_M\" 'DLC_30_Torso_M' \"DLC_30_Torso_M\" Source code references X2BodyPartTemplateManager.uc:65-117 XComCharacterCustomization.uc:1108","title":"BodyPartTemplateNames"},{"location":"misc/BodyPartTemplateNames/#bodyparttemplatenames","text":"Tracking Issue: #328 Tags: customization Allows Torso, Arms and Legs customization pieces to be uniquely localized. For templates, localization (i.e. providing strings for in-game display like names or descriptions) is handled using the object name that is the same as the template name. For example, given a template name of 'Female_LongStraight' , the template is created by giving the X2BodyPartTemplate that name: // Object name -------vvvvvvvvvvvvvvvvvvv Template = new(None, \"Female_LongStraight\") class'X2BodyPartTemplate'; Template.SetTemplateName('Female_LongStraight'); // Template name ---------^^^^^^^^^^^^^^^^^^^ On the localization side, the object name is used to localize the DisplayName : ;vvvvvvvvvvvvvvvvvvv--- Object name [Female_LongStraight X2BodyPartTemplate] DisplayName=\"Long Straight\" Body part templates are different from normal templates in that templates for different customization categories are allowed to have the same name. In vanilla, there are collisions for Torso , Arms and Legs so there is a Conventional Medium Male Torso, an Arms piece, and a Legs piece with the name CnvMed_Std_A_M . However, in order for localization to work, there must be no object name collisions. As a result, the game opts to not assign any object name to Torsos, Arms, and Legs, and instead simply shows them as \"Torso 1\", \"Torso 2\" and so on. Because mods may want to localize their pieces, this Highlander change gives all armor pieces a unique object name. This happens using the following algorithm for every BodyPartTemplateConfig entry: If the PartType is not \"Torso\" , \"Arms\" , \"Legs\" , the object name and the template name are taken from TemplateName in the config entry (vanilla behavior). If the PartType is \"Torso\" , \"Arms\" , or \"Legs\" : If TemplateName contains that part type, then the object name and the template name are taken from TemplateName in the config entry. If TemplateName does not contain that part type, then the template name is taken from TemplateName , and the object name is created by appending an underscore and the part type to the template name. Additionally, the UI is changed to use the DisplayName for Torso/Arms/Legs, and fall back to numbered vanilla display if no DisplayName is provided. A table with some examples: Config PartType Config TemplateName Resulting Template Name Resulting Object Name \"Torso\" \"CnvMed_Std_A_M\" 'CnvMed_Std_A_M' \"CnvMed_Std_A_M_Torso\" \"Helmets\" \"Reaper_Hood_A_M\" 'Reaper_Hood_A_M' \"Reaper_Hood_A_M\" \"Torso\" \"DLC_30_Torso_M\" 'DLC_30_Torso_M' \"DLC_30_Torso_M\"","title":"BodyPartTemplateNames"},{"location":"misc/BodyPartTemplateNames/#source-code-references","text":"X2BodyPartTemplateManager.uc:65-117 XComCharacterCustomization.uc:1108","title":"Source code references"},{"location":"misc/CHEventListenerTemplate/","text":"CHEventListenerTemplate Tracking Issue: #4 Tags: events Allows mods to set up Event Listener classes with specified Deferral and Priority, similar to X2AbilityTrigger_EventListener. The AddCHEvent function accepts up to four arguments: Name of the Event to listen for. EventFn to run when the event is triggered. Optional: Deferral (default deferral is ELD_OnStateSubmitted). Visit the r/xcom2mods wiki for info on Deferrals. Optional: Priority (default priority is 50). Event listeners with the larger priority number are executed first. Example use: class X2EventListener_YourEventListener extends X2EventListener; static function array<X2DataTemplate> CreateTemplates() { local array<X2DataTemplate> Templates; // You can create any number of Event Listener templates within one X2EventListener class. Templates.AddItem(CreateListenerTemplate_YourListener()); return Templates; } static function CHEventListenerTemplate CreateListenerTemplate_OnBestGearLoadoutApplied() { local CHEventListenerTemplate Template; `CREATE_X2TEMPLATE(class'CHEventListenerTemplate', Template, 'Your_Custom_BestGearApplied_Listener'); // Whether this Listener should be active during tactical missions. Template.RegisterInTactical = true; // Whether this Listener should be active on the strategic layer (while on Avenger) Template.RegisterInStrategy = true; Template.AddCHEvent('EventName', YourEventFn_Listener, ELD_Immediate, 50); return Template; } static function EventListenerReturn YourEventFn_Listener(Object EventData, Object EventSource, XComGameState NewGameState, Name Event, Object CallbackData) { if (GameState.GetContext().InterruptionStatus == eInterruptionStatus_Interrupt) { // Perform actions if the event was triggered during interruption stage. } else { // Perform actions outside interruption stage (after an ability was successfully activated, for example) } return ELR_NoInterrupt; } Source code references CHEventListenerTemplate.uc:2-55","title":"CHEventListenerTemplate"},{"location":"misc/CHEventListenerTemplate/#cheventlistenertemplate","text":"Tracking Issue: #4 Tags: events Allows mods to set up Event Listener classes with specified Deferral and Priority, similar to X2AbilityTrigger_EventListener. The AddCHEvent function accepts up to four arguments: Name of the Event to listen for. EventFn to run when the event is triggered. Optional: Deferral (default deferral is ELD_OnStateSubmitted). Visit the r/xcom2mods wiki for info on Deferrals. Optional: Priority (default priority is 50). Event listeners with the larger priority number are executed first. Example use: class X2EventListener_YourEventListener extends X2EventListener; static function array<X2DataTemplate> CreateTemplates() { local array<X2DataTemplate> Templates; // You can create any number of Event Listener templates within one X2EventListener class. Templates.AddItem(CreateListenerTemplate_YourListener()); return Templates; } static function CHEventListenerTemplate CreateListenerTemplate_OnBestGearLoadoutApplied() { local CHEventListenerTemplate Template; `CREATE_X2TEMPLATE(class'CHEventListenerTemplate', Template, 'Your_Custom_BestGearApplied_Listener'); // Whether this Listener should be active during tactical missions. Template.RegisterInTactical = true; // Whether this Listener should be active on the strategic layer (while on Avenger) Template.RegisterInStrategy = true; Template.AddCHEvent('EventName', YourEventFn_Listener, ELD_Immediate, 50); return Template; } static function EventListenerReturn YourEventFn_Listener(Object EventData, Object EventSource, XComGameState NewGameState, Name Event, Object CallbackData) { if (GameState.GetContext().InterruptionStatus == eInterruptionStatus_Interrupt) { // Perform actions if the event was triggered during interruption stage. } else { // Perform actions outside interruption stage (after an ability was successfully activated, for example) } return ELR_NoInterrupt; }","title":"CHEventListenerTemplate"},{"location":"misc/CHEventListenerTemplate/#source-code-references","text":"CHEventListenerTemplate.uc:2-55","title":"Source code references"},{"location":"misc/ChangeDefaultWeaponColor/","text":"ChangeDefaultWeaponColor Tracking Issue: #397 Tags: customization Soldiers with randomly generated appearance get the beige weapon color by default (color number 20). This change moves the default weapon color number to XComContent.ini , where it can be changed by mods or by the player manually. [XComGame.XGCharacterGenerator] iDefaultWeaponTint = 20 Source code references XGCharacterGenerator.uc:902-909","title":"ChangeDefaultWeaponColor"},{"location":"misc/ChangeDefaultWeaponColor/#changedefaultweaponcolor","text":"Tracking Issue: #397 Tags: customization Soldiers with randomly generated appearance get the beige weapon color by default (color number 20). This change moves the default weapon color number to XComContent.ini , where it can be changed by mods or by the player manually. [XComGame.XGCharacterGenerator] iDefaultWeaponTint = 20","title":"ChangeDefaultWeaponColor"},{"location":"misc/ChangeDefaultWeaponColor/#source-code-references","text":"XGCharacterGenerator.uc:902-909","title":"Source code references"},{"location":"misc/ClassIsNative/","text":"ClassIsNative Tracking Issue: #767 To check whether a given class is native, use the static function CH_ClassIsNative . Example usage: CH_ClassIsNative(class'X2AbilityTarget_Single'); // True CH_ClassIsNative(UnitState.GetVisualizer().Class); // False because XGUnit is always non-native Source code references Object.uc:2405-2412","title":"ClassIsNative"},{"location":"misc/ClassIsNative/#classisnative","text":"Tracking Issue: #767 To check whether a given class is native, use the static function CH_ClassIsNative . Example usage: CH_ClassIsNative(class'X2AbilityTarget_Single'); // True CH_ClassIsNative(UnitState.GetVisualizer().Class); // False because XGUnit is always non-native","title":"ClassIsNative"},{"location":"misc/ClassIsNative/#source-code-references","text":"Object.uc:2405-2412","title":"Source code references"},{"location":"misc/ComponentVersions/","text":"ComponentVersions Tracking Issue: #765 Both the Highlander and mods using it may be interested in whether replacements for base game packages (\"components\") are installed, and if, which version. This can be used to Behave differently depending on whether a HL feature is available Provide more targeted error messages when a certain HL version is required For example, if you are interested in whether version 1.19.0 of the Highlander is correctly enabled, you can use the following: if (class'CHXComGameVersionTemplate' != none && (class'CHXComGameVersionTemplate'.default.MajorVersion > 1 || (class'CHXComGameVersionTemplate'.default.MajorVersion == 1 && class'CHXComGameVersionTemplate'.default.MinorVersion >= 19) ) ) { // Installed, do thing A } else { // Not installed or wrong version, do thing B } For other classes, see Source code references below. Note that you can employ feature-based detection if the feature can be distinguished by the presence of a certain function or property. For example, OverrideUnitFocusUI can be detected with the following trick: if (Function'XComGame.CHHelpers.GetFocusTuple' != none) { // Feature present } else { // Feature absent } Source code references CHXComGameVersionTemplate.uc:12-55 CHCoreVersion.uc:1 CHEngineVersion.uc:1 CHX2WOTCCHVersion.uc:1","title":"ComponentVersions"},{"location":"misc/ComponentVersions/#componentversions","text":"Tracking Issue: #765 Both the Highlander and mods using it may be interested in whether replacements for base game packages (\"components\") are installed, and if, which version. This can be used to Behave differently depending on whether a HL feature is available Provide more targeted error messages when a certain HL version is required For example, if you are interested in whether version 1.19.0 of the Highlander is correctly enabled, you can use the following: if (class'CHXComGameVersionTemplate' != none && (class'CHXComGameVersionTemplate'.default.MajorVersion > 1 || (class'CHXComGameVersionTemplate'.default.MajorVersion == 1 && class'CHXComGameVersionTemplate'.default.MinorVersion >= 19) ) ) { // Installed, do thing A } else { // Not installed or wrong version, do thing B } For other classes, see Source code references below. Note that you can employ feature-based detection if the feature can be distinguished by the presence of a certain function or property. For example, OverrideUnitFocusUI can be detected with the following trick: if (Function'XComGame.CHHelpers.GetFocusTuple' != none) { // Feature present } else { // Feature absent }","title":"ComponentVersions"},{"location":"misc/ComponentVersions/#source-code-references","text":"CHXComGameVersionTemplate.uc:12-55 CHCoreVersion.uc:1 CHEngineVersion.uc:1 CHX2WOTCCHVersion.uc:1","title":"Source code references"},{"location":"misc/CustomInventorySlots/","text":"CustomInventorySlots Tracking Issue: #118 Tags: loadoutslots This feature defines additional inventory slots in the Highlander for mods to use. Configuration is done via CHItemSlot . More docs to follow. enum EInventorySlot { eInvSlot_Unknown, eInvSlot_Armor, eInvSlot_PrimaryWeapon, eInvSlot_SecondaryWeapon, eInvSlot_HeavyWeapon, eInvSlot_Utility, eInvSlot_Mission, eInvSlot_Backpack, eInvSlot_Loot, eInvSlot_GrenadePocket, eInvSlot_CombatSim, eInvSlot_AmmoPocket, eInvSlot_TertiaryWeapon, eInvSlot_QuaternaryWeapon, eInvSlot_QuinaryWeapon, eInvSlot_SenaryWeapon, eInvSlot_SeptenaryWeapon, // Add a marker slot, and buffer in case Firaxis adds more in the future // ALL MARKER SLOTS SHOULD NOT BE USED IN CODE OTHER THAN XCOMGAME // CHItemSlotTemplate has static helper functions for this purpose! // Since enums are compile-time constants, mods may have old values // that don't apply anymore for markers. eInvSlot_END_VANILLA_SLOTS, eInvSlot_Buffer018, eInvSlot_Buffer019, eInvSlot_Buffer020, eInvSlot_Buffer021, eInvSlot_Buffer022, eInvSlot_Buffer023, eInvSlot_Buffer024, eInvSlot_Buffer025, eInvSlot_Buffer026, eInvSlot_Buffer027, eInvSlot_Buffer028, eInvSlot_Buffer029, eInvSlot_Buffer030, eInvSlot_Buffer031, // again, don't use in mod code eInvSlot_BEGIN_TEMPLATED_SLOTS, // Custom slots begin here. We have space for ~220 slots, should be enough! // These slots can be used in Mod code and config values eInvSlot_Vest, eInvSlot_AugmentationHead, eInvSlot_AugmentationTorso, eInvSlot_AugmentationArms, eInvSlot_AugmentationLegs, eInvSlot_CombatDrugs, eInvSlot_Decorations, eInvSlot_PsiAmp, eInvSlot_Plating, eInvSlot_SparkLauncher, eInvSlot_ExtraSecondary, eInvSlot_PrimaryPayload, eInvSlot_SecondaryPayload, eInvSlot_ExtraRocket1, eInvSlot_ExtraRocket2, eInvSlot_ExtraRocket3, eInvSlot_ExtraRocket4, eInvSlot_Pistol, eInvSlot_Wings, eInvSlot_ExtraBackpack, eInvSlot_SparkGrenadePocket, eInvSlot_AuxiliaryWeapon, eInvSlot_AModMedical, eInvSlot_ArmorMod, eInvSlot_TacticalGadget, eInvSlot_MZAux, eInvSlot_TemplateMaster, // Marker slot, don't use eInvSlot_END_TEMPLATED_SLOTS, }; If you need additional enum entries, request them in the tracking issue. Source code references X2TacticalGameRulesetDataStructures.uc:38-118 CHItemSlot.uc:13","title":"CustomInventorySlots"},{"location":"misc/CustomInventorySlots/#custominventoryslots","text":"Tracking Issue: #118 Tags: loadoutslots This feature defines additional inventory slots in the Highlander for mods to use. Configuration is done via CHItemSlot . More docs to follow. enum EInventorySlot { eInvSlot_Unknown, eInvSlot_Armor, eInvSlot_PrimaryWeapon, eInvSlot_SecondaryWeapon, eInvSlot_HeavyWeapon, eInvSlot_Utility, eInvSlot_Mission, eInvSlot_Backpack, eInvSlot_Loot, eInvSlot_GrenadePocket, eInvSlot_CombatSim, eInvSlot_AmmoPocket, eInvSlot_TertiaryWeapon, eInvSlot_QuaternaryWeapon, eInvSlot_QuinaryWeapon, eInvSlot_SenaryWeapon, eInvSlot_SeptenaryWeapon, // Add a marker slot, and buffer in case Firaxis adds more in the future // ALL MARKER SLOTS SHOULD NOT BE USED IN CODE OTHER THAN XCOMGAME // CHItemSlotTemplate has static helper functions for this purpose! // Since enums are compile-time constants, mods may have old values // that don't apply anymore for markers. eInvSlot_END_VANILLA_SLOTS, eInvSlot_Buffer018, eInvSlot_Buffer019, eInvSlot_Buffer020, eInvSlot_Buffer021, eInvSlot_Buffer022, eInvSlot_Buffer023, eInvSlot_Buffer024, eInvSlot_Buffer025, eInvSlot_Buffer026, eInvSlot_Buffer027, eInvSlot_Buffer028, eInvSlot_Buffer029, eInvSlot_Buffer030, eInvSlot_Buffer031, // again, don't use in mod code eInvSlot_BEGIN_TEMPLATED_SLOTS, // Custom slots begin here. We have space for ~220 slots, should be enough! // These slots can be used in Mod code and config values eInvSlot_Vest, eInvSlot_AugmentationHead, eInvSlot_AugmentationTorso, eInvSlot_AugmentationArms, eInvSlot_AugmentationLegs, eInvSlot_CombatDrugs, eInvSlot_Decorations, eInvSlot_PsiAmp, eInvSlot_Plating, eInvSlot_SparkLauncher, eInvSlot_ExtraSecondary, eInvSlot_PrimaryPayload, eInvSlot_SecondaryPayload, eInvSlot_ExtraRocket1, eInvSlot_ExtraRocket2, eInvSlot_ExtraRocket3, eInvSlot_ExtraRocket4, eInvSlot_Pistol, eInvSlot_Wings, eInvSlot_ExtraBackpack, eInvSlot_SparkGrenadePocket, eInvSlot_AuxiliaryWeapon, eInvSlot_AModMedical, eInvSlot_ArmorMod, eInvSlot_TacticalGadget, eInvSlot_MZAux, eInvSlot_TemplateMaster, // Marker slot, don't use eInvSlot_END_TEMPLATED_SLOTS, }; If you need additional enum entries, request them in the tracking issue.","title":"CustomInventorySlots"},{"location":"misc/CustomInventorySlots/#source-code-references","text":"X2TacticalGameRulesetDataStructures.uc:38-118 CHItemSlot.uc:13","title":"Source code references"},{"location":"misc/DLCAppendWeaponSockets/","text":"DLCAppendWeaponSockets Tracking Issue: #281 Tags: pawns Allows mods to add, move and rescale sockets on the skeletal mesh of any weapon, which can be used to position visual weapon attachments, using different position/scale of the same attachment's skeletal mesh for different weapons. Example use: static function DLCAppendWeaponSockets(out array<SkeletalMeshSocket> NewSockets, XComWeapon Weapon, XComGameState_Item ItemState) { local SkeletalMeshSocket Socket; local vector RelativeLocation; local rotator RelativeRotation; local vector RelativeScale; if (ItemState != none) { Socket = new class'SkeletalMeshSocket'; Socket.SocketName = 'NewSocket'; Socket.BoneName = 'root'; // Location offsets are in Unreal Units; 1 unit is roughly equal to a centimeter. RelativeLocation.X = 5; RelativeLocation.Y = 10; RelativeLocation.Z = 15; Socket.RelativeLocation = RelativeLocation; // Socket rotation is recorded as an int value [-65535; 65535], which corresponds with [-360 degrees; 360 degrees] // If we want to specify the rotation in degrees, the value must be converted using DegToUnrRot, a const in the Object class. RelativeRotation.Pitch = 5 * DegToUnrRot; // Pitch of five degrees. RelativeRotation.Yaw = 10 * DegToUnrRot; RelativeRotation.Roll = 15 * DegToUnrRot; Socket.RelativeRotation = RelativeRotation; // Scaling a socket will scale any mesh attached to it. RelativeScale.X = 0.25f; RelativeScale.Y = 0.5f; RelativeScale.Z = 1.0f; Socket.RelativeScale = RelativeScale; NewSockets.AddItem(Socket); } } Sockets that have the name of an existing socket will replace the original socket. This can be used to move, rotate, and rescale existing sockets. Source code references X2DownloadableContentInfo.uc:572-615","title":"DLCAppendWeaponSockets"},{"location":"misc/DLCAppendWeaponSockets/#dlcappendweaponsockets","text":"Tracking Issue: #281 Tags: pawns Allows mods to add, move and rescale sockets on the skeletal mesh of any weapon, which can be used to position visual weapon attachments, using different position/scale of the same attachment's skeletal mesh for different weapons. Example use: static function DLCAppendWeaponSockets(out array<SkeletalMeshSocket> NewSockets, XComWeapon Weapon, XComGameState_Item ItemState) { local SkeletalMeshSocket Socket; local vector RelativeLocation; local rotator RelativeRotation; local vector RelativeScale; if (ItemState != none) { Socket = new class'SkeletalMeshSocket'; Socket.SocketName = 'NewSocket'; Socket.BoneName = 'root'; // Location offsets are in Unreal Units; 1 unit is roughly equal to a centimeter. RelativeLocation.X = 5; RelativeLocation.Y = 10; RelativeLocation.Z = 15; Socket.RelativeLocation = RelativeLocation; // Socket rotation is recorded as an int value [-65535; 65535], which corresponds with [-360 degrees; 360 degrees] // If we want to specify the rotation in degrees, the value must be converted using DegToUnrRot, a const in the Object class. RelativeRotation.Pitch = 5 * DegToUnrRot; // Pitch of five degrees. RelativeRotation.Yaw = 10 * DegToUnrRot; RelativeRotation.Roll = 15 * DegToUnrRot; Socket.RelativeRotation = RelativeRotation; // Scaling a socket will scale any mesh attached to it. RelativeScale.X = 0.25f; RelativeScale.Y = 0.5f; RelativeScale.Z = 1.0f; Socket.RelativeScale = RelativeScale; NewSockets.AddItem(Socket); } } Sockets that have the name of an existing socket will replace the original socket. This can be used to move, rotate, and rescale existing sockets.","title":"DLCAppendWeaponSockets"},{"location":"misc/DLCAppendWeaponSockets/#source-code-references","text":"X2DownloadableContentInfo.uc:572-615","title":"Source code references"},{"location":"misc/DebugStartSecondWave/","text":"DebugStartSecondWave Tracking Issue: #197 A debug strategy start by default uses Beta Strike and no other second wave options. This change disables Beta Strike by default and makes the list configurable. XComGameData.ini : [XComGame.XGStrategy] ; uncomment for Beta Strike ;+DEBUG_SecondWaveOptions=\"BetaStrike\" Source code references XGStrategy.uc:762-764 XComGameData.ini:1-7","title":"DebugStartSecondWave"},{"location":"misc/DebugStartSecondWave/#debugstartsecondwave","text":"Tracking Issue: #197 A debug strategy start by default uses Beta Strike and no other second wave options. This change disables Beta Strike by default and makes the list configurable. XComGameData.ini : [XComGame.XGStrategy] ; uncomment for Beta Strike ;+DEBUG_SecondWaveOptions=\"BetaStrike\"","title":"DebugStartSecondWave"},{"location":"misc/DebugStartSecondWave/#source-code-references","text":"XGStrategy.uc:762-764 XComGameData.ini:1-7","title":"Source code references"},{"location":"misc/DisplayMultiSlotItems/","text":"DisplayMultiSlotItems Tracking Issue: #885 Tags: pawns This feature allows mods to allow items equipped in multi-item inventory slots to be visible on soldiers' bodies. The vanilla behavior is that only the first item in the Utility Slot is visible on the soldier's body, and only in Tactical, but not in the Armory. Using this feature it's possible to show all items in all multi-slots, including Highlander-templated slots. There are two delegates: // Used to decide whether the specified item should be visible on specified unit in the Armory, Squad Select and Post Mission Sequence. delegate EHLDelegateReturn ShouldDisplayMultiSlotItemInStrategyDelegate(XComGameState_Unit UnitState, XComGameState_Item ItemState, out int bDisplayItem, XComUnitPawn UnitPawn, optional XComGameState CheckGameState); // Same as above, but for Tactical. delegate EHLDelegateReturn ShouldDisplayMultiSlotItemInTacticalDelegate(XComGameState_Unit UnitState, XComGameState_Item ItemState, out int bDisplayItem, XGUnit UnitVisualizer, optional XComGameState CheckGameState); How to use Delegates must be added to the CHHelpers ClassDefaultObject. Normally this is done in OnPostTemplatesCreated via AddShouldDisplayMultiSlotItemInStrategyCallback and AddShouldDisplayMultiSlotItemInTacticalCallback . Warning: Delegates must be bound to the ClassDefaultObject of your class, otherwise the game will hard crash due to a garbage collection failure when transitioning between layers. Implementing your methods in a class that extends X2DownloadableContentInfo will automatically handle this for you. Both delegates have the out int bDisplayItem argument. Set it to any value above zero to display the item on the soldier's body. Set to 0 to keep the item hidden. Highlander-templated slots also need to have NeedsPresEquip=true to display in Tactical, and ShowOnCinematicPawns=true to display in the Armory and Squad Select. Both delegates should return EHLDR_NoInterrupt to allow subsequent delegates to run and potentially override the value you have assigned to bDisplayItem , or EHLDR_InterruptDelegates to not allow any subsequent delegates to run. A priority can be supplied to the AddShouldDisplay... functions, where a higher-priority callback runs earlier. You can get the template name of the item in question from the provided ItemState by doing ItemState.GetMyTemplateName() , and access its Inventory Slot as ItemState.InventorySlot . Both delegates may or may not provide you with an XComGameState that can be used to access accompanying state objects, for example: if (CheckGameState != none) { MyState = CheckGameState.GetGameStateForObjectID(ObjectID); } if (MyState == none) { MyState = `XCOMHISTORY.GetGameStateForObjectID(ObjectID); } // Alternatively, for items in a unit's inventory: ItemState = UnitState.GetItemGameState(ItemRef, CheckGameState); ItemState = UnitState.GetItemInSlot(eInvSlot_PrimaryWeapon, CheckGameState); ItemStates = UnitState.GetAllItemsInSlot(eInvSlot_Utility, CheckGameState); This is mostly relevant for multiplayer, as the pre-game setup doesn't have a History. Example Here's a simple example of a delegate pair that will display all items equipped in the Utility Slot in both Tactical and Strategy. This needs to go in a class that extends X2DownloadableContentInfo . static event OnPostTemplatesCreated() { local CHHelpers CHHelpersObj; CHHelpersObj = class'CHHelpers'.static.GetCDO(); if (CHHelpersObj != none) { CHHelpersObj.AddShouldDisplayMultiSlotItemInStrategyCallback(ShouldDisplayMultiSlotItemInStrategyDelegate, 50); CHHelpersObj.AddShouldDisplayMultiSlotItemInTacticalCallback(ShouldDisplayMultiSlotItemInTacticalDelegate, 50); } } static private function EHLDelegateReturn ShouldDisplayMultiSlotItemInStrategyDelegate(XComGameState_Unit UnitState, XComGameState_Item ItemState, out int bDisplayItem, XComUnitPawn UnitPawn, optional XComGameState CheckGameState) { ShouldDisplayUtilitySlotItem(ItemState, bDisplayItem); // Return this to allow following Delegates to override the output of this delegate. return EHLDR_NoInterrupt; } static private function bool ShouldDisplayMultiSlotItemInTacticalDelegate(XComGameState_Unit UnitState, XComGameState_Item ItemState, out int bDisplayItem, XGUnit UnitVisualizer, optional XComGameState CheckGameState); { return ShouldDisplayUtilitySlotItem(ItemState, bDisplayItem); return EHLDR_NoInterrupt; } static private function ShouldDisplayUtilitySlotItem(XComGameState_Item ItemState, out int bDisplayItem) { local X2EquipmentTemplate EqTemplate; if (ItemState.InventorySlot == eInvSlot_Utility) { EqTemplate = X2EquipmentTemplate(ItemState.GetMyTemplate()); if (EqTemplate != none && EqTemplate.iItemSize > 0) { bDisplayItem = 1; } } } Source code references CHHelpers.uc:602-700 CHHelpers.uc:702 CHHelpers.uc:780","title":"DisplayMultiSlotItems"},{"location":"misc/DisplayMultiSlotItems/#displaymultislotitems","text":"Tracking Issue: #885 Tags: pawns This feature allows mods to allow items equipped in multi-item inventory slots to be visible on soldiers' bodies. The vanilla behavior is that only the first item in the Utility Slot is visible on the soldier's body, and only in Tactical, but not in the Armory. Using this feature it's possible to show all items in all multi-slots, including Highlander-templated slots. There are two delegates: // Used to decide whether the specified item should be visible on specified unit in the Armory, Squad Select and Post Mission Sequence. delegate EHLDelegateReturn ShouldDisplayMultiSlotItemInStrategyDelegate(XComGameState_Unit UnitState, XComGameState_Item ItemState, out int bDisplayItem, XComUnitPawn UnitPawn, optional XComGameState CheckGameState); // Same as above, but for Tactical. delegate EHLDelegateReturn ShouldDisplayMultiSlotItemInTacticalDelegate(XComGameState_Unit UnitState, XComGameState_Item ItemState, out int bDisplayItem, XGUnit UnitVisualizer, optional XComGameState CheckGameState);","title":"DisplayMultiSlotItems"},{"location":"misc/DisplayMultiSlotItems/#how-to-use","text":"Delegates must be added to the CHHelpers ClassDefaultObject. Normally this is done in OnPostTemplatesCreated via AddShouldDisplayMultiSlotItemInStrategyCallback and AddShouldDisplayMultiSlotItemInTacticalCallback . Warning: Delegates must be bound to the ClassDefaultObject of your class, otherwise the game will hard crash due to a garbage collection failure when transitioning between layers. Implementing your methods in a class that extends X2DownloadableContentInfo will automatically handle this for you. Both delegates have the out int bDisplayItem argument. Set it to any value above zero to display the item on the soldier's body. Set to 0 to keep the item hidden. Highlander-templated slots also need to have NeedsPresEquip=true to display in Tactical, and ShowOnCinematicPawns=true to display in the Armory and Squad Select. Both delegates should return EHLDR_NoInterrupt to allow subsequent delegates to run and potentially override the value you have assigned to bDisplayItem , or EHLDR_InterruptDelegates to not allow any subsequent delegates to run. A priority can be supplied to the AddShouldDisplay... functions, where a higher-priority callback runs earlier. You can get the template name of the item in question from the provided ItemState by doing ItemState.GetMyTemplateName() , and access its Inventory Slot as ItemState.InventorySlot . Both delegates may or may not provide you with an XComGameState that can be used to access accompanying state objects, for example: if (CheckGameState != none) { MyState = CheckGameState.GetGameStateForObjectID(ObjectID); } if (MyState == none) { MyState = `XCOMHISTORY.GetGameStateForObjectID(ObjectID); } // Alternatively, for items in a unit's inventory: ItemState = UnitState.GetItemGameState(ItemRef, CheckGameState); ItemState = UnitState.GetItemInSlot(eInvSlot_PrimaryWeapon, CheckGameState); ItemStates = UnitState.GetAllItemsInSlot(eInvSlot_Utility, CheckGameState); This is mostly relevant for multiplayer, as the pre-game setup doesn't have a History.","title":"How to use"},{"location":"misc/DisplayMultiSlotItems/#example","text":"Here's a simple example of a delegate pair that will display all items equipped in the Utility Slot in both Tactical and Strategy. This needs to go in a class that extends X2DownloadableContentInfo . static event OnPostTemplatesCreated() { local CHHelpers CHHelpersObj; CHHelpersObj = class'CHHelpers'.static.GetCDO(); if (CHHelpersObj != none) { CHHelpersObj.AddShouldDisplayMultiSlotItemInStrategyCallback(ShouldDisplayMultiSlotItemInStrategyDelegate, 50); CHHelpersObj.AddShouldDisplayMultiSlotItemInTacticalCallback(ShouldDisplayMultiSlotItemInTacticalDelegate, 50); } } static private function EHLDelegateReturn ShouldDisplayMultiSlotItemInStrategyDelegate(XComGameState_Unit UnitState, XComGameState_Item ItemState, out int bDisplayItem, XComUnitPawn UnitPawn, optional XComGameState CheckGameState) { ShouldDisplayUtilitySlotItem(ItemState, bDisplayItem); // Return this to allow following Delegates to override the output of this delegate. return EHLDR_NoInterrupt; } static private function bool ShouldDisplayMultiSlotItemInTacticalDelegate(XComGameState_Unit UnitState, XComGameState_Item ItemState, out int bDisplayItem, XGUnit UnitVisualizer, optional XComGameState CheckGameState); { return ShouldDisplayUtilitySlotItem(ItemState, bDisplayItem); return EHLDR_NoInterrupt; } static private function ShouldDisplayUtilitySlotItem(XComGameState_Item ItemState, out int bDisplayItem) { local X2EquipmentTemplate EqTemplate; if (ItemState.InventorySlot == eInvSlot_Utility) { EqTemplate = X2EquipmentTemplate(ItemState.GetMyTemplate()); if (EqTemplate != none && EqTemplate.iItemSize > 0) { bDisplayItem = 1; } } }","title":"Example"},{"location":"misc/DisplayMultiSlotItems/#source-code-references","text":"CHHelpers.uc:602-700 CHHelpers.uc:702 CHHelpers.uc:780","title":"Source code references"},{"location":"misc/GetCrossClassAbilities_CH/","text":"GetCrossClassAbilities_CH Tracking Issue: #62 The CH variant of GetCrossClassAbilities compared to vanilla does two things differently: - Adds a check to ensure that the ability to be added to the CrossClassAbilities list isn't already in the soldiers default ability tree. - This variant supersedes issue #30 by checking against the actual abilities in the current soldiers tree, instead of comparing against all the potential abilities the soldier could have had available. This is especially important when classes uses the RandomAbilityDecks, since otherwise in the worst case scenario, you could end up with no available cross class abilities. The old function is kept in case mods call it, but is otherwise ignored throughout the XComGame codebase Source code references X2SoldierClassTemplateManager.uc:100-110","title":"GetCrossClassAbilities_CH"},{"location":"misc/GetCrossClassAbilities_CH/#getcrossclassabilities_ch","text":"Tracking Issue: #62 The CH variant of GetCrossClassAbilities compared to vanilla does two things differently: - Adds a check to ensure that the ability to be added to the CrossClassAbilities list isn't already in the soldiers default ability tree. - This variant supersedes issue #30 by checking against the actual abilities in the current soldiers tree, instead of comparing against all the potential abilities the soldier could have had available. This is especially important when classes uses the RandomAbilityDecks, since otherwise in the worst case scenario, you could end up with no available cross class abilities. The old function is kept in case mods call it, but is otherwise ignored throughout the XComGame codebase","title":"GetCrossClassAbilities_CH"},{"location":"misc/GetCrossClassAbilities_CH/#source-code-references","text":"X2SoldierClassTemplateManager.uc:100-110","title":"Source code references"},{"location":"misc/ItemAddedOrRemovedToSlot/","text":"ItemAddedOrRemovedToSlot Tracking Issue: #694 Tags: events Triggers ItemAddedToSlot event when a unit adds an item to their inventory. Triggers ItemRemovedFromSlot event when a unit removes an item from their inventory. These events are perfect when relying on X2ItemTemplate::OnEquippedFn and X2ItemTemplate::OnUnequippedFn is not an option, such as when you need to execute arbitrary code whenever any unit adds any item to their inventory. ItemAddedToSlot event Param Value EventID ItemAddedToSlot EventData XComGameState_Item EventSource XComGameState_Unit NewGameState yes Listener template static function EventListenerReturn OnItemAddedToSlot(Object EventData, Object EventSource, XComGameState GameState, Name EventID, Object CallbackObject) { // Your code here return ELR_NoInterrupt; } ItemRemovedFromSlot event Param Value EventID ItemRemovedFromSlot EventData XComGameState_Item EventSource XComGameState_Unit NewGameState maybe Listener template static function EventListenerReturn OnItemRemovedFromSlot(Object EventData, Object EventSource, XComGameState GameState, Name EventID, Object CallbackObject) { // Your code here return ELR_NoInterrupt; } Source code references XComGameState_Unit.uc:8024-8035 XComGameState_Unit.uc:8406-8412","title":"ItemAddedOrRemovedToSlot"},{"location":"misc/ItemAddedOrRemovedToSlot/#itemaddedorremovedtoslot","text":"Tracking Issue: #694 Tags: events Triggers ItemAddedToSlot event when a unit adds an item to their inventory. Triggers ItemRemovedFromSlot event when a unit removes an item from their inventory. These events are perfect when relying on X2ItemTemplate::OnEquippedFn and X2ItemTemplate::OnUnequippedFn is not an option, such as when you need to execute arbitrary code whenever any unit adds any item to their inventory.","title":"ItemAddedOrRemovedToSlot"},{"location":"misc/ItemAddedOrRemovedToSlot/#itemaddedtoslot-event","text":"Param Value EventID ItemAddedToSlot EventData XComGameState_Item EventSource XComGameState_Unit NewGameState yes","title":"ItemAddedToSlot event"},{"location":"misc/ItemAddedOrRemovedToSlot/#listener-template","text":"static function EventListenerReturn OnItemAddedToSlot(Object EventData, Object EventSource, XComGameState GameState, Name EventID, Object CallbackObject) { // Your code here return ELR_NoInterrupt; }","title":"Listener template"},{"location":"misc/ItemAddedOrRemovedToSlot/#itemremovedfromslot-event","text":"Param Value EventID ItemRemovedFromSlot EventData XComGameState_Item EventSource XComGameState_Unit NewGameState maybe","title":"ItemRemovedFromSlot event"},{"location":"misc/ItemAddedOrRemovedToSlot/#listener-template_1","text":"static function EventListenerReturn OnItemRemovedFromSlot(Object EventData, Object EventSource, XComGameState GameState, Name EventID, Object CallbackObject) { // Your code here return ELR_NoInterrupt; }","title":"Listener template"},{"location":"misc/ItemAddedOrRemovedToSlot/#source-code-references","text":"XComGameState_Unit.uc:8024-8035 XComGameState_Unit.uc:8406-8412","title":"Source code references"},{"location":"misc/ModAddedHeads/","text":"ModAddedHeads Tracking Issue: #219 Tags: customization , pawns Allows Human Pawns to freely switch between default head and separate skeletal mesh heads without resorting to invisible head hacks and helmets. +BodyPartTemplateConfig=(PartType=\"Head\", TemplateName=\"Augmentations_Head_AFR\", ArchetypeName=\"MusashiAndroidHeads.ARC_Head_Afr_M\", Gender=eGender_Male, Race=eRace_African, bCanUseOnCivilian=false, SpecializedType=false, DLCName=\"Augmentations\") Base-game behavior There are two kinds of Human Pawns in the game: Pawns that share their head mesh with their pawn mesh, and pawns that don't. Note that the pawn mesh itself never has any geometry except for a possible head. In more concrete terms, the standard human pawn meshes have their head included, and the head archetypes reference the same mesh. The Human Pawn recognizes this and doesn't actually attach a head, and instead aliases the head component to the pawn component so that all changes to the head customization apply to the mesh. Sparks on the other hand have the option to switch between different head meshes, and the head mesh never references the pawn mesh. The pawn mesh is entirely void of geometry. The Human Pawn recognizes this and uses a separate mesh component for the head. Where it all goes wrong is when those two types of heads are being mixed. The Human Pawn first aliases the head to the pawn, and when a custom head is being used, it changes the head mesh -- and, due to the alias, also the base pawn mesh. Even worse, it tries to attach the pawn to the pawn itself instead of the head to the pawn. This generally crashes the game. The fix We handle the case where we go from a standard head to a custom head correctly and don't crash We apply an invisible material to the entire pawn mesh when a custom head is being used For Sparks, this causes no change in behavior because the Spark pawn has no geometry For Humans, this is desired because otherwise, the base head clips with any custom head An invisible material is used because outright hiding the pawn turns off parts of the animation system =) Additional nice-to-have Some mod-added heads don't work well with certain customization categories. For example, the Augmentations mod adds Cyborg heads, which generally don't have facial hair (but other facial props are okay!) This change allows custom head archetypes to suppress certain facial customization categories. Example from Augmentations: XComContent.ini : [XComGame.X2BodyPartTemplateManager] +BodyPartTemplateConfig=(PartType=\"Head\", TemplateName=\"Augmentations_Head_AFR\", ArchetypeName=\"MusashiAndroidHeads.ARC_Head_Afr_M\", Gender=eGender_Male, Race=eRace_African, bCanUseOnCivilian=false, SpecializedType=false, DLCName=\"Augmentations\") ; Object name ^^^^^^^^^^^^^^ [XComGame.CHHelpers] +HeadSuppressesHair=\"ARC_Head_Afr_M\" +HeadSuppressesBeard=\"ARC_Head_Afr_M\" The specified name is the object name of the archetype. Full list of arrays: HeadSuppressesHair HeadSuppressesLowerFaceProp HeadSuppressesUpperFaceProp HeadSuppressesHelmet HeadSuppressesBeard Source code references XComHumanPawn.uc:1264-1327 CHHelpers.uc:96","title":"ModAddedHeads"},{"location":"misc/ModAddedHeads/#modaddedheads","text":"Tracking Issue: #219 Tags: customization , pawns Allows Human Pawns to freely switch between default head and separate skeletal mesh heads without resorting to invisible head hacks and helmets. +BodyPartTemplateConfig=(PartType=\"Head\", TemplateName=\"Augmentations_Head_AFR\", ArchetypeName=\"MusashiAndroidHeads.ARC_Head_Afr_M\", Gender=eGender_Male, Race=eRace_African, bCanUseOnCivilian=false, SpecializedType=false, DLCName=\"Augmentations\")","title":"ModAddedHeads"},{"location":"misc/ModAddedHeads/#base-game-behavior","text":"There are two kinds of Human Pawns in the game: Pawns that share their head mesh with their pawn mesh, and pawns that don't. Note that the pawn mesh itself never has any geometry except for a possible head. In more concrete terms, the standard human pawn meshes have their head included, and the head archetypes reference the same mesh. The Human Pawn recognizes this and doesn't actually attach a head, and instead aliases the head component to the pawn component so that all changes to the head customization apply to the mesh. Sparks on the other hand have the option to switch between different head meshes, and the head mesh never references the pawn mesh. The pawn mesh is entirely void of geometry. The Human Pawn recognizes this and uses a separate mesh component for the head. Where it all goes wrong is when those two types of heads are being mixed. The Human Pawn first aliases the head to the pawn, and when a custom head is being used, it changes the head mesh -- and, due to the alias, also the base pawn mesh. Even worse, it tries to attach the pawn to the pawn itself instead of the head to the pawn. This generally crashes the game.","title":"Base-game behavior"},{"location":"misc/ModAddedHeads/#the-fix","text":"We handle the case where we go from a standard head to a custom head correctly and don't crash We apply an invisible material to the entire pawn mesh when a custom head is being used For Sparks, this causes no change in behavior because the Spark pawn has no geometry For Humans, this is desired because otherwise, the base head clips with any custom head An invisible material is used because outright hiding the pawn turns off parts of the animation system =)","title":"The fix"},{"location":"misc/ModAddedHeads/#additional-nice-to-have","text":"Some mod-added heads don't work well with certain customization categories. For example, the Augmentations mod adds Cyborg heads, which generally don't have facial hair (but other facial props are okay!) This change allows custom head archetypes to suppress certain facial customization categories. Example from Augmentations: XComContent.ini : [XComGame.X2BodyPartTemplateManager] +BodyPartTemplateConfig=(PartType=\"Head\", TemplateName=\"Augmentations_Head_AFR\", ArchetypeName=\"MusashiAndroidHeads.ARC_Head_Afr_M\", Gender=eGender_Male, Race=eRace_African, bCanUseOnCivilian=false, SpecializedType=false, DLCName=\"Augmentations\") ; Object name ^^^^^^^^^^^^^^ [XComGame.CHHelpers] +HeadSuppressesHair=\"ARC_Head_Afr_M\" +HeadSuppressesBeard=\"ARC_Head_Afr_M\" The specified name is the object name of the archetype. Full list of arrays: HeadSuppressesHair HeadSuppressesLowerFaceProp HeadSuppressesUpperFaceProp HeadSuppressesHelmet HeadSuppressesBeard","title":"Additional nice-to-have"},{"location":"misc/ModAddedHeads/#source-code-references","text":"XComHumanPawn.uc:1264-1327 CHHelpers.uc:96","title":"Source code references"},{"location":"misc/ModifyEarnedSoldierAbilities/","text":"ModifyEarnedSoldierAbilities Tracking Issue: #409 This allows mods to add to or otherwise modify earned abilities for units. For example, the Officer Pack can use this to attach learned officer abilities to the unit. Note: abilities added this way will not be picked up by XComGameState_Unit::HasSoldierAbility() Elements of the EarnedAbilities array are structs of type SoldierClassAbilityType . Each element has the following parameters: * AbilityName - template name of the ability that should be added to the unit. * ApplyToWeaponSlot - inventory slot of the item that this ability should be attached to. Being attached to the correct item is critical for abilities that rely on the source item, for example abilities that deal damage of the weapon they are attached to. * UtilityCat - used only if ApplyToWeaponSlot = eInvSlot_Utility . Optional. If specified, the ability will be initialized for the unit when they enter tactical combat only if they have a weapon with the specified weapon category in one of their utility slots. local SoldierClassAbilityType NewAbility; NewAbility.AbilityName = 'PrimaryWeapon_AbilityTemplateName'; NewAbility.ApplyToWeaponSlot = eInvSlot_Primary; EarnedAbilities.AddItem(NewAbility); NewAbility.AbilityName = 'UtilityItem_AbilityTemplateName'; NewAbility.ApplyToWeaponSlot = eInvSlot_Utility; NewAbility.UtilityCat = 'UtilityItemWeaponCategory'; EarnedAbilities.AddItem(NewAbility); Source code references X2DownloadableContentInfo.uc:646-675","title":"ModifyEarnedSoldierAbilities"},{"location":"misc/ModifyEarnedSoldierAbilities/#modifyearnedsoldierabilities","text":"Tracking Issue: #409 This allows mods to add to or otherwise modify earned abilities for units. For example, the Officer Pack can use this to attach learned officer abilities to the unit. Note: abilities added this way will not be picked up by XComGameState_Unit::HasSoldierAbility() Elements of the EarnedAbilities array are structs of type SoldierClassAbilityType . Each element has the following parameters: * AbilityName - template name of the ability that should be added to the unit. * ApplyToWeaponSlot - inventory slot of the item that this ability should be attached to. Being attached to the correct item is critical for abilities that rely on the source item, for example abilities that deal damage of the weapon they are attached to. * UtilityCat - used only if ApplyToWeaponSlot = eInvSlot_Utility . Optional. If specified, the ability will be initialized for the unit when they enter tactical combat only if they have a weapon with the specified weapon category in one of their utility slots. local SoldierClassAbilityType NewAbility; NewAbility.AbilityName = 'PrimaryWeapon_AbilityTemplateName'; NewAbility.ApplyToWeaponSlot = eInvSlot_Primary; EarnedAbilities.AddItem(NewAbility); NewAbility.AbilityName = 'UtilityItem_AbilityTemplateName'; NewAbility.ApplyToWeaponSlot = eInvSlot_Utility; NewAbility.UtilityCat = 'UtilityItemWeaponCategory'; EarnedAbilities.AddItem(NewAbility);","title":"ModifyEarnedSoldierAbilities"},{"location":"misc/ModifyEarnedSoldierAbilities/#source-code-references","text":"X2DownloadableContentInfo.uc:646-675","title":"Source code references"},{"location":"misc/ModifyGeneratedUnitAppearance/","text":"ModifyGeneratedUnitAppearance Tracking Issue: #783 Tags: customization , compatibility Usage This DLC hook allows mods to make arbitrary changes to unit appearance after it has been generated by XGCharacterGenerator::CreateTSoldier() . The generated appearance is stored in CharGen.kSoldier , which you can modify directly. Other arguments are provided to you mostly for reference, and presented to you as they were used by the CreateTSoldier() function. The UnitState and the GameState will be passed to this hook only if the CreateTSoldier() function was called from CreateTSoldierFromUnit() , which normally happens only in the Shell code (TQL / Challenge Mode / Character Pool), and will be none otherwise. If you wish to \"redo\" some parts of the process of generating unit's appearance, you can call various methods in the Character Generator, but you must avoid calling the CreateTSoldier() and CreateTSoldierFromUnit() methods, as that will retrigger the hook, potentially causing an inception loop and crashing the game. Compatibility Custom XGCharacterGenerator classes used by mods to generate appearance of custom units can potentially interfere with the normal operation of this hook for themselves. If the Character Generator implements a custom CreateTSoldier() function that does not call super.CreateTSoldier() , then this DLC hook will not be called for that class. If super.CreateTSoldier() is called, but the custom CreateTSoldier() function makes changes to the generated appearance afterwards, it can potentially override changes made by this hook. For example, Character Generators for Faction Hero classes had to be adjusted in the Highlander so that they do not override Country and Nickname after calling super.CreateTSoldier() , and instead override the SetCountry() and GenerateName() methods, which are called by super.CreateTSoldier() . For best compatibility with this hook, mod-added XGCharacterGenerator() classes should avoid making any appearance changes after calling super.CreateTSoldier() . Ideally, that function should not be overridden at all, and the Character Generator should rely on overriding other methods called by CreateTSoldier() as much as possible. Source code references X2DownloadableContentInfo.uc:821-851 XGCharacterGenerator.uc:419","title":"ModifyGeneratedUnitAppearance"},{"location":"misc/ModifyGeneratedUnitAppearance/#modifygeneratedunitappearance","text":"Tracking Issue: #783 Tags: customization , compatibility","title":"ModifyGeneratedUnitAppearance"},{"location":"misc/ModifyGeneratedUnitAppearance/#usage","text":"This DLC hook allows mods to make arbitrary changes to unit appearance after it has been generated by XGCharacterGenerator::CreateTSoldier() . The generated appearance is stored in CharGen.kSoldier , which you can modify directly. Other arguments are provided to you mostly for reference, and presented to you as they were used by the CreateTSoldier() function. The UnitState and the GameState will be passed to this hook only if the CreateTSoldier() function was called from CreateTSoldierFromUnit() , which normally happens only in the Shell code (TQL / Challenge Mode / Character Pool), and will be none otherwise. If you wish to \"redo\" some parts of the process of generating unit's appearance, you can call various methods in the Character Generator, but you must avoid calling the CreateTSoldier() and CreateTSoldierFromUnit() methods, as that will retrigger the hook, potentially causing an inception loop and crashing the game.","title":"Usage"},{"location":"misc/ModifyGeneratedUnitAppearance/#compatibility","text":"Custom XGCharacterGenerator classes used by mods to generate appearance of custom units can potentially interfere with the normal operation of this hook for themselves. If the Character Generator implements a custom CreateTSoldier() function that does not call super.CreateTSoldier() , then this DLC hook will not be called for that class. If super.CreateTSoldier() is called, but the custom CreateTSoldier() function makes changes to the generated appearance afterwards, it can potentially override changes made by this hook. For example, Character Generators for Faction Hero classes had to be adjusted in the Highlander so that they do not override Country and Nickname after calling super.CreateTSoldier() , and instead override the SetCountry() and GenerateName() methods, which are called by super.CreateTSoldier() . For best compatibility with this hook, mod-added XGCharacterGenerator() classes should avoid making any appearance changes after calling super.CreateTSoldier() . Ideally, that function should not be overridden at all, and the Character Generator should rely on overriding other methods called by CreateTSoldier() as much as possible.","title":"Compatibility"},{"location":"misc/ModifyGeneratedUnitAppearance/#source-code-references","text":"X2DownloadableContentInfo.uc:821-851 XGCharacterGenerator.uc:419","title":"Source code references"},{"location":"misc/OverrideWeaponScale/","text":"OverrideWeaponScale Tracking Issue: #921 Tags: pawns , events The OverrideWeaponScale event allows mods to rescale weapons for unit pawns. This event is triggered from two places: 1) XComUnitPawn::EquipWeapon() is used by items in weapon slots, as well as for utility items that use the Display Multi Slot Items functionality. 2) XComUnitPawn::AttachItem() is used for utility items by default. In this case, the ItemState component of the Tuple will be none . OverrideWeaponScale event Param Value EventID OverrideWeaponScale EventData XComLWTuple EventSource XComUnitPawn NewGameState none Tuple contents Index Name Type Direction 0 bOverride bool out 1 fOverrideWeaponScale float inout 2 ItemState XComGameState_Item in Listener template static function EventListenerReturn OnOverrideWeaponScale(Object EventData, Object EventSource, XComGameState GameState, Name EventID, Object CallbackObject) { local XComUnitPawn UnitPawn; local XComLWTuple Tuple; local bool bOverride; local float fOverrideWeaponScale; local XComGameState_Item ItemState; UnitPawn = XComUnitPawn(EventSource); Tuple = XComLWTuple(EventData); fOverrideWeaponScale = Tuple.Data[1].f; ItemState = XComGameState_Item(Tuple.Data[2].o); // Your code here Tuple.Data[0].b = bOverride; Tuple.Data[1].f = fOverrideWeaponScale; return ELR_NoInterrupt; } Source code references XComUnitPawn.uc:2093-2107","title":"OverrideWeaponScale"},{"location":"misc/OverrideWeaponScale/#overrideweaponscale","text":"Tracking Issue: #921 Tags: pawns , events The OverrideWeaponScale event allows mods to rescale weapons for unit pawns. This event is triggered from two places: 1) XComUnitPawn::EquipWeapon() is used by items in weapon slots, as well as for utility items that use the Display Multi Slot Items functionality. 2) XComUnitPawn::AttachItem() is used for utility items by default. In this case, the ItemState component of the Tuple will be none .","title":"OverrideWeaponScale"},{"location":"misc/OverrideWeaponScale/#overrideweaponscale-event","text":"Param Value EventID OverrideWeaponScale EventData XComLWTuple EventSource XComUnitPawn NewGameState none","title":"OverrideWeaponScale event"},{"location":"misc/OverrideWeaponScale/#tuple-contents","text":"Index Name Type Direction 0 bOverride bool out 1 fOverrideWeaponScale float inout 2 ItemState XComGameState_Item in","title":"Tuple contents"},{"location":"misc/OverrideWeaponScale/#listener-template","text":"static function EventListenerReturn OnOverrideWeaponScale(Object EventData, Object EventSource, XComGameState GameState, Name EventID, Object CallbackObject) { local XComUnitPawn UnitPawn; local XComLWTuple Tuple; local bool bOverride; local float fOverrideWeaponScale; local XComGameState_Item ItemState; UnitPawn = XComUnitPawn(EventSource); Tuple = XComLWTuple(EventData); fOverrideWeaponScale = Tuple.Data[1].f; ItemState = XComGameState_Item(Tuple.Data[2].o); // Your code here Tuple.Data[0].b = bOverride; Tuple.Data[1].f = fOverrideWeaponScale; return ELR_NoInterrupt; }","title":"Listener template"},{"location":"misc/OverrideWeaponScale/#source-code-references","text":"XComUnitPawn.uc:2093-2107","title":"Source code references"},{"location":"misc/ScreenStackSubClasses/","text":"ScreenStackSubClasses Tracking Issue: #290 Tags: compatibility A number of functions in UIScreenStack operate on classes, but fail to consider subclasses. This causes subtle bugs in base game and mod code that fails to consider the possibility that a given class can be subclassed/overridden. For example, UIArmory does something like this: // Don't allow jumping to the geoscape from the armory when coming from squad select if (!`ScreenStack.IsInStack(class'UISquadSelect')) { NavHelp.AddGeoscapeButton(); } However, if UISquadSelect is being overridden or replaced, this can cause the campaign to permanently deadlock because UIArmory fails to find the changed squad select screen. The proper fix would be using HasInstanceOf , but this error is extremely common in base game and mod code. As a result, it was decided that the best fix is to change all functions in UIScreenStack to always consider subclasses. A full list of affected functions: GetScreen IsCurrentClass IsInStack IsNotInStack Compatibility If you legitimately want to not consider subclasses, you can use the functions function UIScreen GetScreen_CH(class<UIScreen> ScreenClass, bool IncludeSubTypes); function bool IsCurrentClass_CH(class<UIScreen> ScreenClass, bool IncludeSubTypes); and rewrite IsInStack / IsNotInStack in terms of GetScreen_CH(...) !=/== none . Source code references UIScreenStack.uc:640-675","title":"ScreenStackSubClasses"},{"location":"misc/ScreenStackSubClasses/#screenstacksubclasses","text":"Tracking Issue: #290 Tags: compatibility A number of functions in UIScreenStack operate on classes, but fail to consider subclasses. This causes subtle bugs in base game and mod code that fails to consider the possibility that a given class can be subclassed/overridden. For example, UIArmory does something like this: // Don't allow jumping to the geoscape from the armory when coming from squad select if (!`ScreenStack.IsInStack(class'UISquadSelect')) { NavHelp.AddGeoscapeButton(); } However, if UISquadSelect is being overridden or replaced, this can cause the campaign to permanently deadlock because UIArmory fails to find the changed squad select screen. The proper fix would be using HasInstanceOf , but this error is extremely common in base game and mod code. As a result, it was decided that the best fix is to change all functions in UIScreenStack to always consider subclasses. A full list of affected functions: GetScreen IsCurrentClass IsInStack IsNotInStack","title":"ScreenStackSubClasses"},{"location":"misc/ScreenStackSubClasses/#compatibility","text":"If you legitimately want to not consider subclasses, you can use the functions function UIScreen GetScreen_CH(class<UIScreen> ScreenClass, bool IncludeSubTypes); function bool IsCurrentClass_CH(class<UIScreen> ScreenClass, bool IncludeSubTypes); and rewrite IsInStack / IsNotInStack in terms of GetScreen_CH(...) !=/== none .","title":"Compatibility"},{"location":"misc/ScreenStackSubClasses/#source-code-references","text":"UIScreenStack.uc:640-675","title":"Source code references"},{"location":"misc/SoundCueNarrativeMoments/","text":"SoundCueNarrativeMoments Tracking Issue: #66 Allows mods to add their own voiceover using narrative moments (top-right corner comms box). Narrative moments in the base game are realized using the WWise middleware. The middleware runs in a background thread, so if audio (spuriously) fails to play, the middleware may take a few frames to figure this out. If audio does fail to play, there must be a callback in order to not deadlock the entire narrative moment system due to the audio never successfully finishing. However, mods have to use SoundCue sounds instead, and the system considers every SoundCue as failed to play. This ends every mod-added narrative moment prematurely after about three seconds. This fix simply triggers the callback only when WWise is involved and silently eats the callback if a SoundCue is involved. Mini-tutorial on mod VO This isn't strictly Highlander-related, but this is the best place to put it. Create a Speaker template (see X2Character_DefaultCharacters.uc ) Templates.AddItem(CreateSpeakerTemplate('Firebrand', \"Firebrand\", \"img:///UILibrary_Common.Head_Firebrand\", eGender_Female)); Compile the mod Import the SoundNodeWave Create a SoundCue , and create an XComConversationNode between the speaker and the SoundNodeWave Set the SpokenText and choose the SpeakerTemplate in the SoundNodeWave Create an XComNarrativeMoment archetype and reference the SoundCue in its Conversations Source code references AudioComponent.uc:252-277","title":"SoundCueNarrativeMoments"},{"location":"misc/SoundCueNarrativeMoments/#soundcuenarrativemoments","text":"Tracking Issue: #66 Allows mods to add their own voiceover using narrative moments (top-right corner comms box). Narrative moments in the base game are realized using the WWise middleware. The middleware runs in a background thread, so if audio (spuriously) fails to play, the middleware may take a few frames to figure this out. If audio does fail to play, there must be a callback in order to not deadlock the entire narrative moment system due to the audio never successfully finishing. However, mods have to use SoundCue sounds instead, and the system considers every SoundCue as failed to play. This ends every mod-added narrative moment prematurely after about three seconds. This fix simply triggers the callback only when WWise is involved and silently eats the callback if a SoundCue is involved.","title":"SoundCueNarrativeMoments"},{"location":"misc/SoundCueNarrativeMoments/#mini-tutorial-on-mod-vo","text":"This isn't strictly Highlander-related, but this is the best place to put it. Create a Speaker template (see X2Character_DefaultCharacters.uc ) Templates.AddItem(CreateSpeakerTemplate('Firebrand', \"Firebrand\", \"img:///UILibrary_Common.Head_Firebrand\", eGender_Female)); Compile the mod Import the SoundNodeWave Create a SoundCue , and create an XComConversationNode between the speaker and the SoundNodeWave Set the SpokenText and choose the SpeakerTemplate in the SoundNodeWave Create an XComNarrativeMoment archetype and reference the SoundCue in its Conversations","title":"Mini-tutorial on mod VO"},{"location":"misc/SoundCueNarrativeMoments/#source-code-references","text":"AudioComponent.uc:252-277","title":"Source code references"},{"location":"misc/SubscribeToOnInput/","text":"SubscribeToOnInput Tracking Issue: #198 Tags: ui Mods may want to intercept mouse/keyboard/controller input and instead run their own code. For most purposes, this feature should be considered superseded by SubscribeToOnInputForScreen , which is more ergonomic to use and harder to misuse. Read that documentation page for a general overview. This feature does not allow receiving the notification only for a specific screen, which is usually what you want. Additionally, it is required to manually unsubscribe at some point, lest you invoke the wrath of the garbage collector and crash everyone's games. delegate bool CHOnInputDelegate(int iInput, int ActionMask); function SubscribeToOnInput(delegate<CHOnInputDelegate> callback); function UnsubscribeFromOnInput(delegate<CHOnInputDelegate> callback); Again, it is recommended to instead use SubscribeToOnInputForScreen . The documentation for that feature has examples. Source code references UIScreenStack.uc:810-826","title":"SubscribeToOnInput"},{"location":"misc/SubscribeToOnInput/#subscribetooninput","text":"Tracking Issue: #198 Tags: ui Mods may want to intercept mouse/keyboard/controller input and instead run their own code. For most purposes, this feature should be considered superseded by SubscribeToOnInputForScreen , which is more ergonomic to use and harder to misuse. Read that documentation page for a general overview. This feature does not allow receiving the notification only for a specific screen, which is usually what you want. Additionally, it is required to manually unsubscribe at some point, lest you invoke the wrath of the garbage collector and crash everyone's games. delegate bool CHOnInputDelegate(int iInput, int ActionMask); function SubscribeToOnInput(delegate<CHOnInputDelegate> callback); function UnsubscribeFromOnInput(delegate<CHOnInputDelegate> callback); Again, it is recommended to instead use SubscribeToOnInputForScreen . The documentation for that feature has examples.","title":"SubscribeToOnInput"},{"location":"misc/SubscribeToOnInput/#source-code-references","text":"UIScreenStack.uc:810-826","title":"Source code references"},{"location":"misc/SubscribeToOnInputForScreen/","text":"SubscribeToOnInputForScreen Tracking Issue: #501 Tags: ui Mods may want to intercept mouse/keyboard/controller input on certain screens and instead run their own code. For example, the Highlander adds a text to the main menu that has small pop-up accessible by pressing the right controller stick. The API consists of a delegate definition and two functions: delegate bool CHOnInputDelegateImproved(UIScreen Screen, int iInput, int ActionMask); function SubscribeToOnInputForScreen(UIScreen Screen, delegate<CHOnInputDelegateImproved> Callback); function UnsubscribeFromOnInputForScreen(UIScreen Screen, delegate<CHOnInputDelegateImproved> Callback); In a nutshell, with SubscribeToOnInputForScreen you ask the UIScreenStack \"when screen Screen would receive input, ask me first\". The CHOnInputDelegateImproved delegate defines the signature of the callback function called when the targeted screen would receive input. Your function will be called with three arguments: The screen that would have received the input ( Screen ), the button that was pressed ( iInput ), and the action that occured ( ActionMask , button press/release). The button and action are numeric values that correspond to constants in UIUtilities_Input.uc . If your function returns true, the ScreenStack will consider the input handled and immediately stop processing the input event. If your function returns false, the ScreenStack will continue calling other subscribers and, if unhandled, will finally notify the screen itself. You can manually unsubscribe from receiving input, but this is generally not necessary as your callback will only be called when the screen would have received input and will automatically be unsubscribed upon removal of the targeted screen. The following simplified example is taken from Covert Infiltration : class UIListener_Mission extends UIScreenListener; event OnInit (UIScreen Screen) { local UIMission MissionScreen; MissionScreen = UIMission(Screen); if (MissionScreen == none) return; // This is a UIMission screen, register MissionScreen.Movie.Stack.SubscribeToOnInputForScreen(MissionScreen, OnMissionScreenInput); } simulated protected function bool OnMissionScreenInput (UIScreen Screen, int iInput, int ActionMask) { if (!Screen.CheckInputIsReleaseOrDirectionRepeat(iInput, ActionMask)) { return false; } switch (iInput) { case class'UIUtilities_Input'.const.FXS_BUTTON_RTRIGGER: // The right controller trigger was just released, show custom screen // ... // Tell the ScreenStack that this input was handled return true; break; } return false; } CheckInputIsReleaseOrDirectionRepeat ensures that the button was just released (or, if directional button, held for a long time), making input behavior more consistent with base game screens. Although all mouse events can be inspected, Flash usually provides its own handlers that run even if the callback indicates to the ScreenStack that the input was handled. As a result, the only mouse event that can reliably be stopped with SubscribeToOnInputForScreen is the already navigation-relevant right click. This feature is a more convenient version of SubscribeToOnInput , which receives events for any screen and has to be manually unsubscribed. SubscribeToOnInput offers lower-level interaction with the input system at the cost of ergonomics. Source code references UIScreenStack.uc:868-944","title":"SubscribeToOnInputForScreen"},{"location":"misc/SubscribeToOnInputForScreen/#subscribetooninputforscreen","text":"Tracking Issue: #501 Tags: ui Mods may want to intercept mouse/keyboard/controller input on certain screens and instead run their own code. For example, the Highlander adds a text to the main menu that has small pop-up accessible by pressing the right controller stick. The API consists of a delegate definition and two functions: delegate bool CHOnInputDelegateImproved(UIScreen Screen, int iInput, int ActionMask); function SubscribeToOnInputForScreen(UIScreen Screen, delegate<CHOnInputDelegateImproved> Callback); function UnsubscribeFromOnInputForScreen(UIScreen Screen, delegate<CHOnInputDelegateImproved> Callback); In a nutshell, with SubscribeToOnInputForScreen you ask the UIScreenStack \"when screen Screen would receive input, ask me first\". The CHOnInputDelegateImproved delegate defines the signature of the callback function called when the targeted screen would receive input. Your function will be called with three arguments: The screen that would have received the input ( Screen ), the button that was pressed ( iInput ), and the action that occured ( ActionMask , button press/release). The button and action are numeric values that correspond to constants in UIUtilities_Input.uc . If your function returns true, the ScreenStack will consider the input handled and immediately stop processing the input event. If your function returns false, the ScreenStack will continue calling other subscribers and, if unhandled, will finally notify the screen itself. You can manually unsubscribe from receiving input, but this is generally not necessary as your callback will only be called when the screen would have received input and will automatically be unsubscribed upon removal of the targeted screen. The following simplified example is taken from Covert Infiltration : class UIListener_Mission extends UIScreenListener; event OnInit (UIScreen Screen) { local UIMission MissionScreen; MissionScreen = UIMission(Screen); if (MissionScreen == none) return; // This is a UIMission screen, register MissionScreen.Movie.Stack.SubscribeToOnInputForScreen(MissionScreen, OnMissionScreenInput); } simulated protected function bool OnMissionScreenInput (UIScreen Screen, int iInput, int ActionMask) { if (!Screen.CheckInputIsReleaseOrDirectionRepeat(iInput, ActionMask)) { return false; } switch (iInput) { case class'UIUtilities_Input'.const.FXS_BUTTON_RTRIGGER: // The right controller trigger was just released, show custom screen // ... // Tell the ScreenStack that this input was handled return true; break; } return false; } CheckInputIsReleaseOrDirectionRepeat ensures that the button was just released (or, if directional button, held for a long time), making input behavior more consistent with base game screens. Although all mouse events can be inspected, Flash usually provides its own handlers that run even if the callback indicates to the ScreenStack that the input was handled. As a result, the only mouse event that can reliably be stopped with SubscribeToOnInputForScreen is the already navigation-relevant right click. This feature is a more convenient version of SubscribeToOnInput , which receives events for any screen and has to be manually unsubscribed. SubscribeToOnInput offers lower-level interaction with the input system at the cost of ergonomics.","title":"SubscribeToOnInputForScreen"},{"location":"misc/SubscribeToOnInputForScreen/#source-code-references","text":"UIScreenStack.uc:868-944","title":"Source code references"},{"location":"misc/TintMaterialConfigs/","text":"TintMaterialConfigs Tracking Issue: #356 Tags: customization , pawns When determining which values to pass to the material using which parameter names, the game matches against a hardcoded list of material names. As a result, mods need to confusingly name their modified materials exactly the same as base-game materials. This change moves these hardcoded names to config lists: var config(Content) array<name> HairMaterial; var config(Content) array<name> SkinMaterial; var config(Content) array<name> ArmorMaterial; var config(Content) array<name> WepAsArmorMaterial; var config(Content) array<name> EyeMaterial; var config(Content) array<name> FlagMaterial; You can add your own materials by creating the following lines in XComContent.ini : [XComGame.CHHelpers] +EyeMaterial=\"MyCustomEyesCustomizable_TC\" Source code references CHHelpers.uc:114-132 XComContent.ini:31 XComHumanPawn.uc:932","title":"TintMaterialConfigs"},{"location":"misc/TintMaterialConfigs/#tintmaterialconfigs","text":"Tracking Issue: #356 Tags: customization , pawns When determining which values to pass to the material using which parameter names, the game matches against a hardcoded list of material names. As a result, mods need to confusingly name their modified materials exactly the same as base-game materials. This change moves these hardcoded names to config lists: var config(Content) array<name> HairMaterial; var config(Content) array<name> SkinMaterial; var config(Content) array<name> ArmorMaterial; var config(Content) array<name> WepAsArmorMaterial; var config(Content) array<name> EyeMaterial; var config(Content) array<name> FlagMaterial; You can add your own materials by creating the following lines in XComContent.ini : [XComGame.CHHelpers] +EyeMaterial=\"MyCustomEyesCustomizable_TC\"","title":"TintMaterialConfigs"},{"location":"misc/TintMaterialConfigs/#source-code-references","text":"CHHelpers.uc:114-132 XComContent.ini:31 XComHumanPawn.uc:932","title":"Source code references"},{"location":"misc/UnrestrictPsiPCS/","text":"UnrestrictPsiPCS Tracking Issue: #602 When adding a PCS granting Psi stat bonus the game will restrict it to the only 'PsiOperative' class. Mods will be able to allow any class to equip a Psi PCS by creating the following lines in XComGame.ini : [XComGame.CHHelpers] +ClassesAllowPsiPCS=ClassName Source code references UIInventory_Implants.uc:135-142 XComGame.ini:35","title":"UnrestrictPsiPCS"},{"location":"misc/UnrestrictPsiPCS/#unrestrictpsipcs","text":"Tracking Issue: #602 When adding a PCS granting Psi stat bonus the game will restrict it to the only 'PsiOperative' class. Mods will be able to allow any class to equip a Psi PCS by creating the following lines in XComGame.ini : [XComGame.CHHelpers] +ClassesAllowPsiPCS=ClassName","title":"UnrestrictPsiPCS"},{"location":"misc/UnrestrictPsiPCS/#source-code-references","text":"UIInventory_Implants.uc:135-142 XComGame.ini:35","title":"Source code references"},{"location":"misc/UpdateHumanPawnMeshComponent/","text":"UpdateHumanPawnMeshComponent Tracking Issue: #216 Tags: customization , pawns Adds a DLC hook to update a given human pawn mesh component's materials. static function UpdateHumanPawnMeshComponent(XComGameState_Unit UnitState, XComHumanPawn Pawn, MeshComponent MeshComp); This can be used to apply custom materials to meshes, or set custom parameters. If not overridden, this calls UpdateHumanPawnMeshMaterial for every MaterialInstanceConstant. Call super.UpdateHumanPawnMeshComponent(UnitState, Pawn, MeshComp); if you rely on both hooks. Source code references X2DownloadableContentInfo.uc:473-484 XComHumanPawn.uc:972","title":"UpdateHumanPawnMeshComponent"},{"location":"misc/UpdateHumanPawnMeshComponent/#updatehumanpawnmeshcomponent","text":"Tracking Issue: #216 Tags: customization , pawns Adds a DLC hook to update a given human pawn mesh component's materials. static function UpdateHumanPawnMeshComponent(XComGameState_Unit UnitState, XComHumanPawn Pawn, MeshComponent MeshComp); This can be used to apply custom materials to meshes, or set custom parameters. If not overridden, this calls UpdateHumanPawnMeshMaterial for every MaterialInstanceConstant. Call super.UpdateHumanPawnMeshComponent(UnitState, Pawn, MeshComp); if you rely on both hooks.","title":"UpdateHumanPawnMeshComponent"},{"location":"misc/UpdateHumanPawnMeshComponent/#source-code-references","text":"X2DownloadableContentInfo.uc:473-484 XComHumanPawn.uc:972","title":"Source code references"},{"location":"misc/UpdateHumanPawnMeshMaterial/","text":"UpdateHumanPawnMeshMaterial Tracking Issue: #169 Tags: customization , pawns Adds a DLC hook to update a given material applied to a human pawn mesh component that can be used to set custom parameters on materials. static function UpdateHumanPawnMeshMaterial(XComGameState_Unit UnitState, XComHumanPawn Pawn, MeshComponent MeshComp, name ParentMaterialName, MaterialInstanceConstant MIC); This is called by UpdateHumanPawnMeshComponent if not overridden. UpdateHumanPawnMeshComponent allows more control over the materials, like being able to use MaterialInstanceTimeVarying or outright replacing materials. The following simplified example is taken from the Warhammer 40,000: Armours of the Imperium mod. Its armor uses custom material names and requires that the eye color is passed to the material using EmissiveColor instead of EyeColor : static function UpdateHumanPawnMeshMaterial(XComGameState_Unit UnitState, XComHumanPawn Pawn, MeshComponent MeshComp, name ParentMaterialName, MaterialInstanceConstant MIC) { local XComLinearColorPalette Palette; local LinearColor ParamColor; if (MaterialInstanceConstant(MIC.Parent).Name == 'Mat_SpaceMarine_Eyes') { Palette = `CONTENT.GetColorPalette(ePalette_EyeColor); ParamColor = Palette.Entries[Pawn.m_kAppearance.iEyeColor].Primary; MIC.SetVectorParameterValue('EmissiveColor', ParamColor); } } Note that a subset of this functionality (specifically if the material parameter names match) can be implemented with config only (no code) using the TintMaterialConfigs feature. Source code references X2DownloadableContentInfo.uc:427-460","title":"UpdateHumanPawnMeshMaterial"},{"location":"misc/UpdateHumanPawnMeshMaterial/#updatehumanpawnmeshmaterial","text":"Tracking Issue: #169 Tags: customization , pawns Adds a DLC hook to update a given material applied to a human pawn mesh component that can be used to set custom parameters on materials. static function UpdateHumanPawnMeshMaterial(XComGameState_Unit UnitState, XComHumanPawn Pawn, MeshComponent MeshComp, name ParentMaterialName, MaterialInstanceConstant MIC); This is called by UpdateHumanPawnMeshComponent if not overridden. UpdateHumanPawnMeshComponent allows more control over the materials, like being able to use MaterialInstanceTimeVarying or outright replacing materials. The following simplified example is taken from the Warhammer 40,000: Armours of the Imperium mod. Its armor uses custom material names and requires that the eye color is passed to the material using EmissiveColor instead of EyeColor : static function UpdateHumanPawnMeshMaterial(XComGameState_Unit UnitState, XComHumanPawn Pawn, MeshComponent MeshComp, name ParentMaterialName, MaterialInstanceConstant MIC) { local XComLinearColorPalette Palette; local LinearColor ParamColor; if (MaterialInstanceConstant(MIC.Parent).Name == 'Mat_SpaceMarine_Eyes') { Palette = `CONTENT.GetColorPalette(ePalette_EyeColor); ParamColor = Palette.Entries[Pawn.m_kAppearance.iEyeColor].Primary; MIC.SetVectorParameterValue('EmissiveColor', ParamColor); } } Note that a subset of this functionality (specifically if the material parameter names match) can be implemented with config only (no code) using the TintMaterialConfigs feature.","title":"UpdateHumanPawnMeshMaterial"},{"location":"misc/UpdateHumanPawnMeshMaterial/#source-code-references","text":"X2DownloadableContentInfo.uc:427-460","title":"Source code references"},{"location":"misc/XComLWTuple/","text":"XComLWTuple Tracking Issue: #754 Tags: events XComLWTuple is based on the original LWTuple that many other mods package themselves, but it cannot be used interchangeably with that class. That means you have to use XComLWTuple for community highlander hooks that rely on it. LWTuple can be used to pass information between two mods without those mods needing to share any additional class types. Typically this information is passed using the XCOM2 event system: an event trigger passes an LWTuple as the EventData, and the listeners can retrieve this LWTuple. Data can be passed in both directions through this system, and the only type they both need to know about is LWTuple. LWTuples contain an id (a name) and an array of LWTValue values. The name is arbitrary and can be used to allow the sender and receiver to validate they are working with the tuple they are expecting. The data array holds the actual data to pass. LWTValue values are a union-like structure, similar to the ASValue struct used by the Scaleform system. A value can hold a bool, int, float, string, name, or object. Values are used by setting the field corresponding to the type you wish to store (e.g. i for int) and setting the kind field to the corresponding enum value (LWTVInt in this case). Readers should read only the field corresponding to the kind set in the value. To use a tuple with the event system, the code firing the event should \"new\" a LWTuple, set its ID field to an appropriate name, optionally fill in any information needed by the event listeners, and pass it as the EventData for the event. Listeners should cast the EventData back to a LWTuple, validate that the result is not none, that its ID is the one they are expecting, and that any contents are as expected. They can then store any new data needed into the tuple by adding to the data array before returning from the listener. These listeners should typically use ELDImmediate as their deferral mode so that the results are immediately processed and passed back to the caller, although mods may advertise longer-lived tuples that can be processed with other deferral strategies. Note that since multiple mods can all be listening on the same event there may be multiple mods receiving the same tuple. If more than one mod needs to return data in a tuple that was not intended to receive data from more than one mod a conflict occurs and these mods may be incompatible. List of data types The kind of data stored in a XComLWTValue. Find the corresponding struct property names in XComLWTuple.uc (see Source code references ) enum XComLWTValueKind { XComLWTVBool, XComLWTVInt, XComLWTVFloat, XComLWTVString, XComLWTVName, XComLWTVObject, XComLWTVVector, XComLWTVRotator, XComLWTVTile, XComLWTVArrayObjects, XComLWTVArrayInts, XComLWTVArrayFloats, XComLWTVArrayStrings, XComLWTVArrayNames, XComLWTVArrayVectors, XComLWTVArrayRotators, XComLWTVArrayTiles }; Source code references XComLWTuple.uc:6-43 XComLWTuple.uc:47-73","title":"XComLWTuple"},{"location":"misc/XComLWTuple/#xcomlwtuple","text":"Tracking Issue: #754 Tags: events XComLWTuple is based on the original LWTuple that many other mods package themselves, but it cannot be used interchangeably with that class. That means you have to use XComLWTuple for community highlander hooks that rely on it. LWTuple can be used to pass information between two mods without those mods needing to share any additional class types. Typically this information is passed using the XCOM2 event system: an event trigger passes an LWTuple as the EventData, and the listeners can retrieve this LWTuple. Data can be passed in both directions through this system, and the only type they both need to know about is LWTuple. LWTuples contain an id (a name) and an array of LWTValue values. The name is arbitrary and can be used to allow the sender and receiver to validate they are working with the tuple they are expecting. The data array holds the actual data to pass. LWTValue values are a union-like structure, similar to the ASValue struct used by the Scaleform system. A value can hold a bool, int, float, string, name, or object. Values are used by setting the field corresponding to the type you wish to store (e.g. i for int) and setting the kind field to the corresponding enum value (LWTVInt in this case). Readers should read only the field corresponding to the kind set in the value. To use a tuple with the event system, the code firing the event should \"new\" a LWTuple, set its ID field to an appropriate name, optionally fill in any information needed by the event listeners, and pass it as the EventData for the event. Listeners should cast the EventData back to a LWTuple, validate that the result is not none, that its ID is the one they are expecting, and that any contents are as expected. They can then store any new data needed into the tuple by adding to the data array before returning from the listener. These listeners should typically use ELDImmediate as their deferral mode so that the results are immediately processed and passed back to the caller, although mods may advertise longer-lived tuples that can be processed with other deferral strategies. Note that since multiple mods can all be listening on the same event there may be multiple mods receiving the same tuple. If more than one mod needs to return data in a tuple that was not intended to receive data from more than one mod a conflict occurs and these mods may be incompatible.","title":"XComLWTuple"},{"location":"misc/XComLWTuple/#list-of-data-types","text":"The kind of data stored in a XComLWTValue. Find the corresponding struct property names in XComLWTuple.uc (see Source code references ) enum XComLWTValueKind { XComLWTVBool, XComLWTVInt, XComLWTVFloat, XComLWTVString, XComLWTVName, XComLWTVObject, XComLWTVVector, XComLWTVRotator, XComLWTVTile, XComLWTVArrayObjects, XComLWTVArrayInts, XComLWTVArrayFloats, XComLWTVArrayStrings, XComLWTVArrayNames, XComLWTVArrayVectors, XComLWTVArrayRotators, XComLWTVArrayTiles };","title":"List of data types"},{"location":"misc/XComLWTuple/#source-code-references","text":"XComLWTuple.uc:6-43 XComLWTuple.uc:47-73","title":"Source code references"},{"location":"strategy/AfterActionModifyRecoveredLoot/","text":"AfterActionModifyRecoveredLoot Tracking Issue: #736 The event is triggered after the cache items were unpacked but before any loot is shown in the UI. Part of the post-mission sequence. Inspect XComGameState_HeadquartersXCom.LootRecovered for the pending loot EventID: AfterActionModifyRecoveredLoot EventSource: UIInventory_LootRecovered (self) No game state is passed, so make sure to use ELD_Immediate Source code references UIInventory_LootRecovered.uc:92-101","title":"AfterActionModifyRecoveredLoot"},{"location":"strategy/AfterActionModifyRecoveredLoot/#afteractionmodifyrecoveredloot","text":"Tracking Issue: #736 The event is triggered after the cache items were unpacked but before any loot is shown in the UI. Part of the post-mission sequence. Inspect XComGameState_HeadquartersXCom.LootRecovered for the pending loot EventID: AfterActionModifyRecoveredLoot EventSource: UIInventory_LootRecovered (self) No game state is passed, so make sure to use ELD_Immediate","title":"AfterActionModifyRecoveredLoot"},{"location":"strategy/AfterActionModifyRecoveredLoot/#source-code-references","text":"UIInventory_LootRecovered.uc:92-101","title":"Source code references"},{"location":"strategy/AllowOnCovertActionCompleteAnalytics/","text":"AllowOnCovertActionCompleteAnalytics Tracking Issue: #752 Tags: events Allows mods to prevent CA completion from counting towards campaign stats. This event is triggered from AnalyticsManager::OnCoverActionComplete and passes all original listener arguments in the tuple. AllowOnCovertActionCompleteAnalytics event Param Value EventID AllowOnCovertActionCompleteAnalytics EventData XComLWTuple EventSource none NewGameState none Tuple contents Index Name Type Direction 0 bAllow bool inout 1 OriginalEventData Object in 2 OriginalEventSource Object in 3 OriginalGameState XComGameState in 4 OriginalEvent name in 5 OriginalCallbackData Object in Listener template static function EventListenerReturn OnAllowOnCovertActionCompleteAnalytics(Object EventData, Object EventSource, XComGameState GameState, Name EventID, Object CallbackObject) { local XComLWTuple Tuple; local bool bAllow; local Object OriginalEventData; local Object OriginalEventSource; local XComGameState OriginalGameState; local name OriginalEvent; local Object OriginalCallbackData; Tuple = XComLWTuple(EventData); bAllow = Tuple.Data[0].b; OriginalEventData = Object(Tuple.Data[1].o); OriginalEventSource = Object(Tuple.Data[2].o); OriginalGameState = XComGameState(Tuple.Data[3].o); OriginalEvent = Tuple.Data[4].n; OriginalCallbackData = Object(Tuple.Data[5].o); // Your code here Tuple.Data[0].b = bAllow; return ELR_NoInterrupt; } Note 1: The OriginalEventSource should be the XComGameState_CovertAction that was just completed, although the AnalyticsManager code does not validate that. Note 2: you must subscribe with ELD_Immediate deferral to modify bAllow Source code references AnalyticsManager.uc:919-942","title":"AllowOnCovertActionCompleteAnalytics"},{"location":"strategy/AllowOnCovertActionCompleteAnalytics/#allowoncovertactioncompleteanalytics","text":"Tracking Issue: #752 Tags: events Allows mods to prevent CA completion from counting towards campaign stats. This event is triggered from AnalyticsManager::OnCoverActionComplete and passes all original listener arguments in the tuple.","title":"AllowOnCovertActionCompleteAnalytics"},{"location":"strategy/AllowOnCovertActionCompleteAnalytics/#allowoncovertactioncompleteanalytics-event","text":"Param Value EventID AllowOnCovertActionCompleteAnalytics EventData XComLWTuple EventSource none NewGameState none","title":"AllowOnCovertActionCompleteAnalytics event"},{"location":"strategy/AllowOnCovertActionCompleteAnalytics/#tuple-contents","text":"Index Name Type Direction 0 bAllow bool inout 1 OriginalEventData Object in 2 OriginalEventSource Object in 3 OriginalGameState XComGameState in 4 OriginalEvent name in 5 OriginalCallbackData Object in","title":"Tuple contents"},{"location":"strategy/AllowOnCovertActionCompleteAnalytics/#listener-template","text":"static function EventListenerReturn OnAllowOnCovertActionCompleteAnalytics(Object EventData, Object EventSource, XComGameState GameState, Name EventID, Object CallbackObject) { local XComLWTuple Tuple; local bool bAllow; local Object OriginalEventData; local Object OriginalEventSource; local XComGameState OriginalGameState; local name OriginalEvent; local Object OriginalCallbackData; Tuple = XComLWTuple(EventData); bAllow = Tuple.Data[0].b; OriginalEventData = Object(Tuple.Data[1].o); OriginalEventSource = Object(Tuple.Data[2].o); OriginalGameState = XComGameState(Tuple.Data[3].o); OriginalEvent = Tuple.Data[4].n; OriginalCallbackData = Object(Tuple.Data[5].o); // Your code here Tuple.Data[0].b = bAllow; return ELR_NoInterrupt; } Note 1: The OriginalEventSource should be the XComGameState_CovertAction that was just completed, although the AnalyticsManager code does not validate that. Note 2: you must subscribe with ELD_Immediate deferral to modify bAllow","title":"Listener template"},{"location":"strategy/AllowOnCovertActionCompleteAnalytics/#source-code-references","text":"AnalyticsManager.uc:919-942","title":"Source code references"},{"location":"strategy/CanNeverBeRookieCovertAction/","text":"CanNeverBeRookieCovertAction Tracking Issue: #695 The game has a concept of \"Rookie Covert Actions\", which are meant to be always available to the player. Any Covert Action without soldier rank requirements is deemed to be a \"rookie\" Covert Action, and any of its spawn requirements will be ignored under certain conditions. Mods that intend to add Covert Actions without soldier rank requirements but with spawn requirements should set bCanNeverBeRookie to true so that the game actually takes their spawn requirements into account. Source code references X2CovertActionTemplate.uc:29-35 XComGameState_HeadquartersResistance.uc:1647","title":"CanNeverBeRookieCovertAction"},{"location":"strategy/CanNeverBeRookieCovertAction/#canneverberookiecovertaction","text":"Tracking Issue: #695 The game has a concept of \"Rookie Covert Actions\", which are meant to be always available to the player. Any Covert Action without soldier rank requirements is deemed to be a \"rookie\" Covert Action, and any of its spawn requirements will be ignored under certain conditions. Mods that intend to add Covert Actions without soldier rank requirements but with spawn requirements should set bCanNeverBeRookie to true so that the game actually takes their spawn requirements into account.","title":"CanNeverBeRookieCovertAction"},{"location":"strategy/CanNeverBeRookieCovertAction/#source-code-references","text":"X2CovertActionTemplate.uc:29-35 XComGameState_HeadquartersResistance.uc:1647","title":"Source code references"},{"location":"strategy/CanTechBeInspired/","text":"CanTechBeInspired Tracking Issue: #633 Tags: events The CanTechBeInspired event allows mods to forbid a tech from being inspired. This provides an important lever for balancing the strategy game. It's particularly important for repeatable techs, which the inspiration mechanic doesn't seem to handle very well (the techs remain inspired even after the first inspired research of them is complete). CanTechBeInspired event Param Value EventID CanTechBeInspired EventData XComLWTuple EventSource XComGameState_Tech NewGameState yes Tuple contents Index Name Type Direction 0 bCanTechBeInspired bool inout Listener template static function EventListenerReturn OnCanTechBeInspired(Object EventData, Object EventSource, XComGameState GameState, Name EventID, Object CallbackObject) { local XComGameState_Tech TechState; local XComLWTuple Tuple; local bool bCanTechBeInspired; TechState = XComGameState_Tech(EventSource); Tuple = XComLWTuple(EventData); bCanTechBeInspired = Tuple.Data[0].b; // Your code here Tuple.Data[0].b = bCanTechBeInspired; return ELR_NoInterrupt; } Source code references XComGameState_HeadquartersXCom.uc:6973-6984","title":"CanTechBeInspired"},{"location":"strategy/CanTechBeInspired/#cantechbeinspired","text":"Tracking Issue: #633 Tags: events The CanTechBeInspired event allows mods to forbid a tech from being inspired. This provides an important lever for balancing the strategy game. It's particularly important for repeatable techs, which the inspiration mechanic doesn't seem to handle very well (the techs remain inspired even after the first inspired research of them is complete).","title":"CanTechBeInspired"},{"location":"strategy/CanTechBeInspired/#cantechbeinspired-event","text":"Param Value EventID CanTechBeInspired EventData XComLWTuple EventSource XComGameState_Tech NewGameState yes","title":"CanTechBeInspired event"},{"location":"strategy/CanTechBeInspired/#tuple-contents","text":"Index Name Type Direction 0 bCanTechBeInspired bool inout","title":"Tuple contents"},{"location":"strategy/CanTechBeInspired/#listener-template","text":"static function EventListenerReturn OnCanTechBeInspired(Object EventData, Object EventSource, XComGameState GameState, Name EventID, Object CallbackObject) { local XComGameState_Tech TechState; local XComLWTuple Tuple; local bool bCanTechBeInspired; TechState = XComGameState_Tech(EventSource); Tuple = XComLWTuple(EventData); bCanTechBeInspired = Tuple.Data[0].b; // Your code here Tuple.Data[0].b = bCanTechBeInspired; return ELR_NoInterrupt; }","title":"Listener template"},{"location":"strategy/CanTechBeInspired/#source-code-references","text":"XComGameState_HeadquartersXCom.uc:6973-6984","title":"Source code references"},{"location":"strategy/CanWeaponApplyUpgrade/","text":"CanWeaponApplyUpgrade Tracking Issue: #260 This function will be used to cycle through DLCInfos that will allow mods to check generally whether or not a weapon is compatible with an upgrade. X2WeaponUpgradeTemplate::CanApplyUpgradeToWeapon still exists as the \"can this upgrade be applied to this weapon RIGHT NOW?\" The best use case for this is to bar your weapon from applying upgrades that don't meet your criteria, without having to edit those upgrades directly. Note that this check is /in addition to/, and not /in lieu of/, CanApplyUpgradeToWeapon. This means you cannot use it to override that function's return value. Source code references XComGameState_Item.uc:2439-2447","title":"CanWeaponApplyUpgrade"},{"location":"strategy/CanWeaponApplyUpgrade/#canweaponapplyupgrade","text":"Tracking Issue: #260 This function will be used to cycle through DLCInfos that will allow mods to check generally whether or not a weapon is compatible with an upgrade. X2WeaponUpgradeTemplate::CanApplyUpgradeToWeapon still exists as the \"can this upgrade be applied to this weapon RIGHT NOW?\" The best use case for this is to bar your weapon from applying upgrades that don't meet your criteria, without having to edit those upgrades directly. Note that this check is /in addition to/, and not /in lieu of/, CanApplyUpgradeToWeapon. This means you cannot use it to override that function's return value.","title":"CanWeaponApplyUpgrade"},{"location":"strategy/CanWeaponApplyUpgrade/#source-code-references","text":"XComGameState_Item.uc:2439-2447","title":"Source code references"},{"location":"strategy/CovertAction_OverrideCostScalar/","text":"CovertAction_OverrideCostScalar Tracking Issue: #807 Tags: events Allows listeners to override the multiplier covert actions use to determine how many resources an optional cost requires. The game uses 0.5 by default, which means CAs need half the supplies/intel/etc. you would get from a POI as the cost to mitigate a risk. CovertAction_OverrideCostScalar event Param Value EventID CovertAction_OverrideCostScalar EventData XComLWTuple EventSource XComGameState_CovertAction NewGameState none Tuple contents Index Name Type Direction 0 DefaultCostScalar float inout 1 RewardState XComGameState_Reward in Listener template static function EventListenerReturn OnCovertAction_OverrideCostScalar(Object EventData, Object EventSource, XComGameState GameState, Name EventID, Object CallbackObject) { local XComGameState_CovertAction ActionState; local XComLWTuple Tuple; local float DefaultCostScalar; local XComGameState_Reward RewardState; ActionState = XComGameState_CovertAction(EventSource); Tuple = XComLWTuple(EventData); DefaultCostScalar = Tuple.Data[0].f; RewardState = XComGameState_Reward(Tuple.Data[1].o); // Your code here Tuple.Data[0].f = DefaultCostScalar; return ELR_NoInterrupt; } Source code references XComGameState_CovertAction.uc:578-592","title":"CovertAction_OverrideCostScalar"},{"location":"strategy/CovertAction_OverrideCostScalar/#covertaction_overridecostscalar","text":"Tracking Issue: #807 Tags: events Allows listeners to override the multiplier covert actions use to determine how many resources an optional cost requires. The game uses 0.5 by default, which means CAs need half the supplies/intel/etc. you would get from a POI as the cost to mitigate a risk.","title":"CovertAction_OverrideCostScalar"},{"location":"strategy/CovertAction_OverrideCostScalar/#covertaction_overridecostscalar-event","text":"Param Value EventID CovertAction_OverrideCostScalar EventData XComLWTuple EventSource XComGameState_CovertAction NewGameState none","title":"CovertAction_OverrideCostScalar event"},{"location":"strategy/CovertAction_OverrideCostScalar/#tuple-contents","text":"Index Name Type Direction 0 DefaultCostScalar float inout 1 RewardState XComGameState_Reward in","title":"Tuple contents"},{"location":"strategy/CovertAction_OverrideCostScalar/#listener-template","text":"static function EventListenerReturn OnCovertAction_OverrideCostScalar(Object EventData, Object EventSource, XComGameState GameState, Name EventID, Object CallbackObject) { local XComGameState_CovertAction ActionState; local XComLWTuple Tuple; local float DefaultCostScalar; local XComGameState_Reward RewardState; ActionState = XComGameState_CovertAction(EventSource); Tuple = XComLWTuple(EventData); DefaultCostScalar = Tuple.Data[0].f; RewardState = XComGameState_Reward(Tuple.Data[1].o); // Your code here Tuple.Data[0].f = DefaultCostScalar; return ELR_NoInterrupt; }","title":"Listener template"},{"location":"strategy/CovertAction_OverrideCostScalar/#source-code-references","text":"XComGameState_CovertAction.uc:578-592","title":"Source code references"},{"location":"strategy/CovertAction_OverrideRewardScalar/","text":"CovertAction_OverrideRewardScalar Tracking Issue: #807 Tags: events Allows listeners to override the multiplier covert actions use to determine how many resources to award. The game uses 0.5 by default, which means CAs award half the supplies/intel/etc. you would get from a POI. CovertAction_OverrideRewardScalar event Param Value EventID CovertAction_OverrideRewardScalar EventData XComLWTuple EventSource XComGameState_CovertAction NewGameState none Tuple contents Index Name Type Direction 0 DefaultRewardScalar float inout 1 RewardState XComGameState_Reward in Listener template static function EventListenerReturn OnCovertAction_OverrideRewardScalar(Object EventData, Object EventSource, XComGameState GameState, Name EventID, Object CallbackObject) { local XComGameState_CovertAction ActionState; local XComLWTuple Tuple; local float DefaultRewardScalar; local XComGameState_Reward RewardState; ActionState = XComGameState_CovertAction(EventSource); Tuple = XComLWTuple(EventData); DefaultRewardScalar = Tuple.Data[0].f; RewardState = XComGameState_Reward(Tuple.Data[1].o); // Your code here Tuple.Data[0].f = DefaultRewardScalar; return ELR_NoInterrupt; } Source code references XComGameState_CovertAction.uc:610-623","title":"CovertAction_OverrideRewardScalar"},{"location":"strategy/CovertAction_OverrideRewardScalar/#covertaction_overriderewardscalar","text":"Tracking Issue: #807 Tags: events Allows listeners to override the multiplier covert actions use to determine how many resources to award. The game uses 0.5 by default, which means CAs award half the supplies/intel/etc. you would get from a POI.","title":"CovertAction_OverrideRewardScalar"},{"location":"strategy/CovertAction_OverrideRewardScalar/#covertaction_overriderewardscalar-event","text":"Param Value EventID CovertAction_OverrideRewardScalar EventData XComLWTuple EventSource XComGameState_CovertAction NewGameState none","title":"CovertAction_OverrideRewardScalar event"},{"location":"strategy/CovertAction_OverrideRewardScalar/#tuple-contents","text":"Index Name Type Direction 0 DefaultRewardScalar float inout 1 RewardState XComGameState_Reward in","title":"Tuple contents"},{"location":"strategy/CovertAction_OverrideRewardScalar/#listener-template","text":"static function EventListenerReturn OnCovertAction_OverrideRewardScalar(Object EventData, Object EventSource, XComGameState GameState, Name EventID, Object CallbackObject) { local XComGameState_CovertAction ActionState; local XComLWTuple Tuple; local float DefaultRewardScalar; local XComGameState_Reward RewardState; ActionState = XComGameState_CovertAction(EventSource); Tuple = XComLWTuple(EventData); DefaultRewardScalar = Tuple.Data[0].f; RewardState = XComGameState_Reward(Tuple.Data[1].o); // Your code here Tuple.Data[0].f = DefaultRewardScalar; return ELR_NoInterrupt; }","title":"Listener template"},{"location":"strategy/CovertAction_OverrideRewardScalar/#source-code-references","text":"XComGameState_CovertAction.uc:610-623","title":"Source code references"},{"location":"strategy/CovertAction_OverrideRiskStrings/","text":"CovertAction_OverrideRiskStrings Tracking Issue: #779 Allows listeners to override how risk chances are displayed in the covert actions screen (UICovertActions). The names of each risk and the texts displayed to represent the chance of each one occurring are passed in the event as two separate arrays of strings. Note that the two arrays are in the same order, i.e. the first element of each array corresponds to the first risk, the second element to the second risk, and so on. Source code references XComGameState_CovertAction.uc:1390-1398","title":"CovertAction_OverrideRiskStrings"},{"location":"strategy/CovertAction_OverrideRiskStrings/#covertaction_overrideriskstrings","text":"Tracking Issue: #779 Allows listeners to override how risk chances are displayed in the covert actions screen (UICovertActions). The names of each risk and the texts displayed to represent the chance of each one occurring are passed in the event as two separate arrays of strings. Note that the two arrays are in the same order, i.e. the first element of each array corresponds to the first risk, the second element to the second risk, and so on.","title":"CovertAction_OverrideRiskStrings"},{"location":"strategy/CovertAction_OverrideRiskStrings/#source-code-references","text":"XComGameState_CovertAction.uc:1390-1398","title":"Source code references"},{"location":"strategy/DynamicSoldierClassDisplay/","text":"DynamicSoldierClassDisplay Tracking Issue: #106 Tags: ui , events Mods may want to manipulate the way a soldier's class is displayed (in terms of icon/name/description) in more dynamic ways. For example, RPGOverhaul has a single soldier class and the way it is displayed depends on selected skills and loadouts. There are three events with mostly self-explanatory names: SoldierClassIcon event Param Value EventID SoldierClassIcon EventData XComLWTuple EventSource XComGameState_Unit NewGameState none Tuple contents Index Name Type Direction 0 IconImagePath string inout Listener template static function EventListenerReturn OnSoldierClassIcon(Object EventData, Object EventSource, XComGameState GameState, Name EventID, Object CallbackObject) { local XComGameState_Unit UnitState; local XComLWTuple Tuple; local string IconImagePath; UnitState = XComGameState_Unit(EventSource); Tuple = XComLWTuple(EventData); IconImagePath = Tuple.Data[0].s; // Your code here Tuple.Data[0].s = IconImagePath; return ELR_NoInterrupt; } SoldierClassDisplayName event Param Value EventID SoldierClassDisplayName EventData XComLWTuple EventSource XComGameState_Unit NewGameState none Tuple contents Index Name Type Direction 0 DisplayName string inout Listener template static function EventListenerReturn OnSoldierClassDisplayName(Object EventData, Object EventSource, XComGameState GameState, Name EventID, Object CallbackObject) { local XComGameState_Unit UnitState; local XComLWTuple Tuple; local string DisplayName; UnitState = XComGameState_Unit(EventSource); Tuple = XComLWTuple(EventData); DisplayName = Tuple.Data[0].s; // Your code here Tuple.Data[0].s = DisplayName; return ELR_NoInterrupt; } SoldierClassSummary event Param Value EventID SoldierClassSummary EventData XComLWTuple EventSource XComGameState_Unit NewGameState none Tuple contents Index Name Type Direction 0 DisplaySummary string inout Listener template static function EventListenerReturn OnSoldierClassSummary(Object EventData, Object EventSource, XComGameState GameState, Name EventID, Object CallbackObject) { local XComGameState_Unit UnitState; local XComLWTuple Tuple; local string DisplaySummary; UnitState = XComGameState_Unit(EventSource); Tuple = XComLWTuple(EventData); DisplaySummary = Tuple.Data[0].s; // Your code here Tuple.Data[0].s = DisplaySummary; return ELR_NoInterrupt; } There is a sister feature DynamicSoldierRankDisplay that extends this to rank icon/name. Source code references XComGameState_Unit.uc:15269-15296","title":"DynamicSoldierClassDisplay"},{"location":"strategy/DynamicSoldierClassDisplay/#dynamicsoldierclassdisplay","text":"Tracking Issue: #106 Tags: ui , events Mods may want to manipulate the way a soldier's class is displayed (in terms of icon/name/description) in more dynamic ways. For example, RPGOverhaul has a single soldier class and the way it is displayed depends on selected skills and loadouts. There are three events with mostly self-explanatory names:","title":"DynamicSoldierClassDisplay"},{"location":"strategy/DynamicSoldierClassDisplay/#soldierclassicon-event","text":"Param Value EventID SoldierClassIcon EventData XComLWTuple EventSource XComGameState_Unit NewGameState none","title":"SoldierClassIcon event"},{"location":"strategy/DynamicSoldierClassDisplay/#tuple-contents","text":"Index Name Type Direction 0 IconImagePath string inout","title":"Tuple contents"},{"location":"strategy/DynamicSoldierClassDisplay/#listener-template","text":"static function EventListenerReturn OnSoldierClassIcon(Object EventData, Object EventSource, XComGameState GameState, Name EventID, Object CallbackObject) { local XComGameState_Unit UnitState; local XComLWTuple Tuple; local string IconImagePath; UnitState = XComGameState_Unit(EventSource); Tuple = XComLWTuple(EventData); IconImagePath = Tuple.Data[0].s; // Your code here Tuple.Data[0].s = IconImagePath; return ELR_NoInterrupt; }","title":"Listener template"},{"location":"strategy/DynamicSoldierClassDisplay/#soldierclassdisplayname-event","text":"Param Value EventID SoldierClassDisplayName EventData XComLWTuple EventSource XComGameState_Unit NewGameState none","title":"SoldierClassDisplayName event"},{"location":"strategy/DynamicSoldierClassDisplay/#tuple-contents_1","text":"Index Name Type Direction 0 DisplayName string inout","title":"Tuple contents"},{"location":"strategy/DynamicSoldierClassDisplay/#listener-template_1","text":"static function EventListenerReturn OnSoldierClassDisplayName(Object EventData, Object EventSource, XComGameState GameState, Name EventID, Object CallbackObject) { local XComGameState_Unit UnitState; local XComLWTuple Tuple; local string DisplayName; UnitState = XComGameState_Unit(EventSource); Tuple = XComLWTuple(EventData); DisplayName = Tuple.Data[0].s; // Your code here Tuple.Data[0].s = DisplayName; return ELR_NoInterrupt; }","title":"Listener template"},{"location":"strategy/DynamicSoldierClassDisplay/#soldierclasssummary-event","text":"Param Value EventID SoldierClassSummary EventData XComLWTuple EventSource XComGameState_Unit NewGameState none","title":"SoldierClassSummary event"},{"location":"strategy/DynamicSoldierClassDisplay/#tuple-contents_2","text":"Index Name Type Direction 0 DisplaySummary string inout","title":"Tuple contents"},{"location":"strategy/DynamicSoldierClassDisplay/#listener-template_2","text":"static function EventListenerReturn OnSoldierClassSummary(Object EventData, Object EventSource, XComGameState GameState, Name EventID, Object CallbackObject) { local XComGameState_Unit UnitState; local XComLWTuple Tuple; local string DisplaySummary; UnitState = XComGameState_Unit(EventSource); Tuple = XComLWTuple(EventData); DisplaySummary = Tuple.Data[0].s; // Your code here Tuple.Data[0].s = DisplaySummary; return ELR_NoInterrupt; } There is a sister feature DynamicSoldierRankDisplay that extends this to rank icon/name.","title":"Listener template"},{"location":"strategy/DynamicSoldierClassDisplay/#source-code-references","text":"XComGameState_Unit.uc:15269-15296","title":"Source code references"},{"location":"strategy/DynamicSoldierRankDisplay/","text":"DynamicSoldierRankDisplay Tracking Issue: #408 Tags: ui , events Mods may want to manipulate the way a soldier's rank is displayed (in terms of icon/name/description) in more dynamic ways. For example, LWOTC shows officer ranks for units with special officer abilities. There are three events with mostly self-explanatory names: SoldierRankName event Param Value EventID SoldierRankName EventData XComLWTuple EventSource XComGameState_Unit NewGameState none Tuple contents Index Name Type Direction 0 Rank int in 1 DisplayRankName string inout Listener template static function EventListenerReturn OnSoldierRankName(Object EventData, Object EventSource, XComGameState GameState, Name EventID, Object CallbackObject) { local XComGameState_Unit UnitState; local XComLWTuple Tuple; local int Rank; local string DisplayRankName; UnitState = XComGameState_Unit(EventSource); Tuple = XComLWTuple(EventData); Rank = Tuple.Data[0].i; DisplayRankName = Tuple.Data[1].s; // Your code here Tuple.Data[1].s = DisplayRankName; return ELR_NoInterrupt; } SoldierShortRankName event Param Value EventID SoldierShortRankName EventData XComLWTuple EventSource XComGameState_Unit NewGameState none Tuple contents Index Name Type Direction 0 Rank int in 1 DisplayShortRankName string inout Listener template static function EventListenerReturn OnSoldierShortRankName(Object EventData, Object EventSource, XComGameState GameState, Name EventID, Object CallbackObject) { local XComGameState_Unit UnitState; local XComLWTuple Tuple; local int Rank; local string DisplayShortRankName; UnitState = XComGameState_Unit(EventSource); Tuple = XComLWTuple(EventData); Rank = Tuple.Data[0].i; DisplayShortRankName = Tuple.Data[1].s; // Your code here Tuple.Data[1].s = DisplayShortRankName; return ELR_NoInterrupt; } SoldierRankIcon event Param Value EventID SoldierRankIcon EventData XComLWTuple EventSource XComGameState_Unit NewGameState none Tuple contents Index Name Type Direction 0 Rank int in 1 IconImagePath string inout Listener template static function EventListenerReturn OnSoldierRankIcon(Object EventData, Object EventSource, XComGameState GameState, Name EventID, Object CallbackObject) { local XComGameState_Unit UnitState; local XComLWTuple Tuple; local int Rank; local string IconImagePath; UnitState = XComGameState_Unit(EventSource); Tuple = XComLWTuple(EventData); Rank = Tuple.Data[0].i; IconImagePath = Tuple.Data[1].s; // Your code here Tuple.Data[1].s = IconImagePath; return ELR_NoInterrupt; } There is a sister feature DynamicSoldierClassDisplay that extends this to class icon/name. Source code references XComGameState_Unit.uc:15361-15389","title":"DynamicSoldierRankDisplay"},{"location":"strategy/DynamicSoldierRankDisplay/#dynamicsoldierrankdisplay","text":"Tracking Issue: #408 Tags: ui , events Mods may want to manipulate the way a soldier's rank is displayed (in terms of icon/name/description) in more dynamic ways. For example, LWOTC shows officer ranks for units with special officer abilities. There are three events with mostly self-explanatory names:","title":"DynamicSoldierRankDisplay"},{"location":"strategy/DynamicSoldierRankDisplay/#soldierrankname-event","text":"Param Value EventID SoldierRankName EventData XComLWTuple EventSource XComGameState_Unit NewGameState none","title":"SoldierRankName event"},{"location":"strategy/DynamicSoldierRankDisplay/#tuple-contents","text":"Index Name Type Direction 0 Rank int in 1 DisplayRankName string inout","title":"Tuple contents"},{"location":"strategy/DynamicSoldierRankDisplay/#listener-template","text":"static function EventListenerReturn OnSoldierRankName(Object EventData, Object EventSource, XComGameState GameState, Name EventID, Object CallbackObject) { local XComGameState_Unit UnitState; local XComLWTuple Tuple; local int Rank; local string DisplayRankName; UnitState = XComGameState_Unit(EventSource); Tuple = XComLWTuple(EventData); Rank = Tuple.Data[0].i; DisplayRankName = Tuple.Data[1].s; // Your code here Tuple.Data[1].s = DisplayRankName; return ELR_NoInterrupt; }","title":"Listener template"},{"location":"strategy/DynamicSoldierRankDisplay/#soldiershortrankname-event","text":"Param Value EventID SoldierShortRankName EventData XComLWTuple EventSource XComGameState_Unit NewGameState none","title":"SoldierShortRankName event"},{"location":"strategy/DynamicSoldierRankDisplay/#tuple-contents_1","text":"Index Name Type Direction 0 Rank int in 1 DisplayShortRankName string inout","title":"Tuple contents"},{"location":"strategy/DynamicSoldierRankDisplay/#listener-template_1","text":"static function EventListenerReturn OnSoldierShortRankName(Object EventData, Object EventSource, XComGameState GameState, Name EventID, Object CallbackObject) { local XComGameState_Unit UnitState; local XComLWTuple Tuple; local int Rank; local string DisplayShortRankName; UnitState = XComGameState_Unit(EventSource); Tuple = XComLWTuple(EventData); Rank = Tuple.Data[0].i; DisplayShortRankName = Tuple.Data[1].s; // Your code here Tuple.Data[1].s = DisplayShortRankName; return ELR_NoInterrupt; }","title":"Listener template"},{"location":"strategy/DynamicSoldierRankDisplay/#soldierrankicon-event","text":"Param Value EventID SoldierRankIcon EventData XComLWTuple EventSource XComGameState_Unit NewGameState none","title":"SoldierRankIcon event"},{"location":"strategy/DynamicSoldierRankDisplay/#tuple-contents_2","text":"Index Name Type Direction 0 Rank int in 1 IconImagePath string inout","title":"Tuple contents"},{"location":"strategy/DynamicSoldierRankDisplay/#listener-template_2","text":"static function EventListenerReturn OnSoldierRankIcon(Object EventData, Object EventSource, XComGameState GameState, Name EventID, Object CallbackObject) { local XComGameState_Unit UnitState; local XComLWTuple Tuple; local int Rank; local string IconImagePath; UnitState = XComGameState_Unit(EventSource); Tuple = XComLWTuple(EventData); Rank = Tuple.Data[0].i; IconImagePath = Tuple.Data[1].s; // Your code here Tuple.Data[1].s = IconImagePath; return ELR_NoInterrupt; } There is a sister feature DynamicSoldierClassDisplay that extends this to class icon/name.","title":"Listener template"},{"location":"strategy/DynamicSoldierRankDisplay/#source-code-references","text":"XComGameState_Unit.uc:15361-15389","title":"Source code references"},{"location":"strategy/ExtendHasHeavyWeapon/","text":"ExtendHasHeavyWeapon Tracking Issue: #881 Tags: loadoutslots Extends the ability check in HasHeavyWeapon() for the config array AbilityUnlocksHeavyWeapon ( XComGameData.ini ) to item granted abilities and abilities granted by the character template. Source code references XComGameState_Unit.uc:4094-4096","title":"ExtendHasHeavyWeapon"},{"location":"strategy/ExtendHasHeavyWeapon/#extendhasheavyweapon","text":"Tracking Issue: #881 Tags: loadoutslots Extends the ability check in HasHeavyWeapon() for the config array AbilityUnlocksHeavyWeapon ( XComGameData.ini ) to item granted abilities and abilities granted by the character template.","title":"ExtendHasHeavyWeapon"},{"location":"strategy/ExtendHasHeavyWeapon/#source-code-references","text":"XComGameState_Unit.uc:4094-4096","title":"Source code references"},{"location":"strategy/FirstPromotionOverrideClass/","text":"FirstPromotionOverrideClass Tracking Issue: #801 Tags: events The XComGameState_Unit::RankUpSoldier triggers a FirstPromotionOverrideClass event, allowing mods to override the soldier class template name that will be assigned to this unit, making it possible to set a class for the soldier based on arbitrary conditions. It is necessary to listen to this event using ELD_Immediate deferral in order for your changes to take effect in time. If the RankUpSoldier function was called with a soldier class template name already specified, it means the game wanted to promote this soldier to a specific class (e.g. GTS rookie training, Psi Operative training or Commander's Choice). In that case, you can set up your Event Listener to not have an effect on such a soldier. FirstPromotionOverrideClass event Param Value EventID FirstPromotionOverrideClass EventData XComLWTuple EventSource XComGameState_Unit NewGameState yes Tuple contents Index Name Type Direction 0 SoldierClassTemplateName name inout Listener template static function EventListenerReturn OnFirstPromotionOverrideClass(Object EventData, Object EventSource, XComGameState GameState, Name EventID, Object CallbackObject) { local XComGameState_Unit FirstSquaddie; local XComLWTuple Tuple; local name SoldierClassTemplateName; FirstSquaddie = XComGameState_Unit(EventSource); Tuple = XComLWTuple(EventData); SoldierClassTemplateName = Tuple.Data[0].n; // Your code here Tuple.Data[0].n = SoldierClassTemplateName; return ELR_NoInterrupt; } Example of an Event Listener Function: static function EventListenerReturn ListenerEventFunction(Object EventData, Object EventSource, XComGameState NewGameState, Name Event, Object CallbackData) { local XComLWTuple Tuple; local XComGameState_Unit UnitState; Tuple = XComLWTuple(EventData); UnitState = XComGameState_Unit(EventSource); if (Tuple == none || UnitState == none) return ELR_NoInterrupt; // If the game did not want to promote this soldier to a specific soldier class if (Tuple.Data[0].n == '') { // If a soldier rolled high aim thanks to Not Created Equal, they are guaranteed to become a sniper. if (UnitState.GetCurrentStat(eStat_Offense) > 70) { Tuple.Data[0].n = 'Sharpshooter'; } } return ELR_NoInterrupt; } Source code references XComGameState_Unit.uc:13245-13284","title":"FirstPromotionOverrideClass"},{"location":"strategy/FirstPromotionOverrideClass/#firstpromotionoverrideclass","text":"Tracking Issue: #801 Tags: events The XComGameState_Unit::RankUpSoldier triggers a FirstPromotionOverrideClass event, allowing mods to override the soldier class template name that will be assigned to this unit, making it possible to set a class for the soldier based on arbitrary conditions. It is necessary to listen to this event using ELD_Immediate deferral in order for your changes to take effect in time. If the RankUpSoldier function was called with a soldier class template name already specified, it means the game wanted to promote this soldier to a specific class (e.g. GTS rookie training, Psi Operative training or Commander's Choice). In that case, you can set up your Event Listener to not have an effect on such a soldier.","title":"FirstPromotionOverrideClass"},{"location":"strategy/FirstPromotionOverrideClass/#firstpromotionoverrideclass-event","text":"Param Value EventID FirstPromotionOverrideClass EventData XComLWTuple EventSource XComGameState_Unit NewGameState yes","title":"FirstPromotionOverrideClass event"},{"location":"strategy/FirstPromotionOverrideClass/#tuple-contents","text":"Index Name Type Direction 0 SoldierClassTemplateName name inout","title":"Tuple contents"},{"location":"strategy/FirstPromotionOverrideClass/#listener-template","text":"static function EventListenerReturn OnFirstPromotionOverrideClass(Object EventData, Object EventSource, XComGameState GameState, Name EventID, Object CallbackObject) { local XComGameState_Unit FirstSquaddie; local XComLWTuple Tuple; local name SoldierClassTemplateName; FirstSquaddie = XComGameState_Unit(EventSource); Tuple = XComLWTuple(EventData); SoldierClassTemplateName = Tuple.Data[0].n; // Your code here Tuple.Data[0].n = SoldierClassTemplateName; return ELR_NoInterrupt; } Example of an Event Listener Function: static function EventListenerReturn ListenerEventFunction(Object EventData, Object EventSource, XComGameState NewGameState, Name Event, Object CallbackData) { local XComLWTuple Tuple; local XComGameState_Unit UnitState; Tuple = XComLWTuple(EventData); UnitState = XComGameState_Unit(EventSource); if (Tuple == none || UnitState == none) return ELR_NoInterrupt; // If the game did not want to promote this soldier to a specific soldier class if (Tuple.Data[0].n == '') { // If a soldier rolled high aim thanks to Not Created Equal, they are guaranteed to become a sniper. if (UnitState.GetCurrentStat(eStat_Offense) > 70) { Tuple.Data[0].n = 'Sharpshooter'; } } return ELR_NoInterrupt; }","title":"Listener template"},{"location":"strategy/FirstPromotionOverrideClass/#source-code-references","text":"XComGameState_Unit.uc:13245-13284","title":"Source code references"},{"location":"strategy/Geoscape_ResInfoButtonVisible/","text":"Geoscape_ResInfoButtonVisible Tracking Issue: #365 Tags: ui , events Allows overriding whether the resistance info button should be visible. Default: After the first month if any faction met and not in flight. Geoscape_ResInfoButtonVisible event Param Value EventID Geoscape_ResInfoButtonVisible EventData XComLWTuple EventSource UIStrategyMap_HUD NewGameState none Tuple contents Index Name Type Direction 0 ShouldShow bool inout 1 InFlight bool in Listener template static function EventListenerReturn OnGeoscape_ResInfoButtonVisible(Object EventData, Object EventSource, XComGameState GameState, Name EventID, Object CallbackObject) { local UIStrategyMap_HUD HUDScreen; local XComLWTuple Tuple; local bool ShouldShow; local bool InFlight; HUDScreen = UIStrategyMap_HUD(EventSource); Tuple = XComLWTuple(EventData); ShouldShow = Tuple.Data[0].b; InFlight = Tuple.Data[1].b; // Your code here Tuple.Data[0].b = ShouldShow; return ELR_NoInterrupt; } Source code references UIStrategyMap_HUD.uc:285-294","title":"Geoscape_ResInfoButtonVisible"},{"location":"strategy/Geoscape_ResInfoButtonVisible/#geoscape_resinfobuttonvisible","text":"Tracking Issue: #365 Tags: ui , events Allows overriding whether the resistance info button should be visible. Default: After the first month if any faction met and not in flight.","title":"Geoscape_ResInfoButtonVisible"},{"location":"strategy/Geoscape_ResInfoButtonVisible/#geoscape_resinfobuttonvisible-event","text":"Param Value EventID Geoscape_ResInfoButtonVisible EventData XComLWTuple EventSource UIStrategyMap_HUD NewGameState none","title":"Geoscape_ResInfoButtonVisible event"},{"location":"strategy/Geoscape_ResInfoButtonVisible/#tuple-contents","text":"Index Name Type Direction 0 ShouldShow bool inout 1 InFlight bool in","title":"Tuple contents"},{"location":"strategy/Geoscape_ResInfoButtonVisible/#listener-template","text":"static function EventListenerReturn OnGeoscape_ResInfoButtonVisible(Object EventData, Object EventSource, XComGameState GameState, Name EventID, Object CallbackObject) { local UIStrategyMap_HUD HUDScreen; local XComLWTuple Tuple; local bool ShouldShow; local bool InFlight; HUDScreen = UIStrategyMap_HUD(EventSource); Tuple = XComLWTuple(EventData); ShouldShow = Tuple.Data[0].b; InFlight = Tuple.Data[1].b; // Your code here Tuple.Data[0].b = ShouldShow; return ELR_NoInterrupt; }","title":"Listener template"},{"location":"strategy/Geoscape_ResInfoButtonVisible/#source-code-references","text":"UIStrategyMap_HUD.uc:285-294","title":"Source code references"},{"location":"strategy/GetCovertActionEvents_Settings/","text":"GetCovertActionEvents_Settings Tracking Issue: #391 Tags: ui , events Allows configuring the behavior of covert actions in the event queue. AddAll allows multiple covert actions, InsertSorted inserts them into position based on time remaining. Default: Only one covert action is added at the end. GetCovertActionEvents_Settings event Param Value EventID GetCovertActionEvents_Settings EventData XComLWTuple EventSource XComGameState_HeadquartersXCom NewGameState none Tuple contents Index Name Type Direction 0 AddAll bool out 1 InsertSorted bool out Listener template static function EventListenerReturn OnGetCovertActionEvents_Settings(Object EventData, Object EventSource, XComGameState GameState, Name EventID, Object CallbackObject) { local XComGameState_HeadquartersXCom XComHQ; local XComLWTuple Tuple; local bool AddAll; local bool InsertSorted; XComHQ = XComGameState_HeadquartersXCom(EventSource); Tuple = XComLWTuple(EventData); // Your code here Tuple.Data[0].b = AddAll; Tuple.Data[1].b = InsertSorted; return ELR_NoInterrupt; } Source code references XComGameState_HeadquartersXCom.uc:8016-8028","title":"GetCovertActionEvents_Settings"},{"location":"strategy/GetCovertActionEvents_Settings/#getcovertactionevents_settings","text":"Tracking Issue: #391 Tags: ui , events Allows configuring the behavior of covert actions in the event queue. AddAll allows multiple covert actions, InsertSorted inserts them into position based on time remaining. Default: Only one covert action is added at the end.","title":"GetCovertActionEvents_Settings"},{"location":"strategy/GetCovertActionEvents_Settings/#getcovertactionevents_settings-event","text":"Param Value EventID GetCovertActionEvents_Settings EventData XComLWTuple EventSource XComGameState_HeadquartersXCom NewGameState none","title":"GetCovertActionEvents_Settings event"},{"location":"strategy/GetCovertActionEvents_Settings/#tuple-contents","text":"Index Name Type Direction 0 AddAll bool out 1 InsertSorted bool out","title":"Tuple contents"},{"location":"strategy/GetCovertActionEvents_Settings/#listener-template","text":"static function EventListenerReturn OnGetCovertActionEvents_Settings(Object EventData, Object EventSource, XComGameState GameState, Name EventID, Object CallbackObject) { local XComGameState_HeadquartersXCom XComHQ; local XComLWTuple Tuple; local bool AddAll; local bool InsertSorted; XComHQ = XComGameState_HeadquartersXCom(EventSource); Tuple = XComLWTuple(EventData); // Your code here Tuple.Data[0].b = AddAll; Tuple.Data[1].b = InsertSorted; return ELR_NoInterrupt; }","title":"Listener template"},{"location":"strategy/GetCovertActionEvents_Settings/#source-code-references","text":"XComGameState_HeadquartersXCom.uc:8016-8028","title":"Source code references"},{"location":"strategy/GetNumHeavyWeaponSlotsOverride/","text":"GetNumHeavyWeaponSlotsOverride Tracking Issue: #171 Tags: loadoutslots The GetNumHeavyWeaponSlotsOverride() X2DLCInfo method allows mods to override the base game logic that determines how many Heavy Weapon Slots a Unit has. To do so, simply interact with the NumHeavySlots argument by increasing, decreasing or setting its value directly. Note that this X2DLCInfo method is executed after the OverrideHasHeavyWeapon event, and may override its result. Source code references X2DownloadableContentInfo.uc:352-358","title":"GetNumHeavyWeaponSlotsOverride"},{"location":"strategy/GetNumHeavyWeaponSlotsOverride/#getnumheavyweaponslotsoverride","text":"Tracking Issue: #171 Tags: loadoutslots The GetNumHeavyWeaponSlotsOverride() X2DLCInfo method allows mods to override the base game logic that determines how many Heavy Weapon Slots a Unit has. To do so, simply interact with the NumHeavySlots argument by increasing, decreasing or setting its value directly. Note that this X2DLCInfo method is executed after the OverrideHasHeavyWeapon event, and may override its result.","title":"GetNumHeavyWeaponSlotsOverride"},{"location":"strategy/GetNumHeavyWeaponSlotsOverride/#source-code-references","text":"X2DownloadableContentInfo.uc:352-358","title":"Source code references"},{"location":"strategy/HeadquartersUnitFired/","text":"HeadquartersUnitFired Tracking Issue: #871 Tags: events This event is triggered when an XComGameStateContext_HeadquartersOrder of eHeadquartersOrderType_FireStaff type is submitted. The unit state in question is already removed ( RemoveStateObject ) when the event is triggered. Usually this happens when the player presses \"DISMISS\" in the armory menu. HeadquartersUnitFired event Param Value EventID HeadquartersUnitFired EventData none EventSource XComGameState_Unit NewGameState yes Listener template static function EventListenerReturn OnHeadquartersUnitFired(Object EventData, Object EventSource, XComGameState GameState, Name EventID, Object CallbackObject) { local XComGameState_Unit FiredUnit; FiredUnit = XComGameState_Unit(EventSource); // Your code here return ELR_NoInterrupt; } Source code references XComGameStateContext_HeadquartersOrder.uc:337-349","title":"HeadquartersUnitFired"},{"location":"strategy/HeadquartersUnitFired/#headquartersunitfired","text":"Tracking Issue: #871 Tags: events This event is triggered when an XComGameStateContext_HeadquartersOrder of eHeadquartersOrderType_FireStaff type is submitted. The unit state in question is already removed ( RemoveStateObject ) when the event is triggered. Usually this happens when the player presses \"DISMISS\" in the armory menu.","title":"HeadquartersUnitFired"},{"location":"strategy/HeadquartersUnitFired/#headquartersunitfired-event","text":"Param Value EventID HeadquartersUnitFired EventData none EventSource XComGameState_Unit NewGameState yes","title":"HeadquartersUnitFired event"},{"location":"strategy/HeadquartersUnitFired/#listener-template","text":"static function EventListenerReturn OnHeadquartersUnitFired(Object EventData, Object EventSource, XComGameState GameState, Name EventID, Object CallbackObject) { local XComGameState_Unit FiredUnit; FiredUnit = XComGameState_Unit(EventSource); // Your code here return ELR_NoInterrupt; }","title":"Listener template"},{"location":"strategy/HeadquartersUnitFired/#source-code-references","text":"XComGameStateContext_HeadquartersOrder.uc:337-349","title":"Source code references"},{"location":"strategy/ItemUpgraded/","text":"ItemUpgraded Tracking Issue: #289 Tags: events This is an event that allows mods to perform non-standard handling to item states when they are upgraded to a new tier. It is fired up to four times during upgrading: * When upgrading the infinite item, if any. * When upgrading utility items, like grenades and medkits. * When upgrading unequipped items that have attachments * When upgrading equipped items that have attachments Note: EventSource (BaseItem) will be none when the event is triggered by upgrading an infinite item. This is because infinite items are created rather than upgraded. ItemUpgraded event Param Value EventID ItemUpgraded EventData XComGameState_Item EventSource XComGameState_Item NewGameState yes Listener template static function EventListenerReturn OnItemUpgraded(Object EventData, Object EventSource, XComGameState GameState, Name EventID, Object CallbackObject) { local XComGameState_Item BaseItem; local XComGameState_Item UpgradedItem; BaseItem = XComGameState_Item(EventSource); UpgradedItem = XComGameState_Item(EventData); // Your code here return ELR_NoInterrupt; } Source code references XComGameState_HeadquartersXCom.uc:4655-4670","title":"ItemUpgraded"},{"location":"strategy/ItemUpgraded/#itemupgraded","text":"Tracking Issue: #289 Tags: events This is an event that allows mods to perform non-standard handling to item states when they are upgraded to a new tier. It is fired up to four times during upgrading: * When upgrading the infinite item, if any. * When upgrading utility items, like grenades and medkits. * When upgrading unequipped items that have attachments * When upgrading equipped items that have attachments Note: EventSource (BaseItem) will be none when the event is triggered by upgrading an infinite item. This is because infinite items are created rather than upgraded.","title":"ItemUpgraded"},{"location":"strategy/ItemUpgraded/#itemupgraded-event","text":"Param Value EventID ItemUpgraded EventData XComGameState_Item EventSource XComGameState_Item NewGameState yes","title":"ItemUpgraded event"},{"location":"strategy/ItemUpgraded/#listener-template","text":"static function EventListenerReturn OnItemUpgraded(Object EventData, Object EventSource, XComGameState GameState, Name EventID, Object CallbackObject) { local XComGameState_Item BaseItem; local XComGameState_Item UpgradedItem; BaseItem = XComGameState_Item(EventSource); UpgradedItem = XComGameState_Item(EventData); // Your code here return ELR_NoInterrupt; }","title":"Listener template"},{"location":"strategy/ItemUpgraded/#source-code-references","text":"XComGameState_HeadquartersXCom.uc:4655-4670","title":"Source code references"},{"location":"strategy/NonWeaponUpgradeSlots/","text":"NonWeaponUpgradeSlots Tracking Issue: #93 Mods can add upgrade slots to items that are not based on X2WeaponTemplate by adding entries to NonWeaponUpgradeSlots config array in XComGame.ini , for example: [XComGame.CHHelpers] +NonWeaponUpgradeSlots = (TemplateName = \"KevlarArmor\", NumUpgradeSlots = 1) +NonWeaponUpgradeSlots = (TemplateName = \"PlatedArmor\", NumUpgradeSlots = 2) +NonWeaponUpgradeSlots = (TemplateName = \"PoweredArmor\", NumUpgradeSlots = 3) Note that if several mods add config entries for the same item template, only the first one one will take effect. Which one counts as first will depend on the config load order. Source code references X2ItemTemplate.uc:366-376","title":"NonWeaponUpgradeSlots"},{"location":"strategy/NonWeaponUpgradeSlots/#nonweaponupgradeslots","text":"Tracking Issue: #93 Mods can add upgrade slots to items that are not based on X2WeaponTemplate by adding entries to NonWeaponUpgradeSlots config array in XComGame.ini , for example: [XComGame.CHHelpers] +NonWeaponUpgradeSlots = (TemplateName = \"KevlarArmor\", NumUpgradeSlots = 1) +NonWeaponUpgradeSlots = (TemplateName = \"PlatedArmor\", NumUpgradeSlots = 2) +NonWeaponUpgradeSlots = (TemplateName = \"PoweredArmor\", NumUpgradeSlots = 3) Note that if several mods add config entries for the same item template, only the first one one will take effect. Which one counts as first will depend on the config load order.","title":"NonWeaponUpgradeSlots"},{"location":"strategy/NonWeaponUpgradeSlots/#source-code-references","text":"X2ItemTemplate.uc:366-376","title":"Source code references"},{"location":"strategy/OnBestGearLoadoutApplied/","text":"OnBestGearLoadoutApplied Tracking Issue: #676 Tags: events The XComGameState_Unit::ApplyBestGearLoadout does not perform CanAddItemToInventory checks when it picks the best gear for the soldier, so if one of the selected items by that function cannot be equipped due to an override in CanAddItemToInventory_CH, the inventory slot will remain empty. This event passes along the Unit State whenever this function is called, so the mods can use their arbitrary conditions to decide what is the actual best gear loadout is for a unit. OnBestGearLoadoutApplied event Param Value EventID OnBestGearLoadoutApplied EventData XComGameState_Unit EventSource XComGameState_Unit NewGameState yes Listener template static function EventListenerReturn OnOnBestGearLoadoutApplied(Object EventData, Object EventSource, XComGameState GameState, Name EventID, Object CallbackObject) { local XComGameState_Unit UnitState; UnitState = XComGameState_Unit(EventData); // Your code here return ELR_NoInterrupt; } // This EventFn requires the Event Listener to use an ELD_Immediate deferral. static function EventListenerReturn OnBestGearLoadoutApplied_Listener(Object EventData, Object EventSource, XComGameState NewGameState, Name Event, Object CallbackData) { local XComGameState_Unit UnitState; // This gets you Unit State from History. UnitState = XComGameState_Unit(EventData); // Here you can *read* the Unit State. // Get the Unit State from the pending New Game State. UnitState = XComGameState_Unit(NewGameState.GetGameStateForObjectID(UnitState.ObjectID)); // Now you can make changes to the Unit State, such as changing its equipment based on arbitrary conditions. } Source code references XComGameState_Unit.uc:11575-11604","title":"OnBestGearLoadoutApplied"},{"location":"strategy/OnBestGearLoadoutApplied/#onbestgearloadoutapplied","text":"Tracking Issue: #676 Tags: events The XComGameState_Unit::ApplyBestGearLoadout does not perform CanAddItemToInventory checks when it picks the best gear for the soldier, so if one of the selected items by that function cannot be equipped due to an override in CanAddItemToInventory_CH, the inventory slot will remain empty. This event passes along the Unit State whenever this function is called, so the mods can use their arbitrary conditions to decide what is the actual best gear loadout is for a unit.","title":"OnBestGearLoadoutApplied"},{"location":"strategy/OnBestGearLoadoutApplied/#onbestgearloadoutapplied-event","text":"Param Value EventID OnBestGearLoadoutApplied EventData XComGameState_Unit EventSource XComGameState_Unit NewGameState yes","title":"OnBestGearLoadoutApplied event"},{"location":"strategy/OnBestGearLoadoutApplied/#listener-template","text":"static function EventListenerReturn OnOnBestGearLoadoutApplied(Object EventData, Object EventSource, XComGameState GameState, Name EventID, Object CallbackObject) { local XComGameState_Unit UnitState; UnitState = XComGameState_Unit(EventData); // Your code here return ELR_NoInterrupt; } // This EventFn requires the Event Listener to use an ELD_Immediate deferral. static function EventListenerReturn OnBestGearLoadoutApplied_Listener(Object EventData, Object EventSource, XComGameState NewGameState, Name Event, Object CallbackData) { local XComGameState_Unit UnitState; // This gets you Unit State from History. UnitState = XComGameState_Unit(EventData); // Here you can *read* the Unit State. // Get the Unit State from the pending New Game State. UnitState = XComGameState_Unit(NewGameState.GetGameStateForObjectID(UnitState.ObjectID)); // Now you can make changes to the Unit State, such as changing its equipment based on arbitrary conditions. }","title":"Listener template"},{"location":"strategy/OnBestGearLoadoutApplied/#source-code-references","text":"XComGameState_Unit.uc:11575-11604","title":"Source code references"},{"location":"strategy/OnGetPCSImage/","text":"OnGetPCSImage Tracking Issue: #110 Tags: ui , events Allows overriding the UI image for a PCS. The base game switches on the stat being boosted, which precludes custom PCS from having a custom icon. Note that for historical reasons, the tuple ID is GetPCSImageTuple while the event ID is OnGetPCSImage . OnGetPCSImage event Param Value EventID OnGetPCSImage EventData XComLWTuple EventSource none NewGameState none Tuple contents Index Name Type Direction 0 ItemState XComGameState_Item in 1 ImagePath string out Listener template static function EventListenerReturn OnOnGetPCSImage(Object EventData, Object EventSource, XComGameState GameState, Name EventID, Object CallbackObject) { local XComLWTuple Tuple; local XComGameState_Item ItemState; local string ImagePath; Tuple = XComLWTuple(EventData); ItemState = XComGameState_Item(Tuple.Data[0].o); // Your code here Tuple.Data[1].s = ImagePath; return ELR_NoInterrupt; } Source code references UIUtilities_Image.uc:841-852","title":"OnGetPCSImage"},{"location":"strategy/OnGetPCSImage/#ongetpcsimage","text":"Tracking Issue: #110 Tags: ui , events Allows overriding the UI image for a PCS. The base game switches on the stat being boosted, which precludes custom PCS from having a custom icon. Note that for historical reasons, the tuple ID is GetPCSImageTuple while the event ID is OnGetPCSImage .","title":"OnGetPCSImage"},{"location":"strategy/OnGetPCSImage/#ongetpcsimage-event","text":"Param Value EventID OnGetPCSImage EventData XComLWTuple EventSource none NewGameState none","title":"OnGetPCSImage event"},{"location":"strategy/OnGetPCSImage/#tuple-contents","text":"Index Name Type Direction 0 ItemState XComGameState_Item in 1 ImagePath string out","title":"Tuple contents"},{"location":"strategy/OnGetPCSImage/#listener-template","text":"static function EventListenerReturn OnOnGetPCSImage(Object EventData, Object EventSource, XComGameState GameState, Name EventID, Object CallbackObject) { local XComLWTuple Tuple; local XComGameState_Item ItemState; local string ImagePath; Tuple = XComLWTuple(EventData); ItemState = XComGameState_Item(Tuple.Data[0].o); // Your code here Tuple.Data[1].s = ImagePath; return ELR_NoInterrupt; }","title":"Listener template"},{"location":"strategy/OnGetPCSImage/#source-code-references","text":"UIUtilities_Image.uc:841-852","title":"Source code references"},{"location":"strategy/OverrideAllowStartingRegionLink/","text":"OverrideAllowStartingRegionLink Tracking Issue: #774 Tags: events This event allows mods to override the default behavior for whether a region can be linked to a potential starting region. The default behavior is that the two regions must be in the same continent if they are to be linked. To override that behavior, add a listener that has RegisterInCampaignStart set to true and within the listener function simply change the value of the AllowLink field in the given tuple data. For example, you could always set it to true to remove the constraints completely, so that a starting region can be linked to any neighboring region. This event is triggered during a start state, which you can access via XComGameStateHistory:GetStartState() . OverrideAllowStartingRegionLink event Param Value EventID OverrideAllowStartingRegionLink EventData XComLWTuple EventSource XComGameState_WorldRegion NewGameState none Tuple contents Index Name Type Direction 0 LinkedRegion XComGameState_WorldRegion in 1 AllowLink bool inout Listener template static function EventListenerReturn OnOverrideAllowStartingRegionLink(Object EventData, Object EventSource, XComGameState GameState, Name EventID, Object CallbackObject) { local XComGameState_WorldRegion PotentialStartRegion; local XComLWTuple Tuple; local XComGameState_WorldRegion LinkedRegion; local bool AllowLink; PotentialStartRegion = XComGameState_WorldRegion(EventSource); Tuple = XComLWTuple(EventData); LinkedRegion = XComGameState_WorldRegion(Tuple.Data[0].o); AllowLink = Tuple.Data[1].b; // Your code here Tuple.Data[1].b = AllowLink; return ELR_NoInterrupt; } Source code references XComGameState_RegionLink.uc:253-272","title":"OverrideAllowStartingRegionLink"},{"location":"strategy/OverrideAllowStartingRegionLink/#overrideallowstartingregionlink","text":"Tracking Issue: #774 Tags: events This event allows mods to override the default behavior for whether a region can be linked to a potential starting region. The default behavior is that the two regions must be in the same continent if they are to be linked. To override that behavior, add a listener that has RegisterInCampaignStart set to true and within the listener function simply change the value of the AllowLink field in the given tuple data. For example, you could always set it to true to remove the constraints completely, so that a starting region can be linked to any neighboring region. This event is triggered during a start state, which you can access via XComGameStateHistory:GetStartState() .","title":"OverrideAllowStartingRegionLink"},{"location":"strategy/OverrideAllowStartingRegionLink/#overrideallowstartingregionlink-event","text":"Param Value EventID OverrideAllowStartingRegionLink EventData XComLWTuple EventSource XComGameState_WorldRegion NewGameState none","title":"OverrideAllowStartingRegionLink event"},{"location":"strategy/OverrideAllowStartingRegionLink/#tuple-contents","text":"Index Name Type Direction 0 LinkedRegion XComGameState_WorldRegion in 1 AllowLink bool inout","title":"Tuple contents"},{"location":"strategy/OverrideAllowStartingRegionLink/#listener-template","text":"static function EventListenerReturn OnOverrideAllowStartingRegionLink(Object EventData, Object EventSource, XComGameState GameState, Name EventID, Object CallbackObject) { local XComGameState_WorldRegion PotentialStartRegion; local XComLWTuple Tuple; local XComGameState_WorldRegion LinkedRegion; local bool AllowLink; PotentialStartRegion = XComGameState_WorldRegion(EventSource); Tuple = XComLWTuple(EventData); LinkedRegion = XComGameState_WorldRegion(Tuple.Data[0].o); AllowLink = Tuple.Data[1].b; // Your code here Tuple.Data[1].b = AllowLink; return ELR_NoInterrupt; }","title":"Listener template"},{"location":"strategy/OverrideAllowStartingRegionLink/#source-code-references","text":"XComGameState_RegionLink.uc:253-272","title":"Source code references"},{"location":"strategy/OverrideCanTakeFacilityMission/","text":"OverrideCanTakeFacilityMission Tracking Issue: #875 Tags: events , ui EventID: OverrideCanTakeFacilityMission EventData: XComLWTuple { Data: [ inout bool CanTakeMission, in UIMission_AlienFacility (self) ] } EventSource: XComGameState_MissionSite NewGameState: no Source code references UIMission_AlienFacility.uc:242-253","title":"OverrideCanTakeFacilityMission"},{"location":"strategy/OverrideCanTakeFacilityMission/#overridecantakefacilitymission","text":"Tracking Issue: #875 Tags: events , ui EventID: OverrideCanTakeFacilityMission EventData: XComLWTuple { Data: [ inout bool CanTakeMission, in UIMission_AlienFacility (self) ] } EventSource: XComGameState_MissionSite NewGameState: no","title":"OverrideCanTakeFacilityMission"},{"location":"strategy/OverrideCanTakeFacilityMission/#source-code-references","text":"UIMission_AlienFacility.uc:242-253","title":"Source code references"},{"location":"strategy/OverrideDarkEventCount/","text":"OverrideDarkEventCount Tracking Issue: #711 Tags: events Triggers the event OverrideDarkEventCount to allow mods to change the number of dark events in the monthly report. OverrideDarkEventCount event Param Value EventID OverrideDarkEventCount EventData XComLWTuple EventSource XComGameState_HeadquartersAlien NewGameState yes Tuple contents Index Name Type Direction 0 NumEvents int inout 1 bChosenAddedEvent bool inout Listener template static function EventListenerReturn OnOverrideDarkEventCount(Object EventData, Object EventSource, XComGameState GameState, Name EventID, Object CallbackObject) { local XComGameState_HeadquartersAlien AlienHQ; local XComLWTuple Tuple; local int NumEvents; local bool bChosenAddedEvent; AlienHQ = XComGameState_HeadquartersAlien(EventSource); Tuple = XComLWTuple(EventData); NumEvents = Tuple.Data[0].i; bChosenAddedEvent = Tuple.Data[1].b; // Your code here Tuple.Data[0].i = NumEvents; Tuple.Data[1].b = bChosenAddedEvent; return ELR_NoInterrupt; } Source code references XComGameState_HeadquartersAlien.uc:1795-1807","title":"OverrideDarkEventCount"},{"location":"strategy/OverrideDarkEventCount/#overridedarkeventcount","text":"Tracking Issue: #711 Tags: events Triggers the event OverrideDarkEventCount to allow mods to change the number of dark events in the monthly report.","title":"OverrideDarkEventCount"},{"location":"strategy/OverrideDarkEventCount/#overridedarkeventcount-event","text":"Param Value EventID OverrideDarkEventCount EventData XComLWTuple EventSource XComGameState_HeadquartersAlien NewGameState yes","title":"OverrideDarkEventCount event"},{"location":"strategy/OverrideDarkEventCount/#tuple-contents","text":"Index Name Type Direction 0 NumEvents int inout 1 bChosenAddedEvent bool inout","title":"Tuple contents"},{"location":"strategy/OverrideDarkEventCount/#listener-template","text":"static function EventListenerReturn OnOverrideDarkEventCount(Object EventData, Object EventSource, XComGameState GameState, Name EventID, Object CallbackObject) { local XComGameState_HeadquartersAlien AlienHQ; local XComLWTuple Tuple; local int NumEvents; local bool bChosenAddedEvent; AlienHQ = XComGameState_HeadquartersAlien(EventSource); Tuple = XComLWTuple(EventData); NumEvents = Tuple.Data[0].i; bChosenAddedEvent = Tuple.Data[1].b; // Your code here Tuple.Data[0].i = NumEvents; Tuple.Data[1].b = bChosenAddedEvent; return ELR_NoInterrupt; }","title":"Listener template"},{"location":"strategy/OverrideDarkEventCount/#source-code-references","text":"XComGameState_HeadquartersAlien.uc:1795-1807","title":"Source code references"},{"location":"strategy/OverrideHasAmmoPocket/","text":"OverrideHasAmmoPocket Tracking Issue: #735 Tags: loadoutslots , events Extends the ability check in HasAmmoPocket() for the config array AbilityUnlocksAmmoPocket ( XComGameData.ini ) to item granted abilities and abilities granted by the character template. Finally the event OverrideHasAmmoPocket is triggered that allows mods to override the final result OverrideHasAmmoPocket event Param Value EventID OverrideHasAmmoPocket EventData XComLWTuple EventSource XComGameState_Unit NewGameState none Tuple contents Index Name Type Direction 0 bHasAmmoPocket bool inout Listener template static function EventListenerReturn OnOverrideHasAmmoPocket(Object EventData, Object EventSource, XComGameState GameState, Name EventID, Object CallbackObject) { local XComGameState_Unit UnitState; local XComLWTuple Tuple; local bool bHasAmmoPocket; UnitState = XComGameState_Unit(EventSource); Tuple = XComLWTuple(EventData); bHasAmmoPocket = Tuple.Data[0].b; // Your code here Tuple.Data[0].b = bHasAmmoPocket; return ELR_NoInterrupt; } Source code references XComGameState_Unit.uc:3966-3976","title":"OverrideHasAmmoPocket"},{"location":"strategy/OverrideHasAmmoPocket/#overridehasammopocket","text":"Tracking Issue: #735 Tags: loadoutslots , events Extends the ability check in HasAmmoPocket() for the config array AbilityUnlocksAmmoPocket ( XComGameData.ini ) to item granted abilities and abilities granted by the character template. Finally the event OverrideHasAmmoPocket is triggered that allows mods to override the final result","title":"OverrideHasAmmoPocket"},{"location":"strategy/OverrideHasAmmoPocket/#overridehasammopocket-event","text":"Param Value EventID OverrideHasAmmoPocket EventData XComLWTuple EventSource XComGameState_Unit NewGameState none","title":"OverrideHasAmmoPocket event"},{"location":"strategy/OverrideHasAmmoPocket/#tuple-contents","text":"Index Name Type Direction 0 bHasAmmoPocket bool inout","title":"Tuple contents"},{"location":"strategy/OverrideHasAmmoPocket/#listener-template","text":"static function EventListenerReturn OnOverrideHasAmmoPocket(Object EventData, Object EventSource, XComGameState GameState, Name EventID, Object CallbackObject) { local XComGameState_Unit UnitState; local XComLWTuple Tuple; local bool bHasAmmoPocket; UnitState = XComGameState_Unit(EventSource); Tuple = XComLWTuple(EventData); bHasAmmoPocket = Tuple.Data[0].b; // Your code here Tuple.Data[0].b = bHasAmmoPocket; return ELR_NoInterrupt; }","title":"Listener template"},{"location":"strategy/OverrideHasAmmoPocket/#source-code-references","text":"XComGameState_Unit.uc:3966-3976","title":"Source code references"},{"location":"strategy/OverrideHasExtraUtilitySlot/","text":"OverrideHasExtraUtilitySlot Tracking Issue: #735 Tags: loadoutslots , events Extends the ability check in HasExtraUtilitySlot() for the config array AbilityUnlocksExtraUtilitySlot ( XComGameData.ini ) to item granted abilities and abilities granted by the character template. Finally the event OverrideHasExtraUtilitySlot is triggered that allows mods to override the final result OverrideHasExtraUtilitySlot event Param Value EventID OverrideHasExtraUtilitySlot EventData XComLWTuple EventSource XComGameState_Unit NewGameState none Tuple contents Index Name Type Direction 0 bHasExtraUtilitySlot bool inout Listener template static function EventListenerReturn OnOverrideHasExtraUtilitySlot(Object EventData, Object EventSource, XComGameState GameState, Name EventID, Object CallbackObject) { local XComGameState_Unit UnitState; local XComLWTuple Tuple; local bool bHasExtraUtilitySlot; UnitState = XComGameState_Unit(EventSource); Tuple = XComLWTuple(EventData); bHasExtraUtilitySlot = Tuple.Data[0].b; // Your code here Tuple.Data[0].b = bHasExtraUtilitySlot; return ELR_NoInterrupt; } Source code references XComGameState_Unit.uc:3991-4001","title":"OverrideHasExtraUtilitySlot"},{"location":"strategy/OverrideHasExtraUtilitySlot/#overridehasextrautilityslot","text":"Tracking Issue: #735 Tags: loadoutslots , events Extends the ability check in HasExtraUtilitySlot() for the config array AbilityUnlocksExtraUtilitySlot ( XComGameData.ini ) to item granted abilities and abilities granted by the character template. Finally the event OverrideHasExtraUtilitySlot is triggered that allows mods to override the final result","title":"OverrideHasExtraUtilitySlot"},{"location":"strategy/OverrideHasExtraUtilitySlot/#overridehasextrautilityslot-event","text":"Param Value EventID OverrideHasExtraUtilitySlot EventData XComLWTuple EventSource XComGameState_Unit NewGameState none","title":"OverrideHasExtraUtilitySlot event"},{"location":"strategy/OverrideHasExtraUtilitySlot/#tuple-contents","text":"Index Name Type Direction 0 bHasExtraUtilitySlot bool inout","title":"Tuple contents"},{"location":"strategy/OverrideHasExtraUtilitySlot/#listener-template","text":"static function EventListenerReturn OnOverrideHasExtraUtilitySlot(Object EventData, Object EventSource, XComGameState GameState, Name EventID, Object CallbackObject) { local XComGameState_Unit UnitState; local XComLWTuple Tuple; local bool bHasExtraUtilitySlot; UnitState = XComGameState_Unit(EventSource); Tuple = XComLWTuple(EventData); bHasExtraUtilitySlot = Tuple.Data[0].b; // Your code here Tuple.Data[0].b = bHasExtraUtilitySlot; return ELR_NoInterrupt; }","title":"Listener template"},{"location":"strategy/OverrideHasExtraUtilitySlot/#source-code-references","text":"XComGameState_Unit.uc:3991-4001","title":"Source code references"},{"location":"strategy/OverrideHasGrenadePocket/","text":"OverrideHasGrenadePocket Tracking Issue: #735 Tags: loadoutslots , events Extends the ability check in HasGrenadePocket() for the config array AbilityUnlocksGrenadePocket ( XComGameData.ini ) to item granted abilities and abilities granted by the character template. Finally the event OverrideHasGrenadePocket is triggered that allows mods to override the final result OverrideHasGrenadePocket event Param Value EventID OverrideHasGrenadePocket EventData XComLWTuple EventSource XComGameState_Unit NewGameState none Tuple contents Index Name Type Direction 0 bHasGrenadePocket bool inout Listener template static function EventListenerReturn OnOverrideHasGrenadePocket(Object EventData, Object EventSource, XComGameState GameState, Name EventID, Object CallbackObject) { local XComGameState_Unit SourceUnit; local XComLWTuple Tuple; local bool bHasGrenadePocket; SourceUnit = XComGameState_Unit(EventSource); Tuple = XComLWTuple(EventData); bHasGrenadePocket = Tuple.Data[0].b; // Your code here Tuple.Data[0].b = bHasGrenadePocket; return ELR_NoInterrupt; } Source code references XComGameState_Unit.uc:3942-3952","title":"OverrideHasGrenadePocket"},{"location":"strategy/OverrideHasGrenadePocket/#overridehasgrenadepocket","text":"Tracking Issue: #735 Tags: loadoutslots , events Extends the ability check in HasGrenadePocket() for the config array AbilityUnlocksGrenadePocket ( XComGameData.ini ) to item granted abilities and abilities granted by the character template. Finally the event OverrideHasGrenadePocket is triggered that allows mods to override the final result","title":"OverrideHasGrenadePocket"},{"location":"strategy/OverrideHasGrenadePocket/#overridehasgrenadepocket-event","text":"Param Value EventID OverrideHasGrenadePocket EventData XComLWTuple EventSource XComGameState_Unit NewGameState none","title":"OverrideHasGrenadePocket event"},{"location":"strategy/OverrideHasGrenadePocket/#tuple-contents","text":"Index Name Type Direction 0 bHasGrenadePocket bool inout","title":"Tuple contents"},{"location":"strategy/OverrideHasGrenadePocket/#listener-template","text":"static function EventListenerReturn OnOverrideHasGrenadePocket(Object EventData, Object EventSource, XComGameState GameState, Name EventID, Object CallbackObject) { local XComGameState_Unit SourceUnit; local XComLWTuple Tuple; local bool bHasGrenadePocket; SourceUnit = XComGameState_Unit(EventSource); Tuple = XComLWTuple(EventData); bHasGrenadePocket = Tuple.Data[0].b; // Your code here Tuple.Data[0].b = bHasGrenadePocket; return ELR_NoInterrupt; }","title":"Listener template"},{"location":"strategy/OverrideHasGrenadePocket/#source-code-references","text":"XComGameState_Unit.uc:3942-3952","title":"Source code references"},{"location":"strategy/OverrideHasHeavyWeapon/","text":"OverrideHasHeavyWeapon Tracking Issue: #172 Tags: loadoutslots , events The OverrideHasHeavyWeapon event allows mods to override the base game logic that determines whether a Unit has a Heavy Weapon Slot or not. Keep in mind the GetNumHeavyWeaponSlotsOverride() X2DLCInfo method may override this later. OverrideHasHeavyWeapon event Param Value EventID OverrideHasHeavyWeapon EventData XComLWTuple EventSource XComGameState_Unit NewGameState maybe Tuple contents Index Name Type Direction 0 bOverrideHasHeavyWeapon bool inout 1 bHasHeavyWeapon bool inout Listener template static function EventListenerReturn OnOverrideHasHeavyWeapon(Object EventData, Object EventSource, XComGameState GameState, Name EventID, Object CallbackObject) { local XComGameState_Unit UnitState; local XComLWTuple Tuple; local bool bOverrideHasHeavyWeapon; local bool bHasHeavyWeapon; UnitState = XComGameState_Unit(EventSource); Tuple = XComLWTuple(EventData); bOverrideHasHeavyWeapon = Tuple.Data[0].b; bHasHeavyWeapon = Tuple.Data[1].b; // Your code here Tuple.Data[0].b = bOverrideHasHeavyWeapon; Tuple.Data[1].b = bHasHeavyWeapon; return ELR_NoInterrupt; } Source code references XComGameState_Unit.uc:4060-4071","title":"OverrideHasHeavyWeapon"},{"location":"strategy/OverrideHasHeavyWeapon/#overridehasheavyweapon","text":"Tracking Issue: #172 Tags: loadoutslots , events The OverrideHasHeavyWeapon event allows mods to override the base game logic that determines whether a Unit has a Heavy Weapon Slot or not. Keep in mind the GetNumHeavyWeaponSlotsOverride() X2DLCInfo method may override this later.","title":"OverrideHasHeavyWeapon"},{"location":"strategy/OverrideHasHeavyWeapon/#overridehasheavyweapon-event","text":"Param Value EventID OverrideHasHeavyWeapon EventData XComLWTuple EventSource XComGameState_Unit NewGameState maybe","title":"OverrideHasHeavyWeapon event"},{"location":"strategy/OverrideHasHeavyWeapon/#tuple-contents","text":"Index Name Type Direction 0 bOverrideHasHeavyWeapon bool inout 1 bHasHeavyWeapon bool inout","title":"Tuple contents"},{"location":"strategy/OverrideHasHeavyWeapon/#listener-template","text":"static function EventListenerReturn OnOverrideHasHeavyWeapon(Object EventData, Object EventSource, XComGameState GameState, Name EventID, Object CallbackObject) { local XComGameState_Unit UnitState; local XComLWTuple Tuple; local bool bOverrideHasHeavyWeapon; local bool bHasHeavyWeapon; UnitState = XComGameState_Unit(EventSource); Tuple = XComLWTuple(EventData); bOverrideHasHeavyWeapon = Tuple.Data[0].b; bHasHeavyWeapon = Tuple.Data[1].b; // Your code here Tuple.Data[0].b = bOverrideHasHeavyWeapon; Tuple.Data[1].b = bHasHeavyWeapon; return ELR_NoInterrupt; }","title":"Listener template"},{"location":"strategy/OverrideHasHeavyWeapon/#source-code-references","text":"XComGameState_Unit.uc:4060-4071","title":"Source code references"},{"location":"strategy/OverrideImageForItemAvaliable/","text":"OverrideImageForItemAvaliable Tracking Issue: #491 Tags: ui Allows overriding the image shown for an item in the eAlert_ItemAvailable alert. This alert is triggered when a tech completes and makes available a new item for building, but, if it happens to target a singular weapon (rather than the upgrade schematic), shows a weapon without attachments (as specified in the Template's strImage ). This event gives mods a chance to fix it. ID: OverrideImageForItemAvaliable, Data: [inout string ImagePath, in X2ItemTemplate ItemTemplate], Source: UIAlert Source code references UIAlert.uc:3418-3429","title":"OverrideImageForItemAvaliable"},{"location":"strategy/OverrideImageForItemAvaliable/#overrideimageforitemavaliable","text":"Tracking Issue: #491 Tags: ui Allows overriding the image shown for an item in the eAlert_ItemAvailable alert. This alert is triggered when a tech completes and makes available a new item for building, but, if it happens to target a singular weapon (rather than the upgrade schematic), shows a weapon without attachments (as specified in the Template's strImage ). This event gives mods a chance to fix it. ID: OverrideImageForItemAvaliable, Data: [inout string ImagePath, in X2ItemTemplate ItemTemplate], Source: UIAlert","title":"OverrideImageForItemAvaliable"},{"location":"strategy/OverrideImageForItemAvaliable/#source-code-references","text":"UIAlert.uc:3418-3429","title":"Source code references"},{"location":"strategy/OverrideItemImage_Improved/","text":"OverrideItemImage_Improved Tracking Issue: #962 The OverrideItemImage_Improved X2DLCInfo method is called from UIArmory_Loadout . It allows mods to conditionally override items' inventory image. It can be used to replace the original image entirely or to overlay an additional icon on top of it to mark the specific item. To do so replace the contents of the imagePath array or add more image paths to it. Source code references X2DownloadableContentInfo.uc:324-329","title":"OverrideItemImage_Improved"},{"location":"strategy/OverrideItemImage_Improved/#overrideitemimage_improved","text":"Tracking Issue: #962 The OverrideItemImage_Improved X2DLCInfo method is called from UIArmory_Loadout . It allows mods to conditionally override items' inventory image. It can be used to replace the original image entirely or to overlay an additional icon on top of it to mark the specific item. To do so replace the contents of the imagePath array or add more image paths to it.","title":"OverrideItemImage_Improved"},{"location":"strategy/OverrideItemImage_Improved/#source-code-references","text":"X2DownloadableContentInfo.uc:324-329","title":"Source code references"},{"location":"strategy/OverrideMissionImage/","text":"OverrideMissionImage Tracking Issue: #635 Tags: ui , events Allows overriding the image shown for a mission in the UIMission screen. OverrideMissionImage event Param Value EventID OverrideMissionImage EventData XComLWTuple EventSource XComGameState_MissionSite NewGameState none Tuple contents Index Name Type Direction 0 ImagePath string inout Listener template static function EventListenerReturn OnOverrideMissionImage(Object EventData, Object EventSource, XComGameState GameState, Name EventID, Object CallbackObject) { local XComGameState_MissionSite MissionState; local XComLWTuple Tuple; local string ImagePath; MissionState = XComGameState_MissionSite(EventSource); Tuple = XComLWTuple(EventData); ImagePath = Tuple.Data[0].s; // Your code here Tuple.Data[0].s = ImagePath; return ELR_NoInterrupt; } Source code references XComGameState_MissionSite.uc:1931-1939","title":"OverrideMissionImage"},{"location":"strategy/OverrideMissionImage/#overridemissionimage","text":"Tracking Issue: #635 Tags: ui , events Allows overriding the image shown for a mission in the UIMission screen.","title":"OverrideMissionImage"},{"location":"strategy/OverrideMissionImage/#overridemissionimage-event","text":"Param Value EventID OverrideMissionImage EventData XComLWTuple EventSource XComGameState_MissionSite NewGameState none","title":"OverrideMissionImage event"},{"location":"strategy/OverrideMissionImage/#tuple-contents","text":"Index Name Type Direction 0 ImagePath string inout","title":"Tuple contents"},{"location":"strategy/OverrideMissionImage/#listener-template","text":"static function EventListenerReturn OnOverrideMissionImage(Object EventData, Object EventSource, XComGameState GameState, Name EventID, Object CallbackObject) { local XComGameState_MissionSite MissionState; local XComLWTuple Tuple; local string ImagePath; MissionState = XComGameState_MissionSite(EventSource); Tuple = XComLWTuple(EventData); ImagePath = Tuple.Data[0].s; // Your code here Tuple.Data[0].s = ImagePath; return ELR_NoInterrupt; }","title":"Listener template"},{"location":"strategy/OverrideMissionImage/#source-code-references","text":"XComGameState_MissionSite.uc:1931-1939","title":"Source code references"},{"location":"strategy/OverrideNextRetaliationDisplay/","text":"OverrideNextRetaliationDisplay Tracking Issue: #667 Tags: events The Dark Events Screen ( UIAdventOperations ) by default shows a string like: \"Next Retaliation: 6 Weeks (Estimated)\". This event allows mods to override whether to show that text, and customize the actual displayed text. OverrideNextRetaliationDisplay event Param Value EventID OverrideNextRetaliationDisplay EventData XComLWTuple EventSource UIAdventOperations NewGameState none Tuple contents Index Name Type Direction 0 bShow bool inout 1 strHeader string inout 2 strValue string inout 3 strFooter string inout Listener template static function EventListenerReturn OnOverrideNextRetaliationDisplay(Object EventData, Object EventSource, XComGameState GameState, Name EventID, Object CallbackObject) { local UIAdventOperations Screen; local XComLWTuple Tuple; local bool bShow; local string strHeader; local string strValue; local string strFooter; Screen = UIAdventOperations(EventSource); Tuple = XComLWTuple(EventData); bShow = Tuple.Data[0].b; strHeader = Tuple.Data[1].s; strValue = Tuple.Data[2].s; strFooter = Tuple.Data[3].s; // Your code here Tuple.Data[0].b = bShow; Tuple.Data[1].s = strHeader; Tuple.Data[2].s = strValue; Tuple.Data[3].s = strFooter; return ELR_NoInterrupt; } Source code references UIAdventOperations.uc:253-268","title":"OverrideNextRetaliationDisplay"},{"location":"strategy/OverrideNextRetaliationDisplay/#overridenextretaliationdisplay","text":"Tracking Issue: #667 Tags: events The Dark Events Screen ( UIAdventOperations ) by default shows a string like: \"Next Retaliation: 6 Weeks (Estimated)\". This event allows mods to override whether to show that text, and customize the actual displayed text.","title":"OverrideNextRetaliationDisplay"},{"location":"strategy/OverrideNextRetaliationDisplay/#overridenextretaliationdisplay-event","text":"Param Value EventID OverrideNextRetaliationDisplay EventData XComLWTuple EventSource UIAdventOperations NewGameState none","title":"OverrideNextRetaliationDisplay event"},{"location":"strategy/OverrideNextRetaliationDisplay/#tuple-contents","text":"Index Name Type Direction 0 bShow bool inout 1 strHeader string inout 2 strValue string inout 3 strFooter string inout","title":"Tuple contents"},{"location":"strategy/OverrideNextRetaliationDisplay/#listener-template","text":"static function EventListenerReturn OnOverrideNextRetaliationDisplay(Object EventData, Object EventSource, XComGameState GameState, Name EventID, Object CallbackObject) { local UIAdventOperations Screen; local XComLWTuple Tuple; local bool bShow; local string strHeader; local string strValue; local string strFooter; Screen = UIAdventOperations(EventSource); Tuple = XComLWTuple(EventData); bShow = Tuple.Data[0].b; strHeader = Tuple.Data[1].s; strValue = Tuple.Data[2].s; strFooter = Tuple.Data[3].s; // Your code here Tuple.Data[0].b = bShow; Tuple.Data[1].s = strHeader; Tuple.Data[2].s = strValue; Tuple.Data[3].s = strFooter; return ELR_NoInterrupt; }","title":"Listener template"},{"location":"strategy/OverrideNextRetaliationDisplay/#source-code-references","text":"UIAdventOperations.uc:253-268","title":"Source code references"},{"location":"strategy/OverrideNumUpgradeSlots/","text":"OverrideNumUpgradeSlots Tracking Issue: #93 Tags: events This event allows mods to modify the number of upgrade slots for each individual item state. OverrideNumUpgradeSlots event Param Value EventID OverrideNumUpgradeSlots EventData XComLWTuple EventSource XComGameState_Item NewGameState none Tuple contents Index Name Type Direction 0 NumUpgradeSlots int inout Listener template static function EventListenerReturn OnOverrideNumUpgradeSlots(Object EventData, Object EventSource, XComGameState GameState, Name EventID, Object CallbackObject) { local XComGameState_Item ItemState; local XComLWTuple Tuple; local int NumUpgradeSlots; ItemState = XComGameState_Item(EventSource); Tuple = XComLWTuple(EventData); NumUpgradeSlots = Tuple.Data[0].i; // Your code here Tuple.Data[0].i = NumUpgradeSlots; return ELR_NoInterrupt; } Source code references XComGameState_Item.uc:2412-2420","title":"OverrideNumUpgradeSlots"},{"location":"strategy/OverrideNumUpgradeSlots/#overridenumupgradeslots","text":"Tracking Issue: #93 Tags: events This event allows mods to modify the number of upgrade slots for each individual item state.","title":"OverrideNumUpgradeSlots"},{"location":"strategy/OverrideNumUpgradeSlots/#overridenumupgradeslots-event","text":"Param Value EventID OverrideNumUpgradeSlots EventData XComLWTuple EventSource XComGameState_Item NewGameState none","title":"OverrideNumUpgradeSlots event"},{"location":"strategy/OverrideNumUpgradeSlots/#tuple-contents","text":"Index Name Type Direction 0 NumUpgradeSlots int inout","title":"Tuple contents"},{"location":"strategy/OverrideNumUpgradeSlots/#listener-template","text":"static function EventListenerReturn OnOverrideNumUpgradeSlots(Object EventData, Object EventSource, XComGameState GameState, Name EventID, Object CallbackObject) { local XComGameState_Item ItemState; local XComLWTuple Tuple; local int NumUpgradeSlots; ItemState = XComGameState_Item(EventSource); Tuple = XComLWTuple(EventData); NumUpgradeSlots = Tuple.Data[0].i; // Your code here Tuple.Data[0].i = NumUpgradeSlots; return ELR_NoInterrupt; }","title":"Listener template"},{"location":"strategy/OverrideNumUpgradeSlots/#source-code-references","text":"XComGameState_Item.uc:2412-2420","title":"Source code references"},{"location":"strategy/OverridePromotionBlueprintTagPrefix/","text":"OverridePromotionBlueprintTagPrefix Tracking Issue: #600 Tags: ui , events Fires an 'OverridePromotionBlueprintTagPrefix' event that allows mods to override the promotion blueprint tag prefix for the after action screen. This means that mods can ensure the camera is positioned properly when displaying their custom promotion screen during the post-mission cinematic. OverridePromotionBlueprintTagPrefix event Param Value EventID OverridePromotionBlueprintTagPrefix EventData XComLWTuple EventSource UIAfterAction NewGameState none Tuple contents Index Name Type Direction 0 UnitState XComGameState_Unit in 1 TagPrefix string inout Listener template static function EventListenerReturn OnOverridePromotionBlueprintTagPrefix(Object EventData, Object EventSource, XComGameState GameState, Name EventID, Object CallbackObject) { local UIAfterAction Screen; local XComLWTuple Tuple; local XComGameState_Unit UnitState; local string TagPrefix; Screen = UIAfterAction(EventSource); Tuple = XComLWTuple(EventData); UnitState = XComGameState_Unit(Tuple.Data[0].o); TagPrefix = Tuple.Data[1].s; // Your code here Tuple.Data[1].s = TagPrefix; return ELR_NoInterrupt; } Source code references UIAfterAction.uc:739-750","title":"OverridePromotionBlueprintTagPrefix"},{"location":"strategy/OverridePromotionBlueprintTagPrefix/#overridepromotionblueprinttagprefix","text":"Tracking Issue: #600 Tags: ui , events Fires an 'OverridePromotionBlueprintTagPrefix' event that allows mods to override the promotion blueprint tag prefix for the after action screen. This means that mods can ensure the camera is positioned properly when displaying their custom promotion screen during the post-mission cinematic.","title":"OverridePromotionBlueprintTagPrefix"},{"location":"strategy/OverridePromotionBlueprintTagPrefix/#overridepromotionblueprinttagprefix-event","text":"Param Value EventID OverridePromotionBlueprintTagPrefix EventData XComLWTuple EventSource UIAfterAction NewGameState none","title":"OverridePromotionBlueprintTagPrefix event"},{"location":"strategy/OverridePromotionBlueprintTagPrefix/#tuple-contents","text":"Index Name Type Direction 0 UnitState XComGameState_Unit in 1 TagPrefix string inout","title":"Tuple contents"},{"location":"strategy/OverridePromotionBlueprintTagPrefix/#listener-template","text":"static function EventListenerReturn OnOverridePromotionBlueprintTagPrefix(Object EventData, Object EventSource, XComGameState GameState, Name EventID, Object CallbackObject) { local UIAfterAction Screen; local XComLWTuple Tuple; local XComGameState_Unit UnitState; local string TagPrefix; Screen = UIAfterAction(EventSource); Tuple = XComLWTuple(EventData); UnitState = XComGameState_Unit(Tuple.Data[0].o); TagPrefix = Tuple.Data[1].s; // Your code here Tuple.Data[1].s = TagPrefix; return ELR_NoInterrupt; }","title":"Listener template"},{"location":"strategy/OverridePromotionBlueprintTagPrefix/#source-code-references","text":"UIAfterAction.uc:739-750","title":"Source code references"},{"location":"strategy/OverridePromotionUIClass/","text":"OverridePromotionUIClass Tracking Issue: #600 Tags: ui , events Fires an event that allows mods to override the UI class used for a given promotion screen. Note that any class provided by a mod must be UIArmory_Promotion or a subclass of it. OverridePromotionUIClass event Param Value EventID OverridePromotionUIClass EventData XComLWTuple EventSource XComHQPresentationLayer NewGameState none Tuple contents Index Name Type Direction 0 PromotionScreenType enum (CHLPromotionScreenType) in 1 PromotionUIClass class (class<UIArmory_Promotion>) inout Listener template static function EventListenerReturn OnOverridePromotionUIClass(Object EventData, Object EventSource, XComGameState GameState, Name EventID, Object CallbackObject) { local XComHQPresentationLayer Pres; local XComLWTuple Tuple; local CHLPromotionScreenType PromotionScreenType; local class<UIArmory_Promotion> PromotionUIClass; Pres = XComHQPresentationLayer(EventSource); Tuple = XComLWTuple(EventData); PromotionScreenType = CHLPromotionScreenType(Tuple.Data[0].i); PromotionUIClass = class<UIArmory_Promotion>(Tuple.Data[1].o); // Your code here Tuple.Data[1].o = PromotionUIClass; return ELR_NoInterrupt; } The following simplified example is taken from Community Promotion Screen : local XComLWTuple Tuple; local CHLPromotionScreenType ScreenType; Tuple = XComLWTuple(EventData); ScreenType = CHLPromotionScreenType(Tuple.Data[0].i); if ((ScreenType == eCHLPST_PsiOp && ShouldOverridePsiPromotionScreen()) || (ScreenType == eCHLPST_Hero && ShouldOverrideHeroPromotionScreen()) || (ScreenType == eCHLPST_Standard && ShouldOverrideStandardPromotionScreen())) { Tuple.Data[1].o = class'NPSBDP_UIArmory_PromotionHero'; } return ELR_NoInterrupt; The integer values of PromotionScreenType correspond to the CHLPromotionScreenType enum. enum CHLPromotionScreenType { eCHLPST_Standard, eCHLPST_Hero, eCHLPST_PsiOp }; Source code references XComHQPresentationLayer.uc:1517-1549 XComHQPresentationLayer.uc:4-12","title":"OverridePromotionUIClass"},{"location":"strategy/OverridePromotionUIClass/#overridepromotionuiclass","text":"Tracking Issue: #600 Tags: ui , events Fires an event that allows mods to override the UI class used for a given promotion screen. Note that any class provided by a mod must be UIArmory_Promotion or a subclass of it.","title":"OverridePromotionUIClass"},{"location":"strategy/OverridePromotionUIClass/#overridepromotionuiclass-event","text":"Param Value EventID OverridePromotionUIClass EventData XComLWTuple EventSource XComHQPresentationLayer NewGameState none","title":"OverridePromotionUIClass event"},{"location":"strategy/OverridePromotionUIClass/#tuple-contents","text":"Index Name Type Direction 0 PromotionScreenType enum (CHLPromotionScreenType) in 1 PromotionUIClass class (class<UIArmory_Promotion>) inout","title":"Tuple contents"},{"location":"strategy/OverridePromotionUIClass/#listener-template","text":"static function EventListenerReturn OnOverridePromotionUIClass(Object EventData, Object EventSource, XComGameState GameState, Name EventID, Object CallbackObject) { local XComHQPresentationLayer Pres; local XComLWTuple Tuple; local CHLPromotionScreenType PromotionScreenType; local class<UIArmory_Promotion> PromotionUIClass; Pres = XComHQPresentationLayer(EventSource); Tuple = XComLWTuple(EventData); PromotionScreenType = CHLPromotionScreenType(Tuple.Data[0].i); PromotionUIClass = class<UIArmory_Promotion>(Tuple.Data[1].o); // Your code here Tuple.Data[1].o = PromotionUIClass; return ELR_NoInterrupt; } The following simplified example is taken from Community Promotion Screen : local XComLWTuple Tuple; local CHLPromotionScreenType ScreenType; Tuple = XComLWTuple(EventData); ScreenType = CHLPromotionScreenType(Tuple.Data[0].i); if ((ScreenType == eCHLPST_PsiOp && ShouldOverridePsiPromotionScreen()) || (ScreenType == eCHLPST_Hero && ShouldOverrideHeroPromotionScreen()) || (ScreenType == eCHLPST_Standard && ShouldOverrideStandardPromotionScreen())) { Tuple.Data[1].o = class'NPSBDP_UIArmory_PromotionHero'; } return ELR_NoInterrupt; The integer values of PromotionScreenType correspond to the CHLPromotionScreenType enum. enum CHLPromotionScreenType { eCHLPST_Standard, eCHLPST_Hero, eCHLPST_PsiOp };","title":"Listener template"},{"location":"strategy/OverridePromotionUIClass/#source-code-references","text":"XComHQPresentationLayer.uc:1517-1549 XComHQPresentationLayer.uc:4-12","title":"Source code references"},{"location":"strategy/OverrideRespecSoldierProjectPoints/","text":"OverrideRespecSoldierProjectPoints Tracking Issue: #624 Tags: events The 'OverrideRespecSoldierProjectPoints' event that allows mods to override the number of project points, i.e. time required to respec a given soldier. The listener is passed the Unit State of the soldier that is to be respecced and the current amount of project points required, either from the base game's config, or from a listener that has fired earlier. To override the project points, the listener simply needs to provide a new value for the ProjectPoints element of the tuple. OverrideRespecSoldierProjectPoints event Param Value EventID OverrideRespecSoldierProjectPoints EventData XComLWTuple EventSource XComGameState_HeadquartersProjectRespecSoldier NewGameState none Tuple contents Index Name Type Direction 0 Unit XComGameState_Unit in 1 ProjectPoints int inout Listener template static function EventListenerReturn OnOverrideRespecSoldierProjectPoints(Object EventData, Object EventSource, XComGameState GameState, Name EventID, Object CallbackObject) { local XComGameState_HeadquartersProjectRespecSoldier RespecProject; local XComLWTuple Tuple; local XComGameState_Unit Unit; local int ProjectPoints; RespecProject = XComGameState_HeadquartersProjectRespecSoldier(EventSource); Tuple = XComLWTuple(EventData); Unit = XComGameState_Unit(Tuple.Data[0].o); ProjectPoints = Tuple.Data[1].i; // Your code here Tuple.Data[1].i = ProjectPoints; return ELR_NoInterrupt; } Source code references XComGameState_HeadquartersProjectRespecSoldier.uc:57-71","title":"OverrideRespecSoldierProjectPoints"},{"location":"strategy/OverrideRespecSoldierProjectPoints/#overriderespecsoldierprojectpoints","text":"Tracking Issue: #624 Tags: events The 'OverrideRespecSoldierProjectPoints' event that allows mods to override the number of project points, i.e. time required to respec a given soldier. The listener is passed the Unit State of the soldier that is to be respecced and the current amount of project points required, either from the base game's config, or from a listener that has fired earlier. To override the project points, the listener simply needs to provide a new value for the ProjectPoints element of the tuple.","title":"OverrideRespecSoldierProjectPoints"},{"location":"strategy/OverrideRespecSoldierProjectPoints/#overriderespecsoldierprojectpoints-event","text":"Param Value EventID OverrideRespecSoldierProjectPoints EventData XComLWTuple EventSource XComGameState_HeadquartersProjectRespecSoldier NewGameState none","title":"OverrideRespecSoldierProjectPoints event"},{"location":"strategy/OverrideRespecSoldierProjectPoints/#tuple-contents","text":"Index Name Type Direction 0 Unit XComGameState_Unit in 1 ProjectPoints int inout","title":"Tuple contents"},{"location":"strategy/OverrideRespecSoldierProjectPoints/#listener-template","text":"static function EventListenerReturn OnOverrideRespecSoldierProjectPoints(Object EventData, Object EventSource, XComGameState GameState, Name EventID, Object CallbackObject) { local XComGameState_HeadquartersProjectRespecSoldier RespecProject; local XComLWTuple Tuple; local XComGameState_Unit Unit; local int ProjectPoints; RespecProject = XComGameState_HeadquartersProjectRespecSoldier(EventSource); Tuple = XComLWTuple(EventData); Unit = XComGameState_Unit(Tuple.Data[0].o); ProjectPoints = Tuple.Data[1].i; // Your code here Tuple.Data[1].i = ProjectPoints; return ELR_NoInterrupt; }","title":"Listener template"},{"location":"strategy/OverrideRespecSoldierProjectPoints/#source-code-references","text":"XComGameState_HeadquartersProjectRespecSoldier.uc:57-71","title":"Source code references"},{"location":"strategy/OverrideShowPromoteIcon/","text":"OverrideShowPromoteIcon Tracking Issue: #631 Tags: events The OverrideShowPromoteIcon event allows mods to determine whether a promotion icon for a particular soldier should be displayed or not. This can be relevant for mods that add their own promotion mechanics for soldiers, e.g. a psionic class that has to go on a few missions before they can be stuck into a Psi Lab to get their promotion. OverrideShowPromoteIcon event Param Value EventID OverrideShowPromoteIcon EventData XComLWTuple EventSource XComGameState_Unit NewGameState none Tuple contents Index Name Type Direction 0 bShowPromotionIcon bool inout Listener template static function EventListenerReturn OnOverrideShowPromoteIcon(Object EventData, Object EventSource, XComGameState GameState, Name EventID, Object CallbackObject) { local XComGameState_Unit UnitState; local XComLWTuple Tuple; local bool bShowPromotionIcon; UnitState = XComGameState_Unit(EventSource); Tuple = XComLWTuple(EventData); bShowPromotionIcon = Tuple.Data[0].b; // Your code here Tuple.Data[0].b = bShowPromotionIcon; return ELR_NoInterrupt; } Source code references XComGameState_Unit.uc:13469-13481","title":"OverrideShowPromoteIcon"},{"location":"strategy/OverrideShowPromoteIcon/#overrideshowpromoteicon","text":"Tracking Issue: #631 Tags: events The OverrideShowPromoteIcon event allows mods to determine whether a promotion icon for a particular soldier should be displayed or not. This can be relevant for mods that add their own promotion mechanics for soldiers, e.g. a psionic class that has to go on a few missions before they can be stuck into a Psi Lab to get their promotion.","title":"OverrideShowPromoteIcon"},{"location":"strategy/OverrideShowPromoteIcon/#overrideshowpromoteicon-event","text":"Param Value EventID OverrideShowPromoteIcon EventData XComLWTuple EventSource XComGameState_Unit NewGameState none","title":"OverrideShowPromoteIcon event"},{"location":"strategy/OverrideShowPromoteIcon/#tuple-contents","text":"Index Name Type Direction 0 bShowPromotionIcon bool inout","title":"Tuple contents"},{"location":"strategy/OverrideShowPromoteIcon/#listener-template","text":"static function EventListenerReturn OnOverrideShowPromoteIcon(Object EventData, Object EventSource, XComGameState GameState, Name EventID, Object CallbackObject) { local XComGameState_Unit UnitState; local XComLWTuple Tuple; local bool bShowPromotionIcon; UnitState = XComGameState_Unit(EventSource); Tuple = XComLWTuple(EventData); bShowPromotionIcon = Tuple.Data[0].b; // Your code here Tuple.Data[0].b = bShowPromotionIcon; return ELR_NoInterrupt; }","title":"Listener template"},{"location":"strategy/OverrideShowPromoteIcon/#source-code-references","text":"XComGameState_Unit.uc:13469-13481","title":"Source code references"},{"location":"strategy/OverrideTotalNumKills/","text":"OverrideTotalNumKills Tracking Issue: #562 Tags: events Allows mods to override the total amount of kill XP this unit has. The event data includes the kill XP calculated by vanilla, which can be left as it is, modified, or replaced completely. One example use case is to provide an additional source of XP, such as simply going on a mission. OverrideTotalNumKills event Param Value EventID OverrideTotalNumKills EventData XComLWTuple EventSource XComGameState_Unit NewGameState none Tuple contents Index Name Type Direction 0 TotalNumKills int inout Listener template static function EventListenerReturn OnOverrideTotalNumKills(Object EventData, Object EventSource, XComGameState GameState, Name EventID, Object CallbackObject) { local XComGameState_Unit UnitState; local XComLWTuple Tuple; local int TotalNumKills; UnitState = XComGameState_Unit(EventSource); Tuple = XComLWTuple(EventData); TotalNumKills = Tuple.Data[0].i; // Your code here Tuple.Data[0].i = TotalNumKills; return ELR_NoInterrupt; } Source code references XComGameState_Unit.uc:13010-13023","title":"OverrideTotalNumKills"},{"location":"strategy/OverrideTotalNumKills/#overridetotalnumkills","text":"Tracking Issue: #562 Tags: events Allows mods to override the total amount of kill XP this unit has. The event data includes the kill XP calculated by vanilla, which can be left as it is, modified, or replaced completely. One example use case is to provide an additional source of XP, such as simply going on a mission.","title":"OverrideTotalNumKills"},{"location":"strategy/OverrideTotalNumKills/#overridetotalnumkills-event","text":"Param Value EventID OverrideTotalNumKills EventData XComLWTuple EventSource XComGameState_Unit NewGameState none","title":"OverrideTotalNumKills event"},{"location":"strategy/OverrideTotalNumKills/#tuple-contents","text":"Index Name Type Direction 0 TotalNumKills int inout","title":"Tuple contents"},{"location":"strategy/OverrideTotalNumKills/#listener-template","text":"static function EventListenerReturn OnOverrideTotalNumKills(Object EventData, Object EventSource, XComGameState GameState, Name EventID, Object CallbackObject) { local XComGameState_Unit UnitState; local XComLWTuple Tuple; local int TotalNumKills; UnitState = XComGameState_Unit(EventSource); Tuple = XComLWTuple(EventData); TotalNumKills = Tuple.Data[0].i; // Your code here Tuple.Data[0].i = TotalNumKills; return ELR_NoInterrupt; }","title":"Listener template"},{"location":"strategy/OverrideTotalNumKills/#source-code-references","text":"XComGameState_Unit.uc:13010-13023","title":"Source code references"},{"location":"strategy/PostInventoryLoadoutApplied/","text":"PostInventoryLoadoutApplied Tracking Issue: #800 Tags: events The PostInventoryLoadoutApplied event allows mods to make arbitrary changes to a Unit after they have been equipped with a Loadout by XComGameState_Unit::ApplyInventoryLoadout() . Normally this is done only once, shortly after the unit was created, but the ApplyInventoryLoadout() may call itself to also equip the Required Loadout on the unit. This means that if listeners intend to call UnitState.ApplyInventoryLoadout() themselves to equip a replacement loadout, they should use UnitState.HasLoadout() to check if the replacement loadout was already equipped by previously triggered listener. Note that the LoadoutName and LoadoutItems components of the Tuple will be empty if ApplyInventoryLoadout() fails to find the loadout it was looking for. PostInventoryLoadoutApplied event Param Value EventID PostInventoryLoadoutApplied EventData XComLWTuple EventSource XComGameState_Unit NewGameState yes Tuple contents Index Name Type Direction 0 LoadoutName name in 1 LoadoutItems array<name> in Listener template static function EventListenerReturn OnPostInventoryLoadoutApplied(Object EventData, Object EventSource, XComGameState GameState, Name EventID, Object CallbackObject) { local XComGameState_Unit UnitState; local XComLWTuple Tuple; local name LoadoutName; local array<name> LoadoutItems; UnitState = XComGameState_Unit(EventSource); Tuple = XComLWTuple(EventData); LoadoutName = Tuple.Data[0].n; LoadoutItems = Tuple.Data[1].an; // Your code here return ELR_NoInterrupt; } Refer to this feature for an event that triggers every time the unit is equipped with best available infinite weapons and armor. PostSquaddieLoadoutApplied The PostSquaddieLoadoutApplied event allows mods to make arbitrary changes to a Unit after they have been equipped with a Squaddie Loadout by XComGameState_Unit::ApplySquaddieLoadout() . Normally this function is called only when the unit is ranked up from a rookie to squaddie. Note that the LoadoutName and LoadoutItems components of the Tuple will be empty if ApplySquaddieLoadout() fails to find the loadout it was looking for. PostSquaddieLoadoutApplied event Param Value EventID PostSquaddieLoadoutApplied EventData XComLWTuple EventSource XComGameState_Unit NewGameState yes Tuple contents Index Name Type Direction 0 LoadoutName name in 1 LoadoutItems array<name> in Listener template static function EventListenerReturn OnPostSquaddieLoadoutApplied(Object EventData, Object EventSource, XComGameState GameState, Name EventID, Object CallbackObject) { local XComGameState_Unit UnitState; local XComLWTuple Tuple; local name LoadoutName; local array<name> LoadoutItems; UnitState = XComGameState_Unit(EventSource); Tuple = XComLWTuple(EventData); LoadoutName = Tuple.Data[0].n; LoadoutItems = Tuple.Data[1].an; // Your code here return ELR_NoInterrupt; } Source code references XComGameState_Unit.uc:11322-11343 XComGameState_Unit.uc:11494-11509","title":"PostInventoryLoadoutApplied"},{"location":"strategy/PostInventoryLoadoutApplied/#postinventoryloadoutapplied","text":"Tracking Issue: #800 Tags: events The PostInventoryLoadoutApplied event allows mods to make arbitrary changes to a Unit after they have been equipped with a Loadout by XComGameState_Unit::ApplyInventoryLoadout() . Normally this is done only once, shortly after the unit was created, but the ApplyInventoryLoadout() may call itself to also equip the Required Loadout on the unit. This means that if listeners intend to call UnitState.ApplyInventoryLoadout() themselves to equip a replacement loadout, they should use UnitState.HasLoadout() to check if the replacement loadout was already equipped by previously triggered listener. Note that the LoadoutName and LoadoutItems components of the Tuple will be empty if ApplyInventoryLoadout() fails to find the loadout it was looking for.","title":"PostInventoryLoadoutApplied"},{"location":"strategy/PostInventoryLoadoutApplied/#postinventoryloadoutapplied-event","text":"Param Value EventID PostInventoryLoadoutApplied EventData XComLWTuple EventSource XComGameState_Unit NewGameState yes","title":"PostInventoryLoadoutApplied event"},{"location":"strategy/PostInventoryLoadoutApplied/#tuple-contents","text":"Index Name Type Direction 0 LoadoutName name in 1 LoadoutItems array<name> in","title":"Tuple contents"},{"location":"strategy/PostInventoryLoadoutApplied/#listener-template","text":"static function EventListenerReturn OnPostInventoryLoadoutApplied(Object EventData, Object EventSource, XComGameState GameState, Name EventID, Object CallbackObject) { local XComGameState_Unit UnitState; local XComLWTuple Tuple; local name LoadoutName; local array<name> LoadoutItems; UnitState = XComGameState_Unit(EventSource); Tuple = XComLWTuple(EventData); LoadoutName = Tuple.Data[0].n; LoadoutItems = Tuple.Data[1].an; // Your code here return ELR_NoInterrupt; } Refer to this feature for an event that triggers every time the unit is equipped with best available infinite weapons and armor.","title":"Listener template"},{"location":"strategy/PostInventoryLoadoutApplied/#postsquaddieloadoutapplied","text":"The PostSquaddieLoadoutApplied event allows mods to make arbitrary changes to a Unit after they have been equipped with a Squaddie Loadout by XComGameState_Unit::ApplySquaddieLoadout() . Normally this function is called only when the unit is ranked up from a rookie to squaddie. Note that the LoadoutName and LoadoutItems components of the Tuple will be empty if ApplySquaddieLoadout() fails to find the loadout it was looking for.","title":"PostSquaddieLoadoutApplied"},{"location":"strategy/PostInventoryLoadoutApplied/#postsquaddieloadoutapplied-event","text":"Param Value EventID PostSquaddieLoadoutApplied EventData XComLWTuple EventSource XComGameState_Unit NewGameState yes","title":"PostSquaddieLoadoutApplied event"},{"location":"strategy/PostInventoryLoadoutApplied/#tuple-contents_1","text":"Index Name Type Direction 0 LoadoutName name in 1 LoadoutItems array<name> in","title":"Tuple contents"},{"location":"strategy/PostInventoryLoadoutApplied/#listener-template_1","text":"static function EventListenerReturn OnPostSquaddieLoadoutApplied(Object EventData, Object EventSource, XComGameState GameState, Name EventID, Object CallbackObject) { local XComGameState_Unit UnitState; local XComLWTuple Tuple; local name LoadoutName; local array<name> LoadoutItems; UnitState = XComGameState_Unit(EventSource); Tuple = XComLWTuple(EventData); LoadoutName = Tuple.Data[0].n; LoadoutItems = Tuple.Data[1].an; // Your code here return ELR_NoInterrupt; }","title":"Listener template"},{"location":"strategy/PostInventoryLoadoutApplied/#source-code-references","text":"XComGameState_Unit.uc:11322-11343 XComGameState_Unit.uc:11494-11509","title":"Source code references"},{"location":"strategy/PreCompleteStrategyFromTacticalTransfer/","text":"PreCompleteStrategyFromTacticalTransfer Tracking Issue: #785 Tags: events There are no events that trigger before the mission rewards and several other critical functions are processed. This event gives a way for mods to change several aspects in the transition from tactical to strategy. PreCompleteStrategyFromTacticalTransfer event Param Value EventID PreCompleteStrategyFromTacticalTransfer EventData None EventSource None NewGameState none Listener template static function EventListenerReturn OnPreCompleteStrategyFromTacticalTransfer(Object EventData, Object EventSource, XComGameState GameState, Name EventID, Object CallbackObject) { // Your code here return ELR_NoInterrupt; } Source code references XComGameStateContext_StrategyGameRule.uc:338-348","title":"PreCompleteStrategyFromTacticalTransfer"},{"location":"strategy/PreCompleteStrategyFromTacticalTransfer/#precompletestrategyfromtacticaltransfer","text":"Tracking Issue: #785 Tags: events There are no events that trigger before the mission rewards and several other critical functions are processed. This event gives a way for mods to change several aspects in the transition from tactical to strategy.","title":"PreCompleteStrategyFromTacticalTransfer"},{"location":"strategy/PreCompleteStrategyFromTacticalTransfer/#precompletestrategyfromtacticaltransfer-event","text":"Param Value EventID PreCompleteStrategyFromTacticalTransfer EventData None EventSource None NewGameState none","title":"PreCompleteStrategyFromTacticalTransfer event"},{"location":"strategy/PreCompleteStrategyFromTacticalTransfer/#listener-template","text":"static function EventListenerReturn OnPreCompleteStrategyFromTacticalTransfer(Object EventData, Object EventSource, XComGameState GameState, Name EventID, Object CallbackObject) { // Your code here return ELR_NoInterrupt; }","title":"Listener template"},{"location":"strategy/PreCompleteStrategyFromTacticalTransfer/#source-code-references","text":"XComGameStateContext_StrategyGameRule.uc:338-348","title":"Source code references"},{"location":"strategy/PreDarkEventDeactivated/","text":"PreDarkEventDeactivated Tracking Issue: #753 Tags: events Notifies listeners of when a dark event has expired/been deactivated. This event fires before the dark event's deactivation code runs, so register an ELD_Immediate listener if you want access to the state before that happens, or an ELD_OnStateSubmitted listener if you want the state after the full deactivation. PreDarkEventDeactivated event Param Value EventID PreDarkEventDeactivated EventData XComGameState_DarkEvent EventSource XComGameState_DarkEvent NewGameState yes Listener template static function EventListenerReturn OnPreDarkEventDeactivated(Object EventData, Object EventSource, XComGameState GameState, Name EventID, Object CallbackObject) { local XComGameState_DarkEvent EventState; EventState = XComGameState_DarkEvent(EventData); // Your code here return ELR_NoInterrupt; } Source code references XComGameState_DarkEvent.uc:227-239","title":"PreDarkEventDeactivated"},{"location":"strategy/PreDarkEventDeactivated/#predarkeventdeactivated","text":"Tracking Issue: #753 Tags: events Notifies listeners of when a dark event has expired/been deactivated. This event fires before the dark event's deactivation code runs, so register an ELD_Immediate listener if you want access to the state before that happens, or an ELD_OnStateSubmitted listener if you want the state after the full deactivation.","title":"PreDarkEventDeactivated"},{"location":"strategy/PreDarkEventDeactivated/#predarkeventdeactivated-event","text":"Param Value EventID PreDarkEventDeactivated EventData XComGameState_DarkEvent EventSource XComGameState_DarkEvent NewGameState yes","title":"PreDarkEventDeactivated event"},{"location":"strategy/PreDarkEventDeactivated/#listener-template","text":"static function EventListenerReturn OnPreDarkEventDeactivated(Object EventData, Object EventSource, XComGameState GameState, Name EventID, Object CallbackObject) { local XComGameState_DarkEvent EventState; EventState = XComGameState_DarkEvent(EventData); // Your code here return ELR_NoInterrupt; }","title":"Listener template"},{"location":"strategy/PreDarkEventDeactivated/#source-code-references","text":"XComGameState_DarkEvent.uc:227-239","title":"Source code references"},{"location":"strategy/PsiProjectCompleted/","text":"PsiProjectCompleted Tracking Issue: #534 Tags: events Triggers a PsiProjectCompleted event to inform mods that a Psi Operative has finished training in the Psi Lab. PsiProjectCompleted event Param Value EventID PsiProjectCompleted EventData XComLWTuple EventSource XComGameState_HeadquartersProjectPsiTraining NewGameState none Tuple contents Index Name Type Direction 0 Unit XComGameState_Unit in 1 AbilityName string in Listener template static function EventListenerReturn OnPsiProjectCompleted(Object EventData, Object EventSource, XComGameState GameState, Name EventID, Object CallbackObject) { local XComGameState_HeadquartersProjectPsiTraining PsiTrainingProject; local XComLWTuple Tuple; local XComGameState_Unit Unit; local string AbilityName; PsiTrainingProject = XComGameState_HeadquartersProjectPsiTraining(EventSource); Tuple = XComLWTuple(EventData); Unit = XComGameState_Unit(Tuple.Data[0].o); AbilityName = Tuple.Data[1].s; // Your code here return ELR_NoInterrupt; } Source code references XComGameState_HeadquartersProjectPsiTraining.uc:139-148","title":"PsiProjectCompleted"},{"location":"strategy/PsiProjectCompleted/#psiprojectcompleted","text":"Tracking Issue: #534 Tags: events Triggers a PsiProjectCompleted event to inform mods that a Psi Operative has finished training in the Psi Lab.","title":"PsiProjectCompleted"},{"location":"strategy/PsiProjectCompleted/#psiprojectcompleted-event","text":"Param Value EventID PsiProjectCompleted EventData XComLWTuple EventSource XComGameState_HeadquartersProjectPsiTraining NewGameState none","title":"PsiProjectCompleted event"},{"location":"strategy/PsiProjectCompleted/#tuple-contents","text":"Index Name Type Direction 0 Unit XComGameState_Unit in 1 AbilityName string in","title":"Tuple contents"},{"location":"strategy/PsiProjectCompleted/#listener-template","text":"static function EventListenerReturn OnPsiProjectCompleted(Object EventData, Object EventSource, XComGameState GameState, Name EventID, Object CallbackObject) { local XComGameState_HeadquartersProjectPsiTraining PsiTrainingProject; local XComLWTuple Tuple; local XComGameState_Unit Unit; local string AbilityName; PsiTrainingProject = XComGameState_HeadquartersProjectPsiTraining(EventSource); Tuple = XComLWTuple(EventData); Unit = XComGameState_Unit(Tuple.Data[0].o); AbilityName = Tuple.Data[1].s; // Your code here return ELR_NoInterrupt; }","title":"Listener template"},{"location":"strategy/PsiProjectCompleted/#source-code-references","text":"XComGameState_HeadquartersProjectPsiTraining.uc:139-148","title":"Source code references"},{"location":"strategy/RegisterInCampaignStart/","text":"RegisterInCampaignStart Tracking Issue: #869 Specifies that a listener template should be registered before campaign initialization occurs so that it can respond to events fired during that initialization (strategy listeners don't receive those events). Source code references CHEventListenerTemplate.uc:67-70","title":"RegisterInCampaignStart"},{"location":"strategy/RegisterInCampaignStart/#registerincampaignstart","text":"Tracking Issue: #869 Specifies that a listener template should be registered before campaign initialization occurs so that it can respond to events fired during that initialization (strategy listeners don't receive those events).","title":"RegisterInCampaignStart"},{"location":"strategy/RegisterInCampaignStart/#source-code-references","text":"CHEventListenerTemplate.uc:67-70","title":"Source code references"},{"location":"strategy/ShowItemInLockerList/","text":"ShowItemInLockerList Tracking Issue: #844 Tags: events Allows listeners to override the result of SlotShowItemInLockerList OverrideShowItemInLockerList event Param Value EventID OverrideShowItemInLockerList EventData XComLWTuple EventSource XComGameState_Item NewGameState maybe Tuple contents Index Name Type Direction 0 bSlotShowItemInLockerList bool inout 1 Slot enum (EInventorySlot) in 2 UnitState XComGameState_Unit in Listener template static function EventListenerReturn OnOverrideShowItemInLockerList(Object EventData, Object EventSource, XComGameState GameState, Name EventID, Object CallbackObject) { local XComGameState_Item ItemState; local XComLWTuple Tuple; local bool bSlotShowItemInLockerList; local EInventorySlot Slot; local XComGameState_Unit UnitState; ItemState = XComGameState_Item(EventSource); Tuple = XComLWTuple(EventData); bSlotShowItemInLockerList = Tuple.Data[0].b; Slot = EInventorySlot(Tuple.Data[1].i); UnitState = XComGameState_Unit(Tuple.Data[2].o); // Your code here Tuple.Data[0].b = bSlotShowItemInLockerList; return ELR_NoInterrupt; } Source code references CHItemSlot.uc:408-420","title":"ShowItemInLockerList"},{"location":"strategy/ShowItemInLockerList/#showiteminlockerlist","text":"Tracking Issue: #844 Tags: events Allows listeners to override the result of SlotShowItemInLockerList","title":"ShowItemInLockerList"},{"location":"strategy/ShowItemInLockerList/#overrideshowiteminlockerlist-event","text":"Param Value EventID OverrideShowItemInLockerList EventData XComLWTuple EventSource XComGameState_Item NewGameState maybe","title":"OverrideShowItemInLockerList event"},{"location":"strategy/ShowItemInLockerList/#tuple-contents","text":"Index Name Type Direction 0 bSlotShowItemInLockerList bool inout 1 Slot enum (EInventorySlot) in 2 UnitState XComGameState_Unit in","title":"Tuple contents"},{"location":"strategy/ShowItemInLockerList/#listener-template","text":"static function EventListenerReturn OnOverrideShowItemInLockerList(Object EventData, Object EventSource, XComGameState GameState, Name EventID, Object CallbackObject) { local XComGameState_Item ItemState; local XComLWTuple Tuple; local bool bSlotShowItemInLockerList; local EInventorySlot Slot; local XComGameState_Unit UnitState; ItemState = XComGameState_Item(EventSource); Tuple = XComLWTuple(EventData); bSlotShowItemInLockerList = Tuple.Data[0].b; Slot = EInventorySlot(Tuple.Data[1].i); UnitState = XComGameState_Unit(Tuple.Data[2].o); // Your code here Tuple.Data[0].b = bSlotShowItemInLockerList; return ELR_NoInterrupt; }","title":"Listener template"},{"location":"strategy/ShowItemInLockerList/#source-code-references","text":"CHItemSlot.uc:408-420","title":"Source code references"},{"location":"strategy/SitRepCheckAdditionalRequirements/","text":"SitRepCheckAdditionalRequirements Tracking Issue: #561 Tags: events The SitRepCheckAdditionalRequirements event allows mods to subject sitreps to additional checks for specific missions, and then either allow the sitrep to be added to the particular mission (default behavior), or forbid it. SitRepCheckAdditionalRequirements event Param Value EventID SitRepCheckAdditionalRequirements EventData XComLWTuple EventSource X2SitRepTemplate NewGameState none Tuple contents Index Name Type Direction 0 bMeetsRequirements bool inout 1 MissionState XComGameState_MissionSite in Listener template static function EventListenerReturn OnSitRepCheckAdditionalRequirements(Object EventData, Object EventSource, XComGameState GameState, Name EventID, Object CallbackObject) { local X2SitRepTemplate SitRepTemplate; local XComLWTuple Tuple; local bool bMeetsRequirements; local XComGameState_MissionSite MissionState; SitRepTemplate = X2SitRepTemplate(EventSource); Tuple = XComLWTuple(EventData); bMeetsRequirements = Tuple.Data[0].b; MissionState = XComGameState_MissionSite(Tuple.Data[1].o); // Your code here Tuple.Data[0].b = bMeetsRequirements; return ELR_NoInterrupt; } Source code references X2SitRepTemplate.uc:121-131","title":"SitRepCheckAdditionalRequirements"},{"location":"strategy/SitRepCheckAdditionalRequirements/#sitrepcheckadditionalrequirements","text":"Tracking Issue: #561 Tags: events The SitRepCheckAdditionalRequirements event allows mods to subject sitreps to additional checks for specific missions, and then either allow the sitrep to be added to the particular mission (default behavior), or forbid it.","title":"SitRepCheckAdditionalRequirements"},{"location":"strategy/SitRepCheckAdditionalRequirements/#sitrepcheckadditionalrequirements-event","text":"Param Value EventID SitRepCheckAdditionalRequirements EventData XComLWTuple EventSource X2SitRepTemplate NewGameState none","title":"SitRepCheckAdditionalRequirements event"},{"location":"strategy/SitRepCheckAdditionalRequirements/#tuple-contents","text":"Index Name Type Direction 0 bMeetsRequirements bool inout 1 MissionState XComGameState_MissionSite in","title":"Tuple contents"},{"location":"strategy/SitRepCheckAdditionalRequirements/#listener-template","text":"static function EventListenerReturn OnSitRepCheckAdditionalRequirements(Object EventData, Object EventSource, XComGameState GameState, Name EventID, Object CallbackObject) { local X2SitRepTemplate SitRepTemplate; local XComLWTuple Tuple; local bool bMeetsRequirements; local XComGameState_MissionSite MissionState; SitRepTemplate = X2SitRepTemplate(EventSource); Tuple = XComLWTuple(EventData); bMeetsRequirements = Tuple.Data[0].b; MissionState = XComGameState_MissionSite(Tuple.Data[1].o); // Your code here Tuple.Data[0].b = bMeetsRequirements; return ELR_NoInterrupt; }","title":"Listener template"},{"location":"strategy/SitRepCheckAdditionalRequirements/#source-code-references","text":"X2SitRepTemplate.uc:121-131","title":"Source code references"},{"location":"strategy/StrategyMap_NavHelpUpdated/","text":"StrategyMap_NavHelpUpdated Tracking Issue: #932 Tags: ui , events This event is fired after the base game has performed its own updates to the nav help on the Geoscape (StrategyMap), allowing mods to make further changes if they wish. StrategyMap_NavHelpUpdated event Param Value EventID StrategyMap_NavHelpUpdated EventData UINavigationHelp EventSource UIStrategyMap NewGameState none Listener template static function EventListenerReturn OnStrategyMap_NavHelpUpdated(Object EventData, Object EventSource, XComGameState GameState, Name EventID, Object CallbackObject) { local UIStrategyMap StrategyMap; StrategyMap = UIStrategyMap(EventSource); // Your code here return ELR_NoInterrupt; } Source code references UIStrategyMap.uc:703-712","title":"StrategyMap_NavHelpUpdated"},{"location":"strategy/StrategyMap_NavHelpUpdated/#strategymap_navhelpupdated","text":"Tracking Issue: #932 Tags: ui , events This event is fired after the base game has performed its own updates to the nav help on the Geoscape (StrategyMap), allowing mods to make further changes if they wish.","title":"StrategyMap_NavHelpUpdated"},{"location":"strategy/StrategyMap_NavHelpUpdated/#strategymap_navhelpupdated-event","text":"Param Value EventID StrategyMap_NavHelpUpdated EventData UINavigationHelp EventSource UIStrategyMap NewGameState none","title":"StrategyMap_NavHelpUpdated event"},{"location":"strategy/StrategyMap_NavHelpUpdated/#listener-template","text":"static function EventListenerReturn OnStrategyMap_NavHelpUpdated(Object EventData, Object EventSource, XComGameState GameState, Name EventID, Object CallbackObject) { local UIStrategyMap StrategyMap; StrategyMap = UIStrategyMap(EventSource); // Your code here return ELR_NoInterrupt; }","title":"Listener template"},{"location":"strategy/StrategyMap_NavHelpUpdated/#source-code-references","text":"UIStrategyMap.uc:703-712","title":"Source code references"},{"location":"strategy/TemporarilyBlockDarkEventActivation/","text":"TemporarilyBlockDarkEventActivation Tracking Issue: #597 While this flag is turned on, the dark event cannot activate/complete (transition from preparing to active) and will simply \"wait\" until this flag is turned off. Another possible way of looking at it is that the DE is postponed indefinitely while this flag is active but only if the EndDateTime was reached. var bool bTemporarilyBlockActivation; Source code references XComGameState_DarkEvent.uc:27-33 XComGameState_HeadquartersAlien.uc:1948","title":"TemporarilyBlockDarkEventActivation"},{"location":"strategy/TemporarilyBlockDarkEventActivation/#temporarilyblockdarkeventactivation","text":"Tracking Issue: #597 While this flag is turned on, the dark event cannot activate/complete (transition from preparing to active) and will simply \"wait\" until this flag is turned off. Another possible way of looking at it is that the DE is postponed indefinitely while this flag is active but only if the EndDateTime was reached. var bool bTemporarilyBlockActivation;","title":"TemporarilyBlockDarkEventActivation"},{"location":"strategy/TemporarilyBlockDarkEventActivation/#source-code-references","text":"XComGameState_DarkEvent.uc:27-33 XComGameState_HeadquartersAlien.uc:1948","title":"Source code references"},{"location":"strategy/UIAvengerShortcuts_ShowCQResistanceOrders/","text":"UIAvengerShortcuts_ShowCQResistanceOrders Tracking Issue: #368 Tags: ui , events Allows overriding whether the resistance orders button should be shown in UIAvengerShortcuts . Default: After the first month if any faction met. UIAvengerShortcuts_ShowCQResistanceOrders event Param Value EventID UIAvengerShortcuts_ShowCQResistanceOrders EventData XComLWTuple EventSource UIAvengerShortcuts NewGameState none Tuple contents Index Name Type Direction 0 ShouldShow bool inout Listener template static function EventListenerReturn OnUIAvengerShortcuts_ShowCQResistanceOrders(Object EventData, Object EventSource, XComGameState GameState, Name EventID, Object CallbackObject) { local UIAvengerShortcuts ShortcutsScreen; local XComLWTuple Tuple; local bool ShouldShow; ShortcutsScreen = UIAvengerShortcuts(EventSource); Tuple = XComLWTuple(EventData); ShouldShow = Tuple.Data[0].b; // Your code here Tuple.Data[0].b = ShouldShow; return ELR_NoInterrupt; } Source code references UIAvengerShortcuts.uc:1130-1139","title":"UIAvengerShortcuts_ShowCQResistanceOrders"},{"location":"strategy/UIAvengerShortcuts_ShowCQResistanceOrders/#uiavengershortcuts_showcqresistanceorders","text":"Tracking Issue: #368 Tags: ui , events Allows overriding whether the resistance orders button should be shown in UIAvengerShortcuts . Default: After the first month if any faction met.","title":"UIAvengerShortcuts_ShowCQResistanceOrders"},{"location":"strategy/UIAvengerShortcuts_ShowCQResistanceOrders/#uiavengershortcuts_showcqresistanceorders-event","text":"Param Value EventID UIAvengerShortcuts_ShowCQResistanceOrders EventData XComLWTuple EventSource UIAvengerShortcuts NewGameState none","title":"UIAvengerShortcuts_ShowCQResistanceOrders event"},{"location":"strategy/UIAvengerShortcuts_ShowCQResistanceOrders/#tuple-contents","text":"Index Name Type Direction 0 ShouldShow bool inout","title":"Tuple contents"},{"location":"strategy/UIAvengerShortcuts_ShowCQResistanceOrders/#listener-template","text":"static function EventListenerReturn OnUIAvengerShortcuts_ShowCQResistanceOrders(Object EventData, Object EventSource, XComGameState GameState, Name EventID, Object CallbackObject) { local UIAvengerShortcuts ShortcutsScreen; local XComLWTuple Tuple; local bool ShouldShow; ShortcutsScreen = UIAvengerShortcuts(EventSource); Tuple = XComLWTuple(EventData); ShouldShow = Tuple.Data[0].b; // Your code here Tuple.Data[0].b = ShouldShow; return ELR_NoInterrupt; }","title":"Listener template"},{"location":"strategy/UIAvengerShortcuts_ShowCQResistanceOrders/#source-code-references","text":"UIAvengerShortcuts.uc:1130-1139","title":"Source code references"},{"location":"strategy/UIResistanceReport_ShowCouncil/","text":"UIResistanceReport_ShowCouncil Tracking Issue: #663 Tags: ui , events Allows overriding whether to show the council guy and his remarks in the background at the end of month. UIResistanceReport_ShowCouncil event Param Value EventID UIResistanceReport_ShowCouncil EventData XComLWTuple EventSource UIResistanceReport NewGameState none Tuple contents Index Name Type Direction 0 ShouldShow bool inout Listener template static function EventListenerReturn OnUIResistanceReport_ShowCouncil(Object EventData, Object EventSource, XComGameState GameState, Name EventID, Object CallbackObject) { local UIResistanceReport Screen; local XComLWTuple Tuple; local bool ShouldShow; Screen = UIResistanceReport(EventSource); Tuple = XComLWTuple(EventData); ShouldShow = Tuple.Data[0].b; // Your code here Tuple.Data[0].b = ShouldShow; return ELR_NoInterrupt; } Source code references UIResistanceReport.uc:57-67","title":"UIResistanceReport_ShowCouncil"},{"location":"strategy/UIResistanceReport_ShowCouncil/#uiresistancereport_showcouncil","text":"Tracking Issue: #663 Tags: ui , events Allows overriding whether to show the council guy and his remarks in the background at the end of month.","title":"UIResistanceReport_ShowCouncil"},{"location":"strategy/UIResistanceReport_ShowCouncil/#uiresistancereport_showcouncil-event","text":"Param Value EventID UIResistanceReport_ShowCouncil EventData XComLWTuple EventSource UIResistanceReport NewGameState none","title":"UIResistanceReport_ShowCouncil event"},{"location":"strategy/UIResistanceReport_ShowCouncil/#tuple-contents","text":"Index Name Type Direction 0 ShouldShow bool inout","title":"Tuple contents"},{"location":"strategy/UIResistanceReport_ShowCouncil/#listener-template","text":"static function EventListenerReturn OnUIResistanceReport_ShowCouncil(Object EventData, Object EventSource, XComGameState GameState, Name EventID, Object CallbackObject) { local UIResistanceReport Screen; local XComLWTuple Tuple; local bool ShouldShow; Screen = UIResistanceReport(EventSource); Tuple = XComLWTuple(EventData); ShouldShow = Tuple.Data[0].b; // Your code here Tuple.Data[0].b = ShouldShow; return ELR_NoInterrupt; }","title":"Listener template"},{"location":"strategy/UIResistanceReport_ShowCouncil/#source-code-references","text":"UIResistanceReport.uc:57-67","title":"Source code references"},{"location":"strategy/UIScanButtonOnMouseEvent/","text":"UIScanButtonOnMouseEvent Tracking Issue: #483 Tags: ui UIScanButton now triggers its OnMouseEventDelegate if set. Do not call ProcessMouseEvents , do not pass go, do not collect $200, just set the delegate directly. Source code references UIScanButton.uc:289-292","title":"UIScanButtonOnMouseEvent"},{"location":"strategy/UIScanButtonOnMouseEvent/#uiscanbuttononmouseevent","text":"Tracking Issue: #483 Tags: ui UIScanButton now triggers its OnMouseEventDelegate if set. Do not call ProcessMouseEvents , do not pass go, do not collect $200, just set the delegate directly.","title":"UIScanButtonOnMouseEvent"},{"location":"strategy/UIScanButtonOnMouseEvent/#source-code-references","text":"UIScanButton.uc:289-292","title":"Source code references"},{"location":"strategy/UIStrategyPolicy_MiscEvents/","text":"UIStrategyPolicy_MiscEvents Tracking Issue: #986 Tags: ui , events UIStrategyPolicy is the screen that allows players to allocate resistance orders at end of \"month\". The Community Highlander adds the following events to that screen so mods have more options for modifying it without overriding it entirely. See the tracking issue for background on why these events were added, and hence a potential use for them. Note You'll need to look at the code for UIStrategyPolicy in order to understand when these events are fired, and hence which ones you'll need for your own customisations. UIStrategyPolicy_PreRefreshAllDecks event Param Value EventID UIStrategyPolicy_PreRefreshAllDecks EventData none EventSource UIStrategyPolicy NewGameState none Listener template static function EventListenerReturn OnUIStrategyPolicy_PreRefreshAllDecks(Object EventData, Object EventSource, XComGameState GameState, Name EventID, Object CallbackObject) { local UIStrategyPolicy StrategyPolicy; StrategyPolicy = UIStrategyPolicy(EventSource); // Your code here return ELR_NoInterrupt; } UIStrategyPolicy_PostRealizeColumn event Param Value EventID UIStrategyPolicy_PostRealizeColumn EventData UIList EventSource UIStrategyPolicy NewGameState none Listener template static function EventListenerReturn OnUIStrategyPolicy_PostRealizeColumn(Object EventData, Object EventSource, XComGameState GameState, Name EventID, Object CallbackObject) { local UIStrategyPolicy StrategyPolicy; local UIList Column; StrategyPolicy = UIStrategyPolicy(EventSource); Column = UIList(EventData); // Your code here return ELR_NoInterrupt; } UIStrategyPolicy_PreSelect event Param Value EventID UIStrategyPolicy_PreSelect EventData UIStrategyPolicy_Card EventSource UIStrategyPolicy NewGameState none Listener template static function EventListenerReturn OnUIStrategyPolicy_PreSelect(Object EventData, Object EventSource, XComGameState GameState, Name EventID, Object CallbackObject) { local UIStrategyPolicy StrategyPolicy; local UIStrategyPolicy_Card TargetCard; StrategyPolicy = UIStrategyPolicy(EventSource); TargetCard = UIStrategyPolicy_Card(EventData); // Your code here return ELR_NoInterrupt; } UIStrategyPolicy_PreClearSelection event Param Value EventID UIStrategyPolicy_PreClearSelection EventData none EventSource UIStrategyPolicy NewGameState none Listener template static function EventListenerReturn OnUIStrategyPolicy_PreClearSelection(Object EventData, Object EventSource, XComGameState GameState, Name EventID, Object CallbackObject) { local UIStrategyPolicy StrategyPolicy; StrategyPolicy = UIStrategyPolicy(EventSource); // Your code here return ELR_NoInterrupt; } UIStrategyPolicy_DraggingStarted event Param Value EventID UIStrategyPolicy_DraggingStarted EventData none EventSource UIStrategyPolicy NewGameState none Listener template static function EventListenerReturn OnUIStrategyPolicy_DraggingStarted(Object EventData, Object EventSource, XComGameState GameState, Name EventID, Object CallbackObject) { local UIStrategyPolicy StrategyPolicy; StrategyPolicy = UIStrategyPolicy(EventSource); // Your code here return ELR_NoInterrupt; } UIStrategyPolicy_DraggingEnded event Param Value EventID UIStrategyPolicy_DraggingEnded EventData none EventSource UIStrategyPolicy NewGameState none Listener template static function EventListenerReturn OnUIStrategyPolicy_DraggingEnded(Object EventData, Object EventSource, XComGameState GameState, Name EventID, Object CallbackObject) { local UIStrategyPolicy StrategyPolicy; StrategyPolicy = UIStrategyPolicy(EventSource); // Your code here return ELR_NoInterrupt; } Source code references UIStrategyPolicy.uc:13-66 UIStrategyPolicy.uc:423 UIStrategyPolicy.uc:914 UIStrategyPolicy.uc:1290 UIStrategyPolicy.uc:1299 UIStrategyPolicy.uc:1597 UIStrategyPolicy.uc:1611","title":"UIStrategyPolicy_MiscEvents"},{"location":"strategy/UIStrategyPolicy_MiscEvents/#uistrategypolicy_miscevents","text":"Tracking Issue: #986 Tags: ui , events UIStrategyPolicy is the screen that allows players to allocate resistance orders at end of \"month\". The Community Highlander adds the following events to that screen so mods have more options for modifying it without overriding it entirely. See the tracking issue for background on why these events were added, and hence a potential use for them. Note You'll need to look at the code for UIStrategyPolicy in order to understand when these events are fired, and hence which ones you'll need for your own customisations.","title":"UIStrategyPolicy_MiscEvents"},{"location":"strategy/UIStrategyPolicy_MiscEvents/#uistrategypolicy_prerefreshalldecks-event","text":"Param Value EventID UIStrategyPolicy_PreRefreshAllDecks EventData none EventSource UIStrategyPolicy NewGameState none","title":"UIStrategyPolicy_PreRefreshAllDecks event"},{"location":"strategy/UIStrategyPolicy_MiscEvents/#listener-template","text":"static function EventListenerReturn OnUIStrategyPolicy_PreRefreshAllDecks(Object EventData, Object EventSource, XComGameState GameState, Name EventID, Object CallbackObject) { local UIStrategyPolicy StrategyPolicy; StrategyPolicy = UIStrategyPolicy(EventSource); // Your code here return ELR_NoInterrupt; }","title":"Listener template"},{"location":"strategy/UIStrategyPolicy_MiscEvents/#uistrategypolicy_postrealizecolumn-event","text":"Param Value EventID UIStrategyPolicy_PostRealizeColumn EventData UIList EventSource UIStrategyPolicy NewGameState none","title":"UIStrategyPolicy_PostRealizeColumn event"},{"location":"strategy/UIStrategyPolicy_MiscEvents/#listener-template_1","text":"static function EventListenerReturn OnUIStrategyPolicy_PostRealizeColumn(Object EventData, Object EventSource, XComGameState GameState, Name EventID, Object CallbackObject) { local UIStrategyPolicy StrategyPolicy; local UIList Column; StrategyPolicy = UIStrategyPolicy(EventSource); Column = UIList(EventData); // Your code here return ELR_NoInterrupt; }","title":"Listener template"},{"location":"strategy/UIStrategyPolicy_MiscEvents/#uistrategypolicy_preselect-event","text":"Param Value EventID UIStrategyPolicy_PreSelect EventData UIStrategyPolicy_Card EventSource UIStrategyPolicy NewGameState none","title":"UIStrategyPolicy_PreSelect event"},{"location":"strategy/UIStrategyPolicy_MiscEvents/#listener-template_2","text":"static function EventListenerReturn OnUIStrategyPolicy_PreSelect(Object EventData, Object EventSource, XComGameState GameState, Name EventID, Object CallbackObject) { local UIStrategyPolicy StrategyPolicy; local UIStrategyPolicy_Card TargetCard; StrategyPolicy = UIStrategyPolicy(EventSource); TargetCard = UIStrategyPolicy_Card(EventData); // Your code here return ELR_NoInterrupt; }","title":"Listener template"},{"location":"strategy/UIStrategyPolicy_MiscEvents/#uistrategypolicy_preclearselection-event","text":"Param Value EventID UIStrategyPolicy_PreClearSelection EventData none EventSource UIStrategyPolicy NewGameState none","title":"UIStrategyPolicy_PreClearSelection event"},{"location":"strategy/UIStrategyPolicy_MiscEvents/#listener-template_3","text":"static function EventListenerReturn OnUIStrategyPolicy_PreClearSelection(Object EventData, Object EventSource, XComGameState GameState, Name EventID, Object CallbackObject) { local UIStrategyPolicy StrategyPolicy; StrategyPolicy = UIStrategyPolicy(EventSource); // Your code here return ELR_NoInterrupt; }","title":"Listener template"},{"location":"strategy/UIStrategyPolicy_MiscEvents/#uistrategypolicy_draggingstarted-event","text":"Param Value EventID UIStrategyPolicy_DraggingStarted EventData none EventSource UIStrategyPolicy NewGameState none","title":"UIStrategyPolicy_DraggingStarted event"},{"location":"strategy/UIStrategyPolicy_MiscEvents/#listener-template_4","text":"static function EventListenerReturn OnUIStrategyPolicy_DraggingStarted(Object EventData, Object EventSource, XComGameState GameState, Name EventID, Object CallbackObject) { local UIStrategyPolicy StrategyPolicy; StrategyPolicy = UIStrategyPolicy(EventSource); // Your code here return ELR_NoInterrupt; }","title":"Listener template"},{"location":"strategy/UIStrategyPolicy_MiscEvents/#uistrategypolicy_draggingended-event","text":"Param Value EventID UIStrategyPolicy_DraggingEnded EventData none EventSource UIStrategyPolicy NewGameState none","title":"UIStrategyPolicy_DraggingEnded event"},{"location":"strategy/UIStrategyPolicy_MiscEvents/#listener-template_5","text":"static function EventListenerReturn OnUIStrategyPolicy_DraggingEnded(Object EventData, Object EventSource, XComGameState GameState, Name EventID, Object CallbackObject) { local UIStrategyPolicy StrategyPolicy; StrategyPolicy = UIStrategyPolicy(EventSource); // Your code here return ELR_NoInterrupt; }","title":"Listener template"},{"location":"strategy/UIStrategyPolicy_MiscEvents/#source-code-references","text":"UIStrategyPolicy.uc:13-66 UIStrategyPolicy.uc:423 UIStrategyPolicy.uc:914 UIStrategyPolicy.uc:1290 UIStrategyPolicy.uc:1299 UIStrategyPolicy.uc:1597 UIStrategyPolicy.uc:1611","title":"Source code references"},{"location":"strategy/UIStrategyPolicy_ScreenInit/","text":"UIStrategyPolicy_ScreenInit Tracking Issue: #440 Tags: ui Triggers the event UIStrategyPolicy_ScreenInit immediately after opening the UIStrategyPolicy screen, before it has fully initialized. Can be used to make modifications to camera transition behavior that would be too late in a ScreenListener. ID: UIStrategyPolicy_ScreenInit, Source: UIStrategyPolicy Source code references UIStrategyPolicy.uc:141-149","title":"UIStrategyPolicy_ScreenInit"},{"location":"strategy/UIStrategyPolicy_ScreenInit/#uistrategypolicy_screeninit","text":"Tracking Issue: #440 Tags: ui Triggers the event UIStrategyPolicy_ScreenInit immediately after opening the UIStrategyPolicy screen, before it has fully initialized. Can be used to make modifications to camera transition behavior that would be too late in a ScreenListener. ID: UIStrategyPolicy_ScreenInit, Source: UIStrategyPolicy","title":"UIStrategyPolicy_ScreenInit"},{"location":"strategy/UIStrategyPolicy_ScreenInit/#source-code-references","text":"UIStrategyPolicy.uc:141-149","title":"Source code references"},{"location":"strategy/UIStrategyPolicy_ShowCovertActionsOnClose/","text":"UIStrategyPolicy_ShowCovertActionsOnClose Tracking Issue: #365 Tags: ui , events Allows overriding whether to show the UICovertActions screen after closing the UIStrategyPolicy screen. Default: Show if UIStrategyPolicy was created as part of the end-of-month report and no covert actions are in progress. UIStrategyPolicy_ShowCovertActionsOnClose event Param Value EventID UIStrategyPolicy_ShowCovertActionsOnClose EventData XComLWTuple EventSource UIStrategyPolicy NewGameState none Tuple contents Index Name Type Direction 0 ShouldShow bool inout Listener template static function EventListenerReturn OnUIStrategyPolicy_ShowCovertActionsOnClose(Object EventData, Object EventSource, XComGameState GameState, Name EventID, Object CallbackObject) { local XComLWTuple Tuple; local bool ShouldShow; Tuple = XComLWTuple(EventData); ShouldShow = Tuple.Data[0].b; // Your code here Tuple.Data[0].b = ShouldShow; return ELR_NoInterrupt; } Source code references UIStrategyPolicy.uc:1932-1944","title":"UIStrategyPolicy_ShowCovertActionsOnClose"},{"location":"strategy/UIStrategyPolicy_ShowCovertActionsOnClose/#uistrategypolicy_showcovertactionsonclose","text":"Tracking Issue: #365 Tags: ui , events Allows overriding whether to show the UICovertActions screen after closing the UIStrategyPolicy screen. Default: Show if UIStrategyPolicy was created as part of the end-of-month report and no covert actions are in progress.","title":"UIStrategyPolicy_ShowCovertActionsOnClose"},{"location":"strategy/UIStrategyPolicy_ShowCovertActionsOnClose/#uistrategypolicy_showcovertactionsonclose-event","text":"Param Value EventID UIStrategyPolicy_ShowCovertActionsOnClose EventData XComLWTuple EventSource UIStrategyPolicy NewGameState none","title":"UIStrategyPolicy_ShowCovertActionsOnClose event"},{"location":"strategy/UIStrategyPolicy_ShowCovertActionsOnClose/#tuple-contents","text":"Index Name Type Direction 0 ShouldShow bool inout","title":"Tuple contents"},{"location":"strategy/UIStrategyPolicy_ShowCovertActionsOnClose/#listener-template","text":"static function EventListenerReturn OnUIStrategyPolicy_ShowCovertActionsOnClose(Object EventData, Object EventSource, XComGameState GameState, Name EventID, Object CallbackObject) { local XComLWTuple Tuple; local bool ShouldShow; Tuple = XComLWTuple(EventData); ShouldShow = Tuple.Data[0].b; // Your code here Tuple.Data[0].b = ShouldShow; return ELR_NoInterrupt; }","title":"Listener template"},{"location":"strategy/UIStrategyPolicy_ShowCovertActionsOnClose/#source-code-references","text":"UIStrategyPolicy.uc:1932-1944","title":"Source code references"},{"location":"strategy/UpdateNavHelp/","text":"UpdateNavHelp Tracking Issue: #420 Tags: events This event allows mods to modify the nav help menu at the bottom of the squad select screen - the menu that normally includes buttons like \"MAKE WEAPONS AVAILABLE\". Note that robojumper's Squad Select mod also triggers this event with the same parameters, so it should be automatically compatible. UISquadSelect_NavHelpUpdate event Param Value EventID UISquadSelect_NavHelpUpdate EventData UINavigationHelp EventSource UISquadSelect NewGameState none Listener template static function EventListenerReturn OnUISquadSelect_NavHelpUpdate(Object EventData, Object EventSource, XComGameState GameState, Name EventID, Object CallbackObject) { local UISquadSelect SquadSelect; local UINavigationHelp NavHelp; SquadSelect = UISquadSelect(EventSource); NavHelp = UINavigationHelp(EventData); // Your code here return ELR_NoInterrupt; } Source code references UISquadSelect.uc:913-923","title":"UpdateNavHelp"},{"location":"strategy/UpdateNavHelp/#updatenavhelp","text":"Tracking Issue: #420 Tags: events This event allows mods to modify the nav help menu at the bottom of the squad select screen - the menu that normally includes buttons like \"MAKE WEAPONS AVAILABLE\". Note that robojumper's Squad Select mod also triggers this event with the same parameters, so it should be automatically compatible.","title":"UpdateNavHelp"},{"location":"strategy/UpdateNavHelp/#uisquadselect_navhelpupdate-event","text":"Param Value EventID UISquadSelect_NavHelpUpdate EventData UINavigationHelp EventSource UISquadSelect NewGameState none","title":"UISquadSelect_NavHelpUpdate event"},{"location":"strategy/UpdateNavHelp/#listener-template","text":"static function EventListenerReturn OnUISquadSelect_NavHelpUpdate(Object EventData, Object EventSource, XComGameState GameState, Name EventID, Object CallbackObject) { local UISquadSelect SquadSelect; local UINavigationHelp NavHelp; SquadSelect = UISquadSelect(EventSource); NavHelp = UINavigationHelp(EventData); // Your code here return ELR_NoInterrupt; }","title":"Listener template"},{"location":"strategy/UpdateNavHelp/#source-code-references","text":"UISquadSelect.uc:913-923","title":"Source code references"},{"location":"strategy/ValidateGTSClassTraining/","text":"ValidateGTSClassTraining Tracking Issue: #814 Tags: events Triggers an 'ValidateGTSClassTraining' event that allows listeners to control whether the given class can be trained in the GTS. The event is fired once for each class whenever the GTS creates a list of classes to train. The boolean value is based on vanilla checks (NumInForcedDeck and bMultiplayerOnly), so vanilla behavior is maintained when the value isn't changed by the listener(s), and listeners can base their logic on the vanilla checks or override the result. ValidateGTSClassTraining event Param Value EventID ValidateGTSClassTraining EventData XComLWTuple EventSource UIChooseClass NewGameState none Tuple contents Index Name Type Direction 0 CanTrainClass bool out 1 SoldierClassTemplate X2SoldierClassTemplate in Listener template static function EventListenerReturn OnValidateGTSClassTraining(Object EventData, Object EventSource, XComGameState GameState, Name EventID, Object CallbackObject) { local UIChooseClass ChooseClassScreen; local XComLWTuple Tuple; local bool CanTrainClass; local X2SoldierClassTemplate SoldierClassTemplate; ChooseClassScreen = UIChooseClass(EventSource); Tuple = XComLWTuple(EventData); SoldierClassTemplate = X2SoldierClassTemplate(Tuple.Data[1].o); // Your code here Tuple.Data[0].b = CanTrainClass; return ELR_NoInterrupt; } Source code references UIChooseClass.uc:128-146","title":"ValidateGTSClassTraining"},{"location":"strategy/ValidateGTSClassTraining/#validategtsclasstraining","text":"Tracking Issue: #814 Tags: events Triggers an 'ValidateGTSClassTraining' event that allows listeners to control whether the given class can be trained in the GTS. The event is fired once for each class whenever the GTS creates a list of classes to train. The boolean value is based on vanilla checks (NumInForcedDeck and bMultiplayerOnly), so vanilla behavior is maintained when the value isn't changed by the listener(s), and listeners can base their logic on the vanilla checks or override the result.","title":"ValidateGTSClassTraining"},{"location":"strategy/ValidateGTSClassTraining/#validategtsclasstraining-event","text":"Param Value EventID ValidateGTSClassTraining EventData XComLWTuple EventSource UIChooseClass NewGameState none","title":"ValidateGTSClassTraining event"},{"location":"strategy/ValidateGTSClassTraining/#tuple-contents","text":"Index Name Type Direction 0 CanTrainClass bool out 1 SoldierClassTemplate X2SoldierClassTemplate in","title":"Tuple contents"},{"location":"strategy/ValidateGTSClassTraining/#listener-template","text":"static function EventListenerReturn OnValidateGTSClassTraining(Object EventData, Object EventSource, XComGameState GameState, Name EventID, Object CallbackObject) { local UIChooseClass ChooseClassScreen; local XComLWTuple Tuple; local bool CanTrainClass; local X2SoldierClassTemplate SoldierClassTemplate; ChooseClassScreen = UIChooseClass(EventSource); Tuple = XComLWTuple(EventData); SoldierClassTemplate = X2SoldierClassTemplate(Tuple.Data[1].o); // Your code here Tuple.Data[0].b = CanTrainClass; return ELR_NoInterrupt; }","title":"Listener template"},{"location":"strategy/ValidateGTSClassTraining/#source-code-references","text":"UIChooseClass.uc:128-146","title":"Source code references"},{"location":"strategy/WillRecoveryTimeModifier/","text":"WillRecoveryTimeModifier Tracking Issue: #650 Tags: events Allows mods to apply a multiplier to the Will recovery project time, where a value of 1.0 makes no change, 2.0 doubles the duration, etc. Listeners can get the recovering unit from the Will project's ProjectFocus property. WillRecoveryTimeModifier event Param Value EventID WillRecoveryTimeModifier EventData XComLWTuple EventSource XComGameState_HeadquartersProjectRecoverWill NewGameState maybe Tuple contents Index Name Type Direction 0 TimeMultiplier float inout 1 bAssumeActive bool in Listener template static function EventListenerReturn OnWillRecoveryTimeModifier(Object EventData, Object EventSource, XComGameState GameState, Name EventID, Object CallbackObject) { local XComGameState_HeadquartersProjectRecoverWill ProjectState; local XComLWTuple Tuple; local float TimeMultiplier; local bool bAssumeActive; ProjectState = XComGameState_HeadquartersProjectRecoverWill(EventSource); Tuple = XComLWTuple(EventData); TimeMultiplier = Tuple.Data[0].f; bAssumeActive = Tuple.Data[1].b; // Your code here Tuple.Data[0].f = TimeMultiplier; return ELR_NoInterrupt; } The NewGameState and bAssumeActive will be whatever caller to CalculateWorkPerHour() passes. Note that both arguments are optional. If you want to modify the TimeMultiplier , you must subscribe with ELD_Immediate deferral Source code references XComGameState_HeadquartersProjectRecoverWill.uc:93-111","title":"WillRecoveryTimeModifier"},{"location":"strategy/WillRecoveryTimeModifier/#willrecoverytimemodifier","text":"Tracking Issue: #650 Tags: events Allows mods to apply a multiplier to the Will recovery project time, where a value of 1.0 makes no change, 2.0 doubles the duration, etc. Listeners can get the recovering unit from the Will project's ProjectFocus property.","title":"WillRecoveryTimeModifier"},{"location":"strategy/WillRecoveryTimeModifier/#willrecoverytimemodifier-event","text":"Param Value EventID WillRecoveryTimeModifier EventData XComLWTuple EventSource XComGameState_HeadquartersProjectRecoverWill NewGameState maybe","title":"WillRecoveryTimeModifier event"},{"location":"strategy/WillRecoveryTimeModifier/#tuple-contents","text":"Index Name Type Direction 0 TimeMultiplier float inout 1 bAssumeActive bool in","title":"Tuple contents"},{"location":"strategy/WillRecoveryTimeModifier/#listener-template","text":"static function EventListenerReturn OnWillRecoveryTimeModifier(Object EventData, Object EventSource, XComGameState GameState, Name EventID, Object CallbackObject) { local XComGameState_HeadquartersProjectRecoverWill ProjectState; local XComLWTuple Tuple; local float TimeMultiplier; local bool bAssumeActive; ProjectState = XComGameState_HeadquartersProjectRecoverWill(EventSource); Tuple = XComLWTuple(EventData); TimeMultiplier = Tuple.Data[0].f; bAssumeActive = Tuple.Data[1].b; // Your code here Tuple.Data[0].f = TimeMultiplier; return ELR_NoInterrupt; } The NewGameState and bAssumeActive will be whatever caller to CalculateWorkPerHour() passes. Note that both arguments are optional. If you want to modify the TimeMultiplier , you must subscribe with ELD_Immediate deferral","title":"Listener template"},{"location":"strategy/WillRecoveryTimeModifier/#source-code-references","text":"XComGameState_HeadquartersProjectRecoverWill.uc:93-111","title":"Source code references"},{"location":"strategy/WorldRegionGetMeshScale/","text":"WorldRegionGetMeshScale Tracking Issue: #864 Tags: events This is an event that mods which add new static meshes to the overworld can hook into to ensure that those static meshes scale properly. The EventData is a single-value XComLWTuple that contains the vector that will be applied to the static mesh. The EventSource is the WorldRegion instance. Source code references XComGameState_WorldRegion.uc:1053-1059","title":"WorldRegionGetMeshScale"},{"location":"strategy/WorldRegionGetMeshScale/#worldregiongetmeshscale","text":"Tracking Issue: #864 Tags: events This is an event that mods which add new static meshes to the overworld can hook into to ensure that those static meshes scale properly. The EventData is a single-value XComLWTuple that contains the vector that will be applied to the static mesh. The EventSource is the WorldRegion instance.","title":"WorldRegionGetMeshScale"},{"location":"strategy/WorldRegionGetMeshScale/#source-code-references","text":"XComGameState_WorldRegion.uc:1053-1059","title":"Source code references"},{"location":"strategy/WorldRegionGetStaticMesh/","text":"WorldRegionGetStaticMesh Tracking Issue: #864 Tags: events This is an event that mods which add new static meshes to the overworld can hook into to ensure that those static meshes actually display. The EventData is a single-value XComLWTuple that contains the StaticMesh that will be displayed. The EventSource is the WorldRegion instance. Source code references XComGameState_WorldRegion.uc:1017-1022","title":"WorldRegionGetStaticMesh"},{"location":"strategy/WorldRegionGetStaticMesh/#worldregiongetstaticmesh","text":"Tracking Issue: #864 Tags: events This is an event that mods which add new static meshes to the overworld can hook into to ensure that those static meshes actually display. The EventData is a single-value XComLWTuple that contains the StaticMesh that will be displayed. The EventSource is the WorldRegion instance.","title":"WorldRegionGetStaticMesh"},{"location":"strategy/WorldRegionGetStaticMesh/#source-code-references","text":"XComGameState_WorldRegion.uc:1017-1022","title":"Source code references"},{"location":"tactical/AllowInteractHack/","text":"AllowInteractHack Tracking Issue: #564 Tags: events The AllowInteractHack event allows mods to forbid an interactive object from being hackable by a unit. AllowInteractHack event Param Value EventID AllowInteractHack EventData XComLWTuple EventSource XComGameState_InteractiveObject NewGameState none Tuple contents Index Name Type Direction 0 bAllowInteractHack bool inout 1 HackingUnit XComGameState_Unit in Listener template static function EventListenerReturn OnAllowInteractHack(Object EventData, Object EventSource, XComGameState GameState, Name EventID, Object CallbackObject) { local XComGameState_InteractiveObject InteractiveObject; local XComLWTuple Tuple; local bool bAllowInteractHack; local XComGameState_Unit HackingUnit; InteractiveObject = XComGameState_InteractiveObject(EventSource); Tuple = XComLWTuple(EventData); bAllowInteractHack = Tuple.Data[0].b; HackingUnit = XComGameState_Unit(Tuple.Data[1].o); // Your code here Tuple.Data[0].b = bAllowInteractHack; return ELR_NoInterrupt; } Source code references XComGameState_InteractiveObject.uc:525-533","title":"AllowInteractHack"},{"location":"tactical/AllowInteractHack/#allowinteracthack","text":"Tracking Issue: #564 Tags: events The AllowInteractHack event allows mods to forbid an interactive object from being hackable by a unit.","title":"AllowInteractHack"},{"location":"tactical/AllowInteractHack/#allowinteracthack-event","text":"Param Value EventID AllowInteractHack EventData XComLWTuple EventSource XComGameState_InteractiveObject NewGameState none","title":"AllowInteractHack event"},{"location":"tactical/AllowInteractHack/#tuple-contents","text":"Index Name Type Direction 0 bAllowInteractHack bool inout 1 HackingUnit XComGameState_Unit in","title":"Tuple contents"},{"location":"tactical/AllowInteractHack/#listener-template","text":"static function EventListenerReturn OnAllowInteractHack(Object EventData, Object EventSource, XComGameState GameState, Name EventID, Object CallbackObject) { local XComGameState_InteractiveObject InteractiveObject; local XComLWTuple Tuple; local bool bAllowInteractHack; local XComGameState_Unit HackingUnit; InteractiveObject = XComGameState_InteractiveObject(EventSource); Tuple = XComLWTuple(EventData); bAllowInteractHack = Tuple.Data[0].b; HackingUnit = XComGameState_Unit(Tuple.Data[1].o); // Your code here Tuple.Data[0].b = bAllowInteractHack; return ELR_NoInterrupt; }","title":"Listener template"},{"location":"tactical/AllowInteractHack/#source-code-references","text":"XComGameState_InteractiveObject.uc:525-533","title":"Source code references"},{"location":"tactical/BleedingDamageBypassesShields/","text":"BleedingDamageBypassesShields Tracking Issue: #629 In base game, shields (eStat_ShieldHP) absorb damage from typical damage over time bleeding effects, such as those applied by ADVENT Stiletto Rounds. Mods can override this behavior by setting the BLEEDING_IGNORES_SHIELDS flag in XComGameCore.ini : [XComGame.X2StatusEffects] BLEEDING_IGNORES_SHIELDS=true ; Make bleeding DOT ignore shields Note that this will apply only to bleeding effects created using the X2StatusEffect::CreateBleedingStatusEffect() helper method, which should cover all instance of bleeding DOT effects in the base game, but mods can potentially create their own bleeding effects, bypassing this helper method. Refer to this feature to apply similar change to burning, poisoned and acid damage over time. Source code references X2StatusEffects.uc:2317-2333","title":"BleedingDamageBypassesShields"},{"location":"tactical/BleedingDamageBypassesShields/#bleedingdamagebypassesshields","text":"Tracking Issue: #629 In base game, shields (eStat_ShieldHP) absorb damage from typical damage over time bleeding effects, such as those applied by ADVENT Stiletto Rounds. Mods can override this behavior by setting the BLEEDING_IGNORES_SHIELDS flag in XComGameCore.ini : [XComGame.X2StatusEffects] BLEEDING_IGNORES_SHIELDS=true ; Make bleeding DOT ignore shields Note that this will apply only to bleeding effects created using the X2StatusEffect::CreateBleedingStatusEffect() helper method, which should cover all instance of bleeding DOT effects in the base game, but mods can potentially create their own bleeding effects, bypassing this helper method. Refer to this feature to apply similar change to burning, poisoned and acid damage over time.","title":"BleedingDamageBypassesShields"},{"location":"tactical/BleedingDamageBypassesShields/#source-code-references","text":"X2StatusEffects.uc:2317-2333","title":"Source code references"},{"location":"tactical/BurningAndPoisonedDamageBypassesShields/","text":"BurningAndPoisonedDamageBypassesShields Tracking Issue: #89 In base game, shields (eStat_ShieldHP) absorb damage from typical damage over time effects, such as burning or poisoned. Mods can override this behavior by setting the following flags in XComGameCore.ini : [XComGame.X2Effect_Burning] BURNED_IGNORES_SHIELDS=true ; Make burn and acid DOT ignore shields [XComGame.X2StatusEffects] POISONED_IGNORES_SHIELDS=true ; Make poison DOT ignore shields Note that BURNED_IGNORES_SHIELDS will apply to all instances of X2Effect_Burning that use its SetBurnDamage() helper method to set up the burn damage effect. POISONED_IGNORES_SHIELDS will apply to all instances of posioned effect created using the X2StatusEffect::CreatePoisonedStatusEffect() helper method. This should cover all instance of these effects in the base game, but mods can potentially disregard these helper methods. Refer to this feature to apply similar change to bleeding damage over time. Source code references X2StatusEffects.uc:1142-1163","title":"BurningAndPoisonedDamageBypassesShields"},{"location":"tactical/BurningAndPoisonedDamageBypassesShields/#burningandpoisoneddamagebypassesshields","text":"Tracking Issue: #89 In base game, shields (eStat_ShieldHP) absorb damage from typical damage over time effects, such as burning or poisoned. Mods can override this behavior by setting the following flags in XComGameCore.ini : [XComGame.X2Effect_Burning] BURNED_IGNORES_SHIELDS=true ; Make burn and acid DOT ignore shields [XComGame.X2StatusEffects] POISONED_IGNORES_SHIELDS=true ; Make poison DOT ignore shields Note that BURNED_IGNORES_SHIELDS will apply to all instances of X2Effect_Burning that use its SetBurnDamage() helper method to set up the burn damage effect. POISONED_IGNORES_SHIELDS will apply to all instances of posioned effect created using the X2StatusEffect::CreatePoisonedStatusEffect() helper method. This should cover all instance of these effects in the base game, but mods can potentially disregard these helper methods. Refer to this feature to apply similar change to bleeding damage over time.","title":"BurningAndPoisonedDamageBypassesShields"},{"location":"tactical/BurningAndPoisonedDamageBypassesShields/#source-code-references","text":"X2StatusEffects.uc:1142-1163","title":"Source code references"},{"location":"tactical/CustomTargetStyles/","text":"CustomTargetStyles Tracking Issue: #763 Tags: compatibility Target styles are responsible for the initial target selection for tactical abilities. The AbilityTargetStyle builds an initial target list (or none, for cursor-targeted abilities). The AbilityMultiTargetStyle adds other targets to every target built by the AbilityTargetStyle or the cursor target. Even though the results are cached, this code is extremely performance-critical: Every time a game state is added to the History, all cached results are invalidated. Whenever the AI evaluates a unit, the player selects a unit, or a reaction ability checks for valid targets, this code is run for every ability on the unit! As a result, all of this code is native: The target styles themselves are native, and their functions are called by the native GatherAbilityTargets function. This native code simply cannot see UnrealScript implementations of target styles, so custom target styles are essentially ignored. We can override GatherAbilityTargets in a subclass with the slower UnrealScript implementation that Firaxis helpfully provided in a comment. Doing this with all abilities would seriously degrade performance, so we use CH_ClassIsNative to check if any target styles are non-native, and if so use a custom XComGameState_Ability subclass when instanciating the game state object for an ability template. TL;DR Custom, scripted ability target/multi-target styles magically start working. Compatibility In order to selectively override the XComGameState_Ability class, we modify X2AbilityTemplate:CreateInstanceFromTemplate . If your mod overrides CreateInstanceFromTemplate in a subclass of X2AbilityTemplate , the Highlander will not be able to apply this enhancement to that ability. On the other hand, if you override CreateInstanceFromTemplate precisely to instantiate your own ability state object with GatherAbilityTargets de-nativized for a custom target style, your abilities will keep working the same way. Source code references XComGameState_Ability_CH.uc:1-30 X2AbilityTemplate.uc:262 XComGameState_Ability.uc:284","title":"CustomTargetStyles"},{"location":"tactical/CustomTargetStyles/#customtargetstyles","text":"Tracking Issue: #763 Tags: compatibility Target styles are responsible for the initial target selection for tactical abilities. The AbilityTargetStyle builds an initial target list (or none, for cursor-targeted abilities). The AbilityMultiTargetStyle adds other targets to every target built by the AbilityTargetStyle or the cursor target. Even though the results are cached, this code is extremely performance-critical: Every time a game state is added to the History, all cached results are invalidated. Whenever the AI evaluates a unit, the player selects a unit, or a reaction ability checks for valid targets, this code is run for every ability on the unit! As a result, all of this code is native: The target styles themselves are native, and their functions are called by the native GatherAbilityTargets function. This native code simply cannot see UnrealScript implementations of target styles, so custom target styles are essentially ignored. We can override GatherAbilityTargets in a subclass with the slower UnrealScript implementation that Firaxis helpfully provided in a comment. Doing this with all abilities would seriously degrade performance, so we use CH_ClassIsNative to check if any target styles are non-native, and if so use a custom XComGameState_Ability subclass when instanciating the game state object for an ability template. TL;DR Custom, scripted ability target/multi-target styles magically start working.","title":"CustomTargetStyles"},{"location":"tactical/CustomTargetStyles/#compatibility","text":"In order to selectively override the XComGameState_Ability class, we modify X2AbilityTemplate:CreateInstanceFromTemplate . If your mod overrides CreateInstanceFromTemplate in a subclass of X2AbilityTemplate , the Highlander will not be able to apply this enhancement to that ability. On the other hand, if you override CreateInstanceFromTemplate precisely to instantiate your own ability state object with GatherAbilityTargets de-nativized for a custom target style, your abilities will keep working the same way.","title":"Compatibility"},{"location":"tactical/CustomTargetStyles/#source-code-references","text":"XComGameState_Ability_CH.uc:1-30 X2AbilityTemplate.uc:262 XComGameState_Ability.uc:284","title":"Source code references"},{"location":"tactical/DamageCalc_ArmorBeforeShield/","text":"DamageCalc_ArmorBeforeShield Tracking Issue: #743 By default, shields are damaged before any damage is mitigated by armor. This is fine in vanilla when shields are rare, but becomes an issue in modded campaigns where 'shields' are turned into 'ablative' hit points that provide a buffer before units become wounded and suffer red fog. Increasing ablative is often a non-optimal choice because it can make the the soldier's armor pips become redundant. This change adds an optional config variable (XComGameCore.ini) that other mods or the player can enable. When enabled, it changes the TakeDamage event inside XComGameState_Unit to handle armor mitigation and apply any shredding to the armor before moving on to shields. Shield-bypassing damage such as Psi or EMP damage behaves as normal, ignoring armor and shields to hit health. [XComGame.X2Effect_ApplyWeaponDamage] ; Issue 743 ; Set to false/commented out if you want damage to hit shields/ablative, then armor, then health (vanilla behaviour) ; Set to true/uncomment it if you want damage to hit armor, then shield/ablative, then health ;ARMOR_BEFORE_SHIELD=true Source code references XComGameState_Unit.uc:6319-6339","title":"DamageCalc_ArmorBeforeShield"},{"location":"tactical/DamageCalc_ArmorBeforeShield/#damagecalc_armorbeforeshield","text":"Tracking Issue: #743 By default, shields are damaged before any damage is mitigated by armor. This is fine in vanilla when shields are rare, but becomes an issue in modded campaigns where 'shields' are turned into 'ablative' hit points that provide a buffer before units become wounded and suffer red fog. Increasing ablative is often a non-optimal choice because it can make the the soldier's armor pips become redundant. This change adds an optional config variable (XComGameCore.ini) that other mods or the player can enable. When enabled, it changes the TakeDamage event inside XComGameState_Unit to handle armor mitigation and apply any shredding to the armor before moving on to shields. Shield-bypassing damage such as Psi or EMP damage behaves as normal, ignoring armor and shields to hit health. [XComGame.X2Effect_ApplyWeaponDamage] ; Issue 743 ; Set to false/commented out if you want damage to hit shields/ablative, then armor, then health (vanilla behaviour) ; Set to true/uncomment it if you want damage to hit armor, then shield/ablative, then health ;ARMOR_BEFORE_SHIELD=true","title":"DamageCalc_ArmorBeforeShield"},{"location":"tactical/DamageCalc_ArmorBeforeShield/#source-code-references","text":"XComGameState_Unit.uc:6319-6339","title":"Source code references"},{"location":"tactical/DisableExtraLOSCheckForPoison/","text":"DisableExtraLOSCheckForPoison Tracking Issue: #669 When true, this option fixes poison so that clouds of it apply to all tiles that are highlighted in targeting. Source code references CHHelpers.uc:221-223 XComGame.ini:41","title":"DisableExtraLOSCheckForPoison"},{"location":"tactical/DisableExtraLOSCheckForPoison/#disableextraloscheckforpoison","text":"Tracking Issue: #669 When true, this option fixes poison so that clouds of it apply to all tiles that are highlighted in targeting.","title":"DisableExtraLOSCheckForPoison"},{"location":"tactical/DisableExtraLOSCheckForPoison/#source-code-references","text":"CHHelpers.uc:221-223 XComGame.ini:41","title":"Source code references"},{"location":"tactical/DisableExtraLOSCheckForSmoke/","text":"DisableExtraLOSCheckForSmoke Tracking Issue: #669 When true, this option fixes smoke so that it applies to all tiles that are highlighted in targeting (as per the Reliable Smoke mod). Source code references CHHelpers.uc:216-218 XComGame.ini:38","title":"DisableExtraLOSCheckForSmoke"},{"location":"tactical/DisableExtraLOSCheckForSmoke/#disableextraloscheckforsmoke","text":"Tracking Issue: #669 When true, this option fixes smoke so that it applies to all tiles that are highlighted in targeting (as per the Reliable Smoke mod).","title":"DisableExtraLOSCheckForSmoke"},{"location":"tactical/DisableExtraLOSCheckForSmoke/#source-code-references","text":"CHHelpers.uc:216-218 XComGame.ini:38","title":"Source code references"},{"location":"tactical/DisplayCustomOverwatchActionPointOnUnitFlag/","text":"DisplayCustomOverwatchActionPointOnUnitFlag Tracking Issue: #724 Tags: compatibility The base XCOM 2 behavior is to show an Overwatch \"eye\" icon under the unit flag only if the soldier has at least one \"overwatch\" Reserve Action Point. The icon is not displayed for Pistol Overwatch. This change addresses that issue, and also allows mods that add weapons with custom Overwatch Action Point to specify that action point name in XComGame.ini: [XComGame.CHHelpers] +ValidReserveAPForUnitFlag = \"overwatch\" +ValidReserveAPForUnitFlag = \"pistoloverwatch\" Compatibility: If you override UIUnitFlag::RealizeOverwatch , your code may undo this change. Source code references UIUnitFlag.uc:1699-1712","title":"DisplayCustomOverwatchActionPointOnUnitFlag"},{"location":"tactical/DisplayCustomOverwatchActionPointOnUnitFlag/#displaycustomoverwatchactionpointonunitflag","text":"Tracking Issue: #724 Tags: compatibility The base XCOM 2 behavior is to show an Overwatch \"eye\" icon under the unit flag only if the soldier has at least one \"overwatch\" Reserve Action Point. The icon is not displayed for Pistol Overwatch. This change addresses that issue, and also allows mods that add weapons with custom Overwatch Action Point to specify that action point name in XComGame.ini: [XComGame.CHHelpers] +ValidReserveAPForUnitFlag = \"overwatch\" +ValidReserveAPForUnitFlag = \"pistoloverwatch\" Compatibility: If you override UIUnitFlag::RealizeOverwatch , your code may undo this change.","title":"DisplayCustomOverwatchActionPointOnUnitFlag"},{"location":"tactical/DisplayCustomOverwatchActionPointOnUnitFlag/#source-code-references","text":"UIUnitFlag.uc:1699-1712","title":"Source code references"},{"location":"tactical/ForceReapplyOnRefresh/","text":"ForceReapplyOnRefresh Tracking Issue: #475 The bForceReapplyOnRefresh flag allows effects that use or extend the X2Effect_PersistentStatChange class to be reapplied to a unit that is already under the influence of this effect. For example, it can be used to make sure Flashbangs remove Overwatch from units that are already disoriented. Source code references X2Effect_PersistentStatChange.uc:13-19","title":"ForceReapplyOnRefresh"},{"location":"tactical/ForceReapplyOnRefresh/#forcereapplyonrefresh","text":"Tracking Issue: #475 The bForceReapplyOnRefresh flag allows effects that use or extend the X2Effect_PersistentStatChange class to be reapplied to a unit that is already under the influence of this effect. For example, it can be used to make sure Flashbangs remove Overwatch from units that are already disoriented.","title":"ForceReapplyOnRefresh"},{"location":"tactical/ForceReapplyOnRefresh/#source-code-references","text":"X2Effect_PersistentStatChange.uc:13-19","title":"Source code references"},{"location":"tactical/GetStatModifiersFixed/","text":"GetStatModifiersFixed Tracking Issue: #313 Tags: compatibility The base game provides a function native function GetStatModifiers(ECharStatType Stat, out array<XComGameState_Effect> Mods, out array<float> ModValues, optional XComGameStateHistory GameStateHistoryObject); that can be used to identify how much different effects contribute to the calculated stat total. For example, X2AbilityToHitCalc_StandardAim wants to show how many percentage points to-hit or to-crit different effects provide or diminish. However, the function is subtly broken in the presence of multiplicative modifiers ( MODOP_Multiplication or MODOP_PostMultiplication ), where it doesn't return the correct contribution but instead simply returns MultiplicationMod * BaseStat . This makes multiplicative modifiers unusable for eStat_Offense and eStat_CritChance . The Highlander function GetStatModifiersFixed wraps the broken function and fixes the numbers. Additionally, X2AbilityToHitCalc_StandardAim is changed to call this modified function. Compatibility Mods that override/replace X2AbilityToHitCalc_StandardAim:GetHitChance may undo the Highlander's changes and use the broken function. In particular, XModBase versions prior to 2.0.2 are known to undo this fix . It is recommended that mods using XModBase upgrade to 2.0.2, and otherwise affected mods check whether GetStatModifiersFixed exists and call it instead: if (Function'XComGame.XComGameState_Unit.GetStatModifiersFixed' != none) { // call GetStatModifiersFixed } else { // call GetStatModifiers } Source code references XComGameState_Unit.uc:7099-7134 X2AbilityToHitCalc_StandardAim.uc:377 X2AbilityToHitCalc_StandardAim.uc:538","title":"GetStatModifiersFixed"},{"location":"tactical/GetStatModifiersFixed/#getstatmodifiersfixed","text":"Tracking Issue: #313 Tags: compatibility The base game provides a function native function GetStatModifiers(ECharStatType Stat, out array<XComGameState_Effect> Mods, out array<float> ModValues, optional XComGameStateHistory GameStateHistoryObject); that can be used to identify how much different effects contribute to the calculated stat total. For example, X2AbilityToHitCalc_StandardAim wants to show how many percentage points to-hit or to-crit different effects provide or diminish. However, the function is subtly broken in the presence of multiplicative modifiers ( MODOP_Multiplication or MODOP_PostMultiplication ), where it doesn't return the correct contribution but instead simply returns MultiplicationMod * BaseStat . This makes multiplicative modifiers unusable for eStat_Offense and eStat_CritChance . The Highlander function GetStatModifiersFixed wraps the broken function and fixes the numbers. Additionally, X2AbilityToHitCalc_StandardAim is changed to call this modified function.","title":"GetStatModifiersFixed"},{"location":"tactical/GetStatModifiersFixed/#compatibility","text":"Mods that override/replace X2AbilityToHitCalc_StandardAim:GetHitChance may undo the Highlander's changes and use the broken function. In particular, XModBase versions prior to 2.0.2 are known to undo this fix . It is recommended that mods using XModBase upgrade to 2.0.2, and otherwise affected mods check whether GetStatModifiersFixed exists and call it instead: if (Function'XComGame.XComGameState_Unit.GetStatModifiersFixed' != none) { // call GetStatModifiersFixed } else { // call GetStatModifiers }","title":"Compatibility"},{"location":"tactical/GetStatModifiersFixed/#source-code-references","text":"XComGameState_Unit.uc:7099-7134 X2AbilityToHitCalc_StandardAim.uc:377 X2AbilityToHitCalc_StandardAim.uc:538","title":"Source code references"},{"location":"tactical/GrenadesRequiringUnitsOnTargetedTiles/","text":"GrenadesRequiringUnitsOnTargetedTiles Tracking Issue: #669 An array of grenade template names for which only units actually on painted tiles should be affected by that grenade. Main example is smoke, since only units on smoked tiles should get the effect. Source code references CHHelpers.uc:210-213 XComGame.ini:44 X2TargetingMethod_Grenade.uc:221","title":"GrenadesRequiringUnitsOnTargetedTiles"},{"location":"tactical/GrenadesRequiringUnitsOnTargetedTiles/#grenadesrequiringunitsontargetedtiles","text":"Tracking Issue: #669 An array of grenade template names for which only units actually on painted tiles should be affected by that grenade. Main example is smoke, since only units on smoked tiles should get the effect.","title":"GrenadesRequiringUnitsOnTargetedTiles"},{"location":"tactical/GrenadesRequiringUnitsOnTargetedTiles/#source-code-references","text":"CHHelpers.uc:210-213 XComGame.ini:44 X2TargetingMethod_Grenade.uc:221","title":"Source code references"},{"location":"tactical/KismetGameStateMatinee/","text":"KismetGameStateMatinee Tracking Issue: #837 Tags: events Allow mods to insert their logic next to matinees triggered by mission kismet, by using ELD_OnVisualizationBlockStarted / ELD_OnVisualizationBlockCompleted or PreBuildVisualizationFn / PostBuildVisualizationFn . The triggering SeqAct_PlayGameStateMatinee can be fetched using the following code: XComGameStateContext_Kismet(GameState.GetContext()).FindSequenceOp() The SeqAct isn't passed as the event source as there is no definitive answer (at the time of implementation of this event) to whether passing kismet objects in events is safe in terms of the replay functionality or not. KismetGameStateMatinee event Param Value EventID KismetGameStateMatinee EventData none EventSource none NewGameState yes Listener template static function EventListenerReturn OnKismetGameStateMatinee(Object EventData, Object EventSource, XComGameState GameState, Name EventID, Object CallbackObject) { // Your code here return ELR_NoInterrupt; } Source code references SeqAct_PlayGameStateMatinee.uc:53-73","title":"KismetGameStateMatinee"},{"location":"tactical/KismetGameStateMatinee/#kismetgamestatematinee","text":"Tracking Issue: #837 Tags: events Allow mods to insert their logic next to matinees triggered by mission kismet, by using ELD_OnVisualizationBlockStarted / ELD_OnVisualizationBlockCompleted or PreBuildVisualizationFn / PostBuildVisualizationFn . The triggering SeqAct_PlayGameStateMatinee can be fetched using the following code: XComGameStateContext_Kismet(GameState.GetContext()).FindSequenceOp() The SeqAct isn't passed as the event source as there is no definitive answer (at the time of implementation of this event) to whether passing kismet objects in events is safe in terms of the replay functionality or not.","title":"KismetGameStateMatinee"},{"location":"tactical/KismetGameStateMatinee/#kismetgamestatematinee-event","text":"Param Value EventID KismetGameStateMatinee EventData none EventSource none NewGameState yes","title":"KismetGameStateMatinee event"},{"location":"tactical/KismetGameStateMatinee/#listener-template","text":"static function EventListenerReturn OnKismetGameStateMatinee(Object EventData, Object EventSource, XComGameState GameState, Name EventID, Object CallbackObject) { // Your code here return ELR_NoInterrupt; }","title":"Listener template"},{"location":"tactical/KismetGameStateMatinee/#source-code-references","text":"SeqAct_PlayGameStateMatinee.uc:53-73","title":"Source code references"},{"location":"tactical/LootTableAPI/","text":"LootTableAPI Tracking Issue: #8 Unprivates LootTables and adds convenience functions for common OPTC loot table operations. Refresher on loot tables Consider the simplified struct definitions taken from X2TacticalGameRulesetDataStructures : struct native LootTableEntry { var int Chance; var int RollGroup; var int MinCount, MaxCount; // Modifier on the chance, multiplicatively applied for each existing Item of type TemplateName acquired: // TotalChance = Chance * ChanceModPerExistingItem ^ NumExistingItems var float ChanceModPerExistingItem; // NOTE: these two are mutually exclusive, so only one should ever be filled in for a given entry var name TemplateName; var name TableRef; }; struct native LootTable { var name TableName; var array<LootTableEntry> Loots; }; When a unit template says \"hey, I drop this kind of loot\", it references a given LootTable by name. For the common random loot, a random unit is designated as a loot carrier at the start of the mission and its loot is rolled. The game then looks at the Loots entries and for every distinct RollGroup the game rolls a number in the half-open interval [0; 100[ (largest possible number is 99) to choose the item from that RollGroup . The game does this by iterating through the LootTableEntry entries with the current RollGroup and subtracting its Chance (after applying ChanceModPerExistingItem ) from the current chance. If this causes the current chance to go below 0 , this entry has been chosen and the game moves on to the next RollGroup . This has a number of non-intuitive consequences: Within the same RollGroup s, the chances are not independent; the game may choose 0 or 1 entries from that group. If the sum of chances in a RollGroup is x < 100 , there is a 100 - x percent chance that no entry is chosen and this RollGroup doesn't roll anything. If the sum of chances is x = 100 , then every entry will have a percent chance to be chosen identical to the Chance of the entry. If the sum of chances is x > 100 , then the latter entries will actually have a lower chance. Consider entries in the same roll group with chances 90 , 20 , 10 : The first entry will be chosen 9/10 times, the second 1/10 times, and the third never! We will discuss later what this means for mods. When an entry has been chosen, the game generates between MinCount and MaxCount of the item listed in TemplateName , if it is non-empty -- otherwise, the game invokes the aforedescribed algorithm recursively with the table referenced by name in TableRef . New APIs First and foremost, you need a loot table manager to work with. If you are in a place before templates are validated (template creation, OnPostTemplatesCreated ), the loot table manager doesn't exist yet and you need to operate on the ClassDefaultObject ; otherwise just request the loot table manager with the singleton accessor: // OPTC or template creation LootManager = X2LootTableManager(class'XComEngine'.static.FindClassDefaultObject(\"XComGame.X2LootTableManager\")); // Otherwise LootManager = class'X2LootTableManager'.static.GetLootTableManager(); The OPTC context is going to be the most common one, so the below documentation assumes that it's going to be used. LootTables This feature unprivates the otherwise config -only LootTables array. You can pretty much change anything there. If your code runs after OnPostTemplatesCreated returns, ensure to call InitLootTables if you add/remove/move around tables as a whole (the game maintains a name->index lookup for efficiency). RecalculateLootTableChanceStatic public static function RecalculateLootTableChanceStatic(name TableName, bool bEquallyDistributed = false); A non-static variant for the runtime context also exists: RecalculateLootTableChance Changes the chances for every entry in the table referred to by TableName so that the chances of every RollGroup add up to 100 . If bEquallyDistributed is true , all chances within a roll group will be equal, otherwise the proportions between the chances are maintained. This is a useful function for when you just want to add some items to existing roll groups of existing tables. Your items will naturally be placed at the end of the array, so according to consequence 4, your items might never be rolled. Calling this function makes sure your items will have a proportional chance to be rolled. Warning: Some of the latter functions recalculate chances for a given roll group implicitly unless opted out of. Warning: Some RollGroups have chance sums much lower than 100 so that only sometimes an item from that group drops. Carelessly calling RecalculateLootTableChance or forgetting to opt out of recalculating may cause showers of rare loot! AddEntryStatic/RemoveEntryStatic public static function AddEntryStatic(name TableName, LootTableEntry TableEntry, optional bool bRecalculateChances = true); public static function RemoveEntryStatic(name TableName, LootTableEntry TableEntry, optional bool bRecalculateChances = true); Non-static variants for the runtime context also exist: AddEntry , Remove Adds the entry to the given loot table, or removes it. Unless bRecalculateChances is set to false , also recalculates the chances for the entry's RollGroup so that they sum up to 100. AddLootTableStatic/RemoveLootTableStatic Actually, I have no idea why they exist and they probably don't do what you want them to. Don't use them. If you do, also call InitLootTables on the ClassDefaultObject . Example: // Adds M2 and M3 to ADVENT mid- and end-game loot, respectively static event OnPostTemplatesCreated() { local LootTableEntry M2Entry, M3Entry; M2Entry.Chance = 20; M2Entry.MinCount = 1; M2Entry.MaxCount = 1; M2Entry.TemplateName = 'AdventGremlinM2'; // RollGroup 1 is 100% a random Weapon Upgrade. This turns it into 20% Gremlin, 80% upgrade. M2Entry.RollGroup = 1; M3Entry = M2Entry; M3Entry.TemplateName = 'AdventGremlinM3'; class'X2LootTableManager'.static.AddEntryStatic('ADVENTMidTimedLoot', M2Entry, true); class'X2LootTableManager'.static.AddEntryStatic('ADVENTLateTimedLoot', M3Entry, true); } More example: Musashis RPG Overhaul uses this feature. Feel free to peruse its source code! Source code references X2LootTable.uc:25-161","title":"LootTableAPI"},{"location":"tactical/LootTableAPI/#loottableapi","text":"Tracking Issue: #8 Unprivates LootTables and adds convenience functions for common OPTC loot table operations.","title":"LootTableAPI"},{"location":"tactical/LootTableAPI/#refresher-on-loot-tables","text":"Consider the simplified struct definitions taken from X2TacticalGameRulesetDataStructures : struct native LootTableEntry { var int Chance; var int RollGroup; var int MinCount, MaxCount; // Modifier on the chance, multiplicatively applied for each existing Item of type TemplateName acquired: // TotalChance = Chance * ChanceModPerExistingItem ^ NumExistingItems var float ChanceModPerExistingItem; // NOTE: these two are mutually exclusive, so only one should ever be filled in for a given entry var name TemplateName; var name TableRef; }; struct native LootTable { var name TableName; var array<LootTableEntry> Loots; }; When a unit template says \"hey, I drop this kind of loot\", it references a given LootTable by name. For the common random loot, a random unit is designated as a loot carrier at the start of the mission and its loot is rolled. The game then looks at the Loots entries and for every distinct RollGroup the game rolls a number in the half-open interval [0; 100[ (largest possible number is 99) to choose the item from that RollGroup . The game does this by iterating through the LootTableEntry entries with the current RollGroup and subtracting its Chance (after applying ChanceModPerExistingItem ) from the current chance. If this causes the current chance to go below 0 , this entry has been chosen and the game moves on to the next RollGroup . This has a number of non-intuitive consequences: Within the same RollGroup s, the chances are not independent; the game may choose 0 or 1 entries from that group. If the sum of chances in a RollGroup is x < 100 , there is a 100 - x percent chance that no entry is chosen and this RollGroup doesn't roll anything. If the sum of chances is x = 100 , then every entry will have a percent chance to be chosen identical to the Chance of the entry. If the sum of chances is x > 100 , then the latter entries will actually have a lower chance. Consider entries in the same roll group with chances 90 , 20 , 10 : The first entry will be chosen 9/10 times, the second 1/10 times, and the third never! We will discuss later what this means for mods. When an entry has been chosen, the game generates between MinCount and MaxCount of the item listed in TemplateName , if it is non-empty -- otherwise, the game invokes the aforedescribed algorithm recursively with the table referenced by name in TableRef .","title":"Refresher on loot tables"},{"location":"tactical/LootTableAPI/#new-apis","text":"First and foremost, you need a loot table manager to work with. If you are in a place before templates are validated (template creation, OnPostTemplatesCreated ), the loot table manager doesn't exist yet and you need to operate on the ClassDefaultObject ; otherwise just request the loot table manager with the singleton accessor: // OPTC or template creation LootManager = X2LootTableManager(class'XComEngine'.static.FindClassDefaultObject(\"XComGame.X2LootTableManager\")); // Otherwise LootManager = class'X2LootTableManager'.static.GetLootTableManager(); The OPTC context is going to be the most common one, so the below documentation assumes that it's going to be used.","title":"New APIs"},{"location":"tactical/LootTableAPI/#loottables","text":"This feature unprivates the otherwise config -only LootTables array. You can pretty much change anything there. If your code runs after OnPostTemplatesCreated returns, ensure to call InitLootTables if you add/remove/move around tables as a whole (the game maintains a name->index lookup for efficiency).","title":"LootTables"},{"location":"tactical/LootTableAPI/#recalculateloottablechancestatic","text":"public static function RecalculateLootTableChanceStatic(name TableName, bool bEquallyDistributed = false); A non-static variant for the runtime context also exists: RecalculateLootTableChance Changes the chances for every entry in the table referred to by TableName so that the chances of every RollGroup add up to 100 . If bEquallyDistributed is true , all chances within a roll group will be equal, otherwise the proportions between the chances are maintained. This is a useful function for when you just want to add some items to existing roll groups of existing tables. Your items will naturally be placed at the end of the array, so according to consequence 4, your items might never be rolled. Calling this function makes sure your items will have a proportional chance to be rolled. Warning: Some of the latter functions recalculate chances for a given roll group implicitly unless opted out of. Warning: Some RollGroups have chance sums much lower than 100 so that only sometimes an item from that group drops. Carelessly calling RecalculateLootTableChance or forgetting to opt out of recalculating may cause showers of rare loot!","title":"RecalculateLootTableChanceStatic"},{"location":"tactical/LootTableAPI/#addentrystaticremoveentrystatic","text":"public static function AddEntryStatic(name TableName, LootTableEntry TableEntry, optional bool bRecalculateChances = true); public static function RemoveEntryStatic(name TableName, LootTableEntry TableEntry, optional bool bRecalculateChances = true); Non-static variants for the runtime context also exist: AddEntry , Remove Adds the entry to the given loot table, or removes it. Unless bRecalculateChances is set to false , also recalculates the chances for the entry's RollGroup so that they sum up to 100.","title":"AddEntryStatic/RemoveEntryStatic"},{"location":"tactical/LootTableAPI/#addloottablestaticremoveloottablestatic","text":"Actually, I have no idea why they exist and they probably don't do what you want them to. Don't use them. If you do, also call InitLootTables on the ClassDefaultObject .","title":"AddLootTableStatic/RemoveLootTableStatic"},{"location":"tactical/LootTableAPI/#example","text":"// Adds M2 and M3 to ADVENT mid- and end-game loot, respectively static event OnPostTemplatesCreated() { local LootTableEntry M2Entry, M3Entry; M2Entry.Chance = 20; M2Entry.MinCount = 1; M2Entry.MaxCount = 1; M2Entry.TemplateName = 'AdventGremlinM2'; // RollGroup 1 is 100% a random Weapon Upgrade. This turns it into 20% Gremlin, 80% upgrade. M2Entry.RollGroup = 1; M3Entry = M2Entry; M3Entry.TemplateName = 'AdventGremlinM3'; class'X2LootTableManager'.static.AddEntryStatic('ADVENTMidTimedLoot', M2Entry, true); class'X2LootTableManager'.static.AddEntryStatic('ADVENTLateTimedLoot', M3Entry, true); }","title":"Example:"},{"location":"tactical/LootTableAPI/#more-example","text":"Musashis RPG Overhaul uses this feature. Feel free to peruse its source code!","title":"More example:"},{"location":"tactical/LootTableAPI/#source-code-references","text":"X2LootTable.uc:25-161","title":"Source code references"},{"location":"tactical/MoreWillRollStats/","text":"MoreWillRollStats Tracking Issue: #936 This feature provides mods additional options when creating will loss events through XComGameStateContext_WillRoll . Adds new elements to enum WillEventRoll_StatType and adds implementation of the new elements to CalculateWillRoll . Elements of WillEventRoll_StatType are used when creating WillEventRollData in configuration files. Example from XComGameCore.ini : [XComGame.X2EventListener_DefaultWillEvents] SawEnemyUnitWillRollData=(WillLossChance=0.5, \\\\ FlatWillLossChance=true, \\\\ WillLossStat=WillEventRollStat_MaxWill, \\\\ WillLossStatMultiplier=0.05, \\\\ MinimumWillLoss=1, \\\\ MaxWillPercentageLostPerMission=0.33) Current Additions WillEventRollStat_Flat Calculated Will Loss: 1.0f This element existed, but was not implemented in the base game code. Similar to WillEventRollStat_None , but allows will loss to be modified by X2SitRepEffect_ModifyWillPenalties effects. For example usage of X2SitRepEffect_ModifyWillPenalties see X2SitRep_DefaultSitRepEffects:CreateDarkEventDarkTowerEffectTemplate . WillEventRollStat_CHPercentageHealthLost Calculated Will Loss: (Unit's Max HP - Unit's Current HP) / Unit's Max HP Corrected version of WillEventRollStat_PercentageHealthLost that actually gives the health lost (as opposed to health remaining). If a soldier with 5 max HP takes 2 damage to ablative HP, the calculation for will loss would be (5 - 5) / 5 = 0 . If they then took another 3 damage, the will loss would be (5 - 2) / 5 = 0.6 , as they have lost 60% of their total HP at this point. WillEventRollStat_CHTurnCountDecimal Calculated Will Loss: 1 + (Player's Turn Count / 10) This allows for a gradual increase in the amount of will lost as the mission goes on. At turn 1 the calculated will loss is 1.1 , and at turn 10 it will have nearly doubled to 2.0 . Source code references XComGameStateContext_WillRoll.uc:310-340","title":"MoreWillRollStats"},{"location":"tactical/MoreWillRollStats/#morewillrollstats","text":"Tracking Issue: #936 This feature provides mods additional options when creating will loss events through XComGameStateContext_WillRoll . Adds new elements to enum WillEventRoll_StatType and adds implementation of the new elements to CalculateWillRoll . Elements of WillEventRoll_StatType are used when creating WillEventRollData in configuration files. Example from XComGameCore.ini : [XComGame.X2EventListener_DefaultWillEvents] SawEnemyUnitWillRollData=(WillLossChance=0.5, \\\\ FlatWillLossChance=true, \\\\ WillLossStat=WillEventRollStat_MaxWill, \\\\ WillLossStatMultiplier=0.05, \\\\ MinimumWillLoss=1, \\\\ MaxWillPercentageLostPerMission=0.33)","title":"MoreWillRollStats"},{"location":"tactical/MoreWillRollStats/#current-additions","text":"","title":"Current Additions"},{"location":"tactical/MoreWillRollStats/#willeventrollstat_flat","text":"Calculated Will Loss: 1.0f This element existed, but was not implemented in the base game code. Similar to WillEventRollStat_None , but allows will loss to be modified by X2SitRepEffect_ModifyWillPenalties effects. For example usage of X2SitRepEffect_ModifyWillPenalties see X2SitRep_DefaultSitRepEffects:CreateDarkEventDarkTowerEffectTemplate .","title":"WillEventRollStat_Flat"},{"location":"tactical/MoreWillRollStats/#willeventrollstat_chpercentagehealthlost","text":"Calculated Will Loss: (Unit's Max HP - Unit's Current HP) / Unit's Max HP Corrected version of WillEventRollStat_PercentageHealthLost that actually gives the health lost (as opposed to health remaining). If a soldier with 5 max HP takes 2 damage to ablative HP, the calculation for will loss would be (5 - 5) / 5 = 0 . If they then took another 3 damage, the will loss would be (5 - 2) / 5 = 0.6 , as they have lost 60% of their total HP at this point.","title":"WillEventRollStat_CHPercentageHealthLost"},{"location":"tactical/MoreWillRollStats/#willeventrollstat_chturncountdecimal","text":"Calculated Will Loss: 1 + (Player's Turn Count / 10) This allows for a gradual increase in the amount of will lost as the mission goes on. At turn 1 the calculated will loss is 1.1 , and at turn 10 it will have nearly doubled to 2.0 .","title":"WillEventRollStat_CHTurnCountDecimal"},{"location":"tactical/MoreWillRollStats/#source-code-references","text":"XComGameStateContext_WillRoll.uc:310-340","title":"Source code references"},{"location":"tactical/OnDistributeTacticalGameEndXp/","text":"OnDistributeTacticalGameEndXp Tracking Issue: #562 Tags: events Allows mods to add their own mission XP distribution mechanics at the end of a mission. This hook is mainly to aid mods in providing other sources of XP than just kills. Mission XP (XP that's gained by just going on a mission) is a good example. OnDistributeTacticalGameEndXp event Param Value EventID OnDistributeTacticalGameEndXp EventData XComGameState_HeadquartersXCom EventSource XComGameState_XpManager NewGameState yes Listener template static function EventListenerReturn OnOnDistributeTacticalGameEndXp(Object EventData, Object EventSource, XComGameState GameState, Name EventID, Object CallbackObject) { local XComGameState_XpManager XpMgr; XpMgr = XComGameState_XpManager(EventSource); // Your code here return ELR_NoInterrupt; } Source code references XComGameState_XpManager.uc:111-122","title":"OnDistributeTacticalGameEndXp"},{"location":"tactical/OnDistributeTacticalGameEndXp/#ondistributetacticalgameendxp","text":"Tracking Issue: #562 Tags: events Allows mods to add their own mission XP distribution mechanics at the end of a mission. This hook is mainly to aid mods in providing other sources of XP than just kills. Mission XP (XP that's gained by just going on a mission) is a good example.","title":"OnDistributeTacticalGameEndXp"},{"location":"tactical/OnDistributeTacticalGameEndXp/#ondistributetacticalgameendxp-event","text":"Param Value EventID OnDistributeTacticalGameEndXp EventData XComGameState_HeadquartersXCom EventSource XComGameState_XpManager NewGameState yes","title":"OnDistributeTacticalGameEndXp event"},{"location":"tactical/OnDistributeTacticalGameEndXp/#listener-template","text":"static function EventListenerReturn OnOnDistributeTacticalGameEndXp(Object EventData, Object EventSource, XComGameState GameState, Name EventID, Object CallbackObject) { local XComGameState_XpManager XpMgr; XpMgr = XComGameState_XpManager(EventSource); // Your code here return ELR_NoInterrupt; }","title":"Listener template"},{"location":"tactical/OnDistributeTacticalGameEndXp/#source-code-references","text":"XComGameState_XpManager.uc:111-122","title":"Source code references"},{"location":"tactical/OverKillDamage/","text":"OverKillDamage Tracking Issue: #805 The UnitState's damage results array only holds the actual damage taken by the unit, so the result can't be higher than the unit's HP. This adds the OverkillDamage Unit value, which is shows how higher the kill damage value was from the standard Unit HP. One of its use cases is to modify the effects of the abilities that trigger on death, like the trigger chance on Advent Priest's Sustain. The OverKillDamage calculated by XCGS_Unit is negative, but the unit value is set to be positive to make using it more intuitive. The value uses eCleanup_BeginTactical . Source code references XComGameState_Unit.uc:15518-15523","title":"OverKillDamage"},{"location":"tactical/OverKillDamage/#overkilldamage","text":"Tracking Issue: #805 The UnitState's damage results array only holds the actual damage taken by the unit, so the result can't be higher than the unit's HP. This adds the OverkillDamage Unit value, which is shows how higher the kill damage value was from the standard Unit HP. One of its use cases is to modify the effects of the abilities that trigger on death, like the trigger chance on Advent Priest's Sustain. The OverKillDamage calculated by XCGS_Unit is negative, but the unit value is set to be positive to make using it more intuitive. The value uses eCleanup_BeginTactical .","title":"OverKillDamage"},{"location":"tactical/OverKillDamage/#source-code-references","text":"XComGameState_Unit.uc:15518-15523","title":"Source code references"},{"location":"tactical/OverrideAbilityIconColor/","text":"OverrideAbilityIconColor Tracking Issue: #400 Tags: events DEPRECATED - The OverrideAbilityIconColor event allows mods to override icon color for objective abilities or abilities that have AbilityIconColor property set in their templates. This event has been deprecated and should no longer be used. It is kept for backwards compatibility. Use OverrideAbilityIconColorImproved instead. OverrideAbilityIconColor event Param Value EventID OverrideAbilityIconColor EventData XComLWTuple EventSource XComGameState_Ability NewGameState none Tuple contents Index Name Type Direction 0 IsObjective bool in 1 BackgroundColor string inout Listener template static function EventListenerReturn OnOverrideAbilityIconColor(Object EventData, Object EventSource, XComGameState GameState, Name EventID, Object CallbackObject) { local XComGameState_Ability AbilityState; local XComLWTuple Tuple; local bool IsObjective; local string BackgroundColor; AbilityState = XComGameState_Ability(EventSource); Tuple = XComLWTuple(EventData); IsObjective = Tuple.Data[0].b; BackgroundColor = Tuple.Data[1].s; // Your code here Tuple.Data[1].s = BackgroundColor; return ELR_NoInterrupt; } Source code references UITacticalHUD_Ability.uc:198-211","title":"OverrideAbilityIconColor"},{"location":"tactical/OverrideAbilityIconColor/#overrideabilityiconcolor","text":"Tracking Issue: #400 Tags: events DEPRECATED - The OverrideAbilityIconColor event allows mods to override icon color for objective abilities or abilities that have AbilityIconColor property set in their templates. This event has been deprecated and should no longer be used. It is kept for backwards compatibility. Use OverrideAbilityIconColorImproved instead.","title":"OverrideAbilityIconColor"},{"location":"tactical/OverrideAbilityIconColor/#overrideabilityiconcolor-event","text":"Param Value EventID OverrideAbilityIconColor EventData XComLWTuple EventSource XComGameState_Ability NewGameState none","title":"OverrideAbilityIconColor event"},{"location":"tactical/OverrideAbilityIconColor/#tuple-contents","text":"Index Name Type Direction 0 IsObjective bool in 1 BackgroundColor string inout","title":"Tuple contents"},{"location":"tactical/OverrideAbilityIconColor/#listener-template","text":"static function EventListenerReturn OnOverrideAbilityIconColor(Object EventData, Object EventSource, XComGameState GameState, Name EventID, Object CallbackObject) { local XComGameState_Ability AbilityState; local XComLWTuple Tuple; local bool IsObjective; local string BackgroundColor; AbilityState = XComGameState_Ability(EventSource); Tuple = XComLWTuple(EventData); IsObjective = Tuple.Data[0].b; BackgroundColor = Tuple.Data[1].s; // Your code here Tuple.Data[1].s = BackgroundColor; return ELR_NoInterrupt; }","title":"Listener template"},{"location":"tactical/OverrideAbilityIconColor/#source-code-references","text":"UITacticalHUD_Ability.uc:198-211","title":"Source code references"},{"location":"tactical/OverrideAbilityIconColorImproved/","text":"OverrideAbilityIconColorImproved Tracking Issue: #749 Tags: compatibility , events The OverrideAbilityIconColorImproved event allows mods to override background and foreground colors of ability icons. The \"background\" color is the color of the icon itself, and normally varies depending on the AbilitySourceName property of the X2AbilityTemplate . The \"foreground\" color is normally always black. Default colors used by the game can be found in the UIUtilities_Colors class. Performance note: this event gets triggered a lot , so try to avoid complex computations in listeners to reduce the performance hit. OverrideAbilityIconColorImproved event Param Value EventID OverrideAbilityIconColorImproved EventData XComLWTuple EventSource XComGameState_Ability NewGameState none Tuple contents Index Name Type Direction 0 IsObjective bool in 1 BackgroundColor string inout 2 ForegroundColor string inout Listener template static function EventListenerReturn OnOverrideAbilityIconColorImproved(Object EventData, Object EventSource, XComGameState GameState, Name EventID, Object CallbackObject) { local XComGameState_Ability AbilityState; local XComLWTuple Tuple; local bool IsObjective; local string BackgroundColor; local string ForegroundColor; AbilityState = XComGameState_Ability(EventSource); Tuple = XComLWTuple(EventData); IsObjective = Tuple.Data[0].b; BackgroundColor = Tuple.Data[1].s; ForegroundColor = Tuple.Data[2].s; // Your code here Tuple.Data[1].s = BackgroundColor; Tuple.Data[2].s = ForegroundColor; return ELR_NoInterrupt; } Compatibility This event takes precedence over the deprecated event OverrideAbilityIconColor , so any listener that changes ability icon colors will always overwrite any changes made by listeners of the deprecated event. Source code references UITacticalHUD_Ability.uc:231-252","title":"OverrideAbilityIconColorImproved"},{"location":"tactical/OverrideAbilityIconColorImproved/#overrideabilityiconcolorimproved","text":"Tracking Issue: #749 Tags: compatibility , events The OverrideAbilityIconColorImproved event allows mods to override background and foreground colors of ability icons. The \"background\" color is the color of the icon itself, and normally varies depending on the AbilitySourceName property of the X2AbilityTemplate . The \"foreground\" color is normally always black. Default colors used by the game can be found in the UIUtilities_Colors class. Performance note: this event gets triggered a lot , so try to avoid complex computations in listeners to reduce the performance hit.","title":"OverrideAbilityIconColorImproved"},{"location":"tactical/OverrideAbilityIconColorImproved/#overrideabilityiconcolorimproved-event","text":"Param Value EventID OverrideAbilityIconColorImproved EventData XComLWTuple EventSource XComGameState_Ability NewGameState none","title":"OverrideAbilityIconColorImproved event"},{"location":"tactical/OverrideAbilityIconColorImproved/#tuple-contents","text":"Index Name Type Direction 0 IsObjective bool in 1 BackgroundColor string inout 2 ForegroundColor string inout","title":"Tuple contents"},{"location":"tactical/OverrideAbilityIconColorImproved/#listener-template","text":"static function EventListenerReturn OnOverrideAbilityIconColorImproved(Object EventData, Object EventSource, XComGameState GameState, Name EventID, Object CallbackObject) { local XComGameState_Ability AbilityState; local XComLWTuple Tuple; local bool IsObjective; local string BackgroundColor; local string ForegroundColor; AbilityState = XComGameState_Ability(EventSource); Tuple = XComLWTuple(EventData); IsObjective = Tuple.Data[0].b; BackgroundColor = Tuple.Data[1].s; ForegroundColor = Tuple.Data[2].s; // Your code here Tuple.Data[1].s = BackgroundColor; Tuple.Data[2].s = ForegroundColor; return ELR_NoInterrupt; }","title":"Listener template"},{"location":"tactical/OverrideAbilityIconColorImproved/#compatibility","text":"This event takes precedence over the deprecated event OverrideAbilityIconColor , so any listener that changes ability icon colors will always overwrite any changes made by listeners of the deprecated event.","title":"Compatibility"},{"location":"tactical/OverrideAbilityIconColorImproved/#source-code-references","text":"UITacticalHUD_Ability.uc:231-252","title":"Source code references"},{"location":"tactical/OverrideCameraRotationAngle/","text":"OverrideCameraRotationAngle Tracking Issue: #854 Tags: compatibility The 'OverrideCameraRotationAngle' event allows mods to override the angle the camera rotates when using the controller or the Q and E buttons. The event takes the following form, with mods changing the first value of the tuple if they want to change the angle: EventID: OverrideCameraRotationAngle EventData: [ inout float RotationAngle, in int ActionMask ] EventSource: none NewGameState: none Compatibility Several mods, typically ones that modify the behavior of the camera, override XComTacticalInput , thus breaking this highlander change. Since those camera mods mostly seem to override the camera rotation behavior, that's usually not a problem. Just be aware that overriding XComTacticalInput without including this highlander event may break other mods that rely on it. Source code references XComTacticalInput.uc:890-910","title":"OverrideCameraRotationAngle"},{"location":"tactical/OverrideCameraRotationAngle/#overridecamerarotationangle","text":"Tracking Issue: #854 Tags: compatibility The 'OverrideCameraRotationAngle' event allows mods to override the angle the camera rotates when using the controller or the Q and E buttons. The event takes the following form, with mods changing the first value of the tuple if they want to change the angle: EventID: OverrideCameraRotationAngle EventData: [ inout float RotationAngle, in int ActionMask ] EventSource: none NewGameState: none","title":"OverrideCameraRotationAngle"},{"location":"tactical/OverrideCameraRotationAngle/#compatibility","text":"Several mods, typically ones that modify the behavior of the camera, override XComTacticalInput , thus breaking this highlander change. Since those camera mods mostly seem to override the camera rotation behavior, that's usually not a problem. Just be aware that overriding XComTacticalInput without including this highlander event may break other mods that rely on it.","title":"Compatibility"},{"location":"tactical/OverrideCameraRotationAngle/#source-code-references","text":"XComTacticalInput.uc:890-910","title":"Source code references"},{"location":"tactical/OverrideClipSize/","text":"OverrideClipSize Tracking Issue: #393 Tags: events The OverrideClipSize event allows mods to override Clip Size of a weapon after it has been modified by weapon upgrades and/or loaded ammo. This can help make a passive ability that modifies Clip Size of the soldier's weapon, or to explicitly disallow a specific weapon benefitting from effects that modify Clip Size by resetting the clip size value to the clip size value stored in the weapon template. OverrideClipSize event Param Value EventID OverrideClipSize EventData XComLWTuple EventSource XComGameState_Item NewGameState none Tuple contents Index Name Type Direction 0 iClipSize int inout Listener template static function EventListenerReturn OnOverrideClipSize(Object EventData, Object EventSource, XComGameState GameState, Name EventID, Object CallbackObject) { local XComGameState_Item ItemState; local XComLWTuple Tuple; local int iClipSize; ItemState = XComGameState_Item(EventSource); Tuple = XComLWTuple(EventData); iClipSize = Tuple.Data[0].i; // Your code here Tuple.Data[0].i = iClipSize; return ELR_NoInterrupt; } Source code references XComGameState_Item.uc:942-955","title":"OverrideClipSize"},{"location":"tactical/OverrideClipSize/#overrideclipsize","text":"Tracking Issue: #393 Tags: events The OverrideClipSize event allows mods to override Clip Size of a weapon after it has been modified by weapon upgrades and/or loaded ammo. This can help make a passive ability that modifies Clip Size of the soldier's weapon, or to explicitly disallow a specific weapon benefitting from effects that modify Clip Size by resetting the clip size value to the clip size value stored in the weapon template.","title":"OverrideClipSize"},{"location":"tactical/OverrideClipSize/#overrideclipsize-event","text":"Param Value EventID OverrideClipSize EventData XComLWTuple EventSource XComGameState_Item NewGameState none","title":"OverrideClipSize event"},{"location":"tactical/OverrideClipSize/#tuple-contents","text":"Index Name Type Direction 0 iClipSize int inout","title":"Tuple contents"},{"location":"tactical/OverrideClipSize/#listener-template","text":"static function EventListenerReturn OnOverrideClipSize(Object EventData, Object EventSource, XComGameState GameState, Name EventID, Object CallbackObject) { local XComGameState_Item ItemState; local XComLWTuple Tuple; local int iClipSize; ItemState = XComGameState_Item(EventSource); Tuple = XComLWTuple(EventData); iClipSize = Tuple.Data[0].i; // Your code here Tuple.Data[0].i = iClipSize; return ELR_NoInterrupt; }","title":"Listener template"},{"location":"tactical/OverrideClipSize/#source-code-references","text":"XComGameState_Item.uc:942-955","title":"Source code references"},{"location":"tactical/OverrideDamageRemovesReserveActionPoints/","text":"OverrideDamageRemovesReserveActionPoints Tracking Issue: #903 Tags: events The OverrideDamageRemovesReserveActionPoints event allows mods to override the base game logic that determines that a Unit must lose their Reserve Action Points when they take damage. This event triggers after the information about this damage instance has been added to the UnitState.DamageResults array, so you can use that last entry to get any additional info about who damaged whom with what. OverrideDamageRemovesReserveActionPoints event Param Value EventID OverrideDamageRemovesReserveActionPoints EventData XComLWTuple EventSource XComGameState_Unit NewGameState yes Tuple contents Index Name Type Direction 0 bDamageRemovesReserveActionPoints bool inout Listener template static function EventListenerReturn OnOverrideDamageRemovesReserveActionPoints(Object EventData, Object EventSource, XComGameState GameState, Name EventID, Object CallbackObject) { local XComGameState_Unit UnitState; local XComLWTuple Tuple; local bool bDamageRemovesReserveActionPoints; UnitState = XComGameState_Unit(EventSource); Tuple = XComLWTuple(EventData); bDamageRemovesReserveActionPoints = Tuple.Data[0].b; // Your code here Tuple.Data[0].b = bDamageRemovesReserveActionPoints; return ELR_NoInterrupt; } Source code references XComGameState_Unit.uc:6570-6584","title":"OverrideDamageRemovesReserveActionPoints"},{"location":"tactical/OverrideDamageRemovesReserveActionPoints/#overridedamageremovesreserveactionpoints","text":"Tracking Issue: #903 Tags: events The OverrideDamageRemovesReserveActionPoints event allows mods to override the base game logic that determines that a Unit must lose their Reserve Action Points when they take damage. This event triggers after the information about this damage instance has been added to the UnitState.DamageResults array, so you can use that last entry to get any additional info about who damaged whom with what.","title":"OverrideDamageRemovesReserveActionPoints"},{"location":"tactical/OverrideDamageRemovesReserveActionPoints/#overridedamageremovesreserveactionpoints-event","text":"Param Value EventID OverrideDamageRemovesReserveActionPoints EventData XComLWTuple EventSource XComGameState_Unit NewGameState yes","title":"OverrideDamageRemovesReserveActionPoints event"},{"location":"tactical/OverrideDamageRemovesReserveActionPoints/#tuple-contents","text":"Index Name Type Direction 0 bDamageRemovesReserveActionPoints bool inout","title":"Tuple contents"},{"location":"tactical/OverrideDamageRemovesReserveActionPoints/#listener-template","text":"static function EventListenerReturn OnOverrideDamageRemovesReserveActionPoints(Object EventData, Object EventSource, XComGameState GameState, Name EventID, Object CallbackObject) { local XComGameState_Unit UnitState; local XComLWTuple Tuple; local bool bDamageRemovesReserveActionPoints; UnitState = XComGameState_Unit(EventSource); Tuple = XComLWTuple(EventData); bDamageRemovesReserveActionPoints = Tuple.Data[0].b; // Your code here Tuple.Data[0].b = bDamageRemovesReserveActionPoints; return ELR_NoInterrupt; }","title":"Listener template"},{"location":"tactical/OverrideDamageRemovesReserveActionPoints/#source-code-references","text":"XComGameState_Unit.uc:6570-6584","title":"Source code references"},{"location":"tactical/OverrideDisableReinforcementsFlare/","text":"OverrideDisableReinforcementsFlare Tracking Issue: #448 Tags: events The OverrideDisableReinforcementsFlare event allows mods to disable the visuals for the particle effects (red flare or purple psionic gate in base game) that indicate the location of incoming enemy reinforcements, as well as other visualization associated with it, such as camera panning. OverrideDisableReinforcementsFlare event Param Value EventID OverrideDisableReinforcementsFlare EventData XComLWTuple EventSource XComGameState_AIReinforcementSpawner NewGameState none Tuple contents Index Name Type Direction 0 bDisableFlare bool inout Listener template static function EventListenerReturn OnOverrideDisableReinforcementsFlare(Object EventData, Object EventSource, XComGameState GameState, Name EventID, Object CallbackObject) { local XComGameState_AIReinforcementSpawner AISpawnerState; local XComLWTuple Tuple; local bool bDisableFlare; AISpawnerState = XComGameState_AIReinforcementSpawner(EventSource); Tuple = XComLWTuple(EventData); bDisableFlare = Tuple.Data[0].b; // Your code here Tuple.Data[0].b = bDisableFlare; return ELR_NoInterrupt; } Source code references XComGameState_AIReinforcementSpawner.uc:614-625","title":"OverrideDisableReinforcementsFlare"},{"location":"tactical/OverrideDisableReinforcementsFlare/#overridedisablereinforcementsflare","text":"Tracking Issue: #448 Tags: events The OverrideDisableReinforcementsFlare event allows mods to disable the visuals for the particle effects (red flare or purple psionic gate in base game) that indicate the location of incoming enemy reinforcements, as well as other visualization associated with it, such as camera panning.","title":"OverrideDisableReinforcementsFlare"},{"location":"tactical/OverrideDisableReinforcementsFlare/#overridedisablereinforcementsflare-event","text":"Param Value EventID OverrideDisableReinforcementsFlare EventData XComLWTuple EventSource XComGameState_AIReinforcementSpawner NewGameState none","title":"OverrideDisableReinforcementsFlare event"},{"location":"tactical/OverrideDisableReinforcementsFlare/#tuple-contents","text":"Index Name Type Direction 0 bDisableFlare bool inout","title":"Tuple contents"},{"location":"tactical/OverrideDisableReinforcementsFlare/#listener-template","text":"static function EventListenerReturn OnOverrideDisableReinforcementsFlare(Object EventData, Object EventSource, XComGameState GameState, Name EventID, Object CallbackObject) { local XComGameState_AIReinforcementSpawner AISpawnerState; local XComLWTuple Tuple; local bool bDisableFlare; AISpawnerState = XComGameState_AIReinforcementSpawner(EventSource); Tuple = XComLWTuple(EventData); bDisableFlare = Tuple.Data[0].b; // Your code here Tuple.Data[0].b = bDisableFlare; return ELR_NoInterrupt; }","title":"Listener template"},{"location":"tactical/OverrideDisableReinforcementsFlare/#source-code-references","text":"XComGameState_AIReinforcementSpawner.uc:614-625","title":"Source code references"},{"location":"tactical/OverrideEncounterZoneAnchorPoint/","text":"OverrideEncounterZoneAnchorPoint Tracking Issue: #500 Tags: events The OverrideEncounterZoneAnchorPoint event allows mods to override the anchor point for determining encounter zones for patrolling pods. X, Y and Z components of the tuple should be treated as components of the Anchor Point's vector coordinates. OverrideEncounterZoneAnchorPoint event Param Value EventID OverrideEncounterZoneAnchorPoint EventData XComLWTuple EventSource XComGameState_AIGroup NewGameState none Tuple contents Index Name Type Direction 0 X float inout 1 Y float inout 2 Z float inout Listener template static function EventListenerReturn OnOverrideEncounterZoneAnchorPoint(Object EventData, Object EventSource, XComGameState GameState, Name EventID, Object CallbackObject) { local XComGameState_AIGroup AIGroup; local XComLWTuple Tuple; local float X; local float Y; local float Z; AIGroup = XComGameState_AIGroup(EventSource); Tuple = XComLWTuple(EventData); X = Tuple.Data[0].f; Y = Tuple.Data[1].f; Z = Tuple.Data[2].f; // Your code here Tuple.Data[0].f = X; Tuple.Data[1].f = Y; Tuple.Data[2].f = Z; return ELR_NoInterrupt; } This allows mods to override the LoP anchor point for the encounter zone. By default, the encounter zone adjusts to the current location of the XCOM squad. As an example, a mod could use the XCOM's spawn location instead so that the encounter zones remain the same regardless of where the XCOM squad is currently. Source code references XComGameState_AIGroup.uc:454-466 XComGameState_AIGroup.uc:391-398","title":"OverrideEncounterZoneAnchorPoint"},{"location":"tactical/OverrideEncounterZoneAnchorPoint/#overrideencounterzoneanchorpoint","text":"Tracking Issue: #500 Tags: events The OverrideEncounterZoneAnchorPoint event allows mods to override the anchor point for determining encounter zones for patrolling pods. X, Y and Z components of the tuple should be treated as components of the Anchor Point's vector coordinates.","title":"OverrideEncounterZoneAnchorPoint"},{"location":"tactical/OverrideEncounterZoneAnchorPoint/#overrideencounterzoneanchorpoint-event","text":"Param Value EventID OverrideEncounterZoneAnchorPoint EventData XComLWTuple EventSource XComGameState_AIGroup NewGameState none","title":"OverrideEncounterZoneAnchorPoint event"},{"location":"tactical/OverrideEncounterZoneAnchorPoint/#tuple-contents","text":"Index Name Type Direction 0 X float inout 1 Y float inout 2 Z float inout","title":"Tuple contents"},{"location":"tactical/OverrideEncounterZoneAnchorPoint/#listener-template","text":"static function EventListenerReturn OnOverrideEncounterZoneAnchorPoint(Object EventData, Object EventSource, XComGameState GameState, Name EventID, Object CallbackObject) { local XComGameState_AIGroup AIGroup; local XComLWTuple Tuple; local float X; local float Y; local float Z; AIGroup = XComGameState_AIGroup(EventSource); Tuple = XComLWTuple(EventData); X = Tuple.Data[0].f; Y = Tuple.Data[1].f; Z = Tuple.Data[2].f; // Your code here Tuple.Data[0].f = X; Tuple.Data[1].f = Y; Tuple.Data[2].f = Z; return ELR_NoInterrupt; } This allows mods to override the LoP anchor point for the encounter zone. By default, the encounter zone adjusts to the current location of the XCOM squad. As an example, a mod could use the XCOM's spawn location instead so that the encounter zones remain the same regardless of where the XCOM squad is currently.","title":"Listener template"},{"location":"tactical/OverrideEncounterZoneAnchorPoint/#source-code-references","text":"XComGameState_AIGroup.uc:454-466 XComGameState_AIGroup.uc:391-398","title":"Source code references"},{"location":"tactical/OverrideHasHeightAdvantageOver/","text":"OverrideHasHeightAdvantageOver Tracking Issue: #851 This event allows mods to override the standard game's logic for checking whether one unit has height advantate over another unit. In order to take advantage of this event, make a listener with the ELD_Immediate deferral, and cast EventData to XComLWTuple. Tuple.Data[0].b will already contain the bool value of whether this unit has height advantage over the other unit according to the vanilla logic. You can replace the value with your own based on arbitrary parameters, such as one of the units being affected by a certain effect or having a certain ability. EventID: OverrideHasHeightAdvantageOver EventData: XComLWTuple { Data: [ inout bool HasHeightAdvantageOver, in bool bAsAttacker, in XComGameState_Unit OtherUnit ] } EventSource: XComGameState_Unit (of the unit performing the check) Game State: never. Example of an Event Listener Function: static function EventListenerReturn ListenerEventFunction(Object EventData, Object EventSource, XComGameState NewGameState, Name Event, Object CallbackData) { local XComLWTuple Tuple; local XComGameState_Unit UnitState; Tuple = XComLWTuple(EventData); UnitState = XComGameState_Unit(EventSource); if (Tuple == none || UnitState == none) return ELR_NoInterrupt; // The Unit is an attacker and it does not already have a height advantage. if (Tuple.Data[1].b && !Tuple.Data[0].b) { // Then we give the unit height advantage if they are affected by the Jet Shot effect. Tuple.Data[0].b = UnitState.IsUnitAffectedByEffectName('IRI_JetShot_Effect'); } return ELR_NoInterrupt; } Source code references XComGameState_Unit.uc:1125-1168","title":"OverrideHasHeightAdvantageOver"},{"location":"tactical/OverrideHasHeightAdvantageOver/#overridehasheightadvantageover","text":"Tracking Issue: #851 This event allows mods to override the standard game's logic for checking whether one unit has height advantate over another unit. In order to take advantage of this event, make a listener with the ELD_Immediate deferral, and cast EventData to XComLWTuple. Tuple.Data[0].b will already contain the bool value of whether this unit has height advantage over the other unit according to the vanilla logic. You can replace the value with your own based on arbitrary parameters, such as one of the units being affected by a certain effect or having a certain ability. EventID: OverrideHasHeightAdvantageOver EventData: XComLWTuple { Data: [ inout bool HasHeightAdvantageOver, in bool bAsAttacker, in XComGameState_Unit OtherUnit ] } EventSource: XComGameState_Unit (of the unit performing the check) Game State: never. Example of an Event Listener Function: static function EventListenerReturn ListenerEventFunction(Object EventData, Object EventSource, XComGameState NewGameState, Name Event, Object CallbackData) { local XComLWTuple Tuple; local XComGameState_Unit UnitState; Tuple = XComLWTuple(EventData); UnitState = XComGameState_Unit(EventSource); if (Tuple == none || UnitState == none) return ELR_NoInterrupt; // The Unit is an attacker and it does not already have a height advantage. if (Tuple.Data[1].b && !Tuple.Data[0].b) { // Then we give the unit height advantage if they are affected by the Jet Shot effect. Tuple.Data[0].b = UnitState.IsUnitAffectedByEffectName('IRI_JetShot_Effect'); } return ELR_NoInterrupt; }","title":"OverrideHasHeightAdvantageOver"},{"location":"tactical/OverrideHasHeightAdvantageOver/#source-code-references","text":"XComGameState_Unit.uc:1125-1168","title":"Source code references"},{"location":"tactical/OverrideHasInfiniteAmmo/","text":"OverrideHasInfiniteAmmo Tracking Issue: #842 Tags: events Allows listeners to override the result of HasInfiniteAmmo OverrideHasInfiniteAmmo event Param Value EventID OverrideHasInfiniteAmmo EventData XComLWTuple EventSource XComGameState_Item NewGameState none Tuple contents Index Name Type Direction 0 bHasInfiniteAmmo bool out Listener template static function EventListenerReturn OnOverrideHasInfiniteAmmo(Object EventData, Object EventSource, XComGameState GameState, Name EventID, Object CallbackObject) { local XComGameState_Item ItemState; local XComLWTuple Tuple; local bool bHasInfiniteAmmo; ItemState = XComGameState_Item(EventSource); Tuple = XComLWTuple(EventData); // Your code here Tuple.Data[0].b = bHasInfiniteAmmo; return ELR_NoInterrupt; } Source code references XComGameState_Item.uc:985-993","title":"OverrideHasInfiniteAmmo"},{"location":"tactical/OverrideHasInfiniteAmmo/#overridehasinfiniteammo","text":"Tracking Issue: #842 Tags: events Allows listeners to override the result of HasInfiniteAmmo","title":"OverrideHasInfiniteAmmo"},{"location":"tactical/OverrideHasInfiniteAmmo/#overridehasinfiniteammo-event","text":"Param Value EventID OverrideHasInfiniteAmmo EventData XComLWTuple EventSource XComGameState_Item NewGameState none","title":"OverrideHasInfiniteAmmo event"},{"location":"tactical/OverrideHasInfiniteAmmo/#tuple-contents","text":"Index Name Type Direction 0 bHasInfiniteAmmo bool out","title":"Tuple contents"},{"location":"tactical/OverrideHasInfiniteAmmo/#listener-template","text":"static function EventListenerReturn OnOverrideHasInfiniteAmmo(Object EventData, Object EventSource, XComGameState GameState, Name EventID, Object CallbackObject) { local XComGameState_Item ItemState; local XComLWTuple Tuple; local bool bHasInfiniteAmmo; ItemState = XComGameState_Item(EventSource); Tuple = XComLWTuple(EventData); // Your code here Tuple.Data[0].b = bHasInfiniteAmmo; return ELR_NoInterrupt; }","title":"Listener template"},{"location":"tactical/OverrideHasInfiniteAmmo/#source-code-references","text":"XComGameState_Item.uc:985-993","title":"Source code references"},{"location":"tactical/OverrideHitEffects/","text":"OverrideHitEffects Tracking Issue: #825 Tags: events Allows listeners to override the default behavior of XComUnitPawn.PlayHitEffects This is especially useful for preventing the hardcoded templar fx for eHit_Parry, eHit_Reflect and eHit_Deflect which play for any abilities that utilizing these hit results. If OverrideHitEffect is set to true the PlayHitEffects function will return early and the default behavior is ommited. OverrideHitEffects event Param Value EventID OverrideHitEffects EventData XComLWTuple EventSource XComUnitPawn NewGameState none Tuple contents Index Name Type Direction 0 OverrideHitEffect bool out 1 Damage float inout 2 InstigatedBy Actor inout 3 HitLocation vector inout 4 DamageTypeName name inout 5 Momentum vector inout 6 bIsUnitRuptured bool inout 7 HitResult enum (EAbilityHitResult) inout Listener template static function EventListenerReturn OnOverrideHitEffects(Object EventData, Object EventSource, XComGameState GameState, Name EventID, Object CallbackObject) { local XComUnitPawn Pawn; local XComLWTuple Tuple; local bool OverrideHitEffect; local float Damage; local Actor InstigatedBy; local vector HitLocation; local name DamageTypeName; local vector Momentum; local bool bIsUnitRuptured; local EAbilityHitResult HitResult; Pawn = XComUnitPawn(EventSource); Tuple = XComLWTuple(EventData); Damage = Tuple.Data[1].f; InstigatedBy = Actor(Tuple.Data[2].o); HitLocation = Tuple.Data[3].v; DamageTypeName = Tuple.Data[4].n; Momentum = Tuple.Data[5].v; bIsUnitRuptured = Tuple.Data[6].b; HitResult = EAbilityHitResult(Tuple.Data[7].i); // Your code here Tuple.Data[0].b = OverrideHitEffect; Tuple.Data[1].f = Damage; Tuple.Data[2].o = InstigatedBy; Tuple.Data[3].v = HitLocation; Tuple.Data[4].n = DamageTypeName; Tuple.Data[5].v = Momentum; Tuple.Data[6].b = bIsUnitRuptured; Tuple.Data[7].i = HitResult; return ELR_NoInterrupt; } Source code references XComUnitPawn.uc:380-400","title":"OverrideHitEffects"},{"location":"tactical/OverrideHitEffects/#overridehiteffects","text":"Tracking Issue: #825 Tags: events Allows listeners to override the default behavior of XComUnitPawn.PlayHitEffects This is especially useful for preventing the hardcoded templar fx for eHit_Parry, eHit_Reflect and eHit_Deflect which play for any abilities that utilizing these hit results. If OverrideHitEffect is set to true the PlayHitEffects function will return early and the default behavior is ommited.","title":"OverrideHitEffects"},{"location":"tactical/OverrideHitEffects/#overridehiteffects-event","text":"Param Value EventID OverrideHitEffects EventData XComLWTuple EventSource XComUnitPawn NewGameState none","title":"OverrideHitEffects event"},{"location":"tactical/OverrideHitEffects/#tuple-contents","text":"Index Name Type Direction 0 OverrideHitEffect bool out 1 Damage float inout 2 InstigatedBy Actor inout 3 HitLocation vector inout 4 DamageTypeName name inout 5 Momentum vector inout 6 bIsUnitRuptured bool inout 7 HitResult enum (EAbilityHitResult) inout","title":"Tuple contents"},{"location":"tactical/OverrideHitEffects/#listener-template","text":"static function EventListenerReturn OnOverrideHitEffects(Object EventData, Object EventSource, XComGameState GameState, Name EventID, Object CallbackObject) { local XComUnitPawn Pawn; local XComLWTuple Tuple; local bool OverrideHitEffect; local float Damage; local Actor InstigatedBy; local vector HitLocation; local name DamageTypeName; local vector Momentum; local bool bIsUnitRuptured; local EAbilityHitResult HitResult; Pawn = XComUnitPawn(EventSource); Tuple = XComLWTuple(EventData); Damage = Tuple.Data[1].f; InstigatedBy = Actor(Tuple.Data[2].o); HitLocation = Tuple.Data[3].v; DamageTypeName = Tuple.Data[4].n; Momentum = Tuple.Data[5].v; bIsUnitRuptured = Tuple.Data[6].b; HitResult = EAbilityHitResult(Tuple.Data[7].i); // Your code here Tuple.Data[0].b = OverrideHitEffect; Tuple.Data[1].f = Damage; Tuple.Data[2].o = InstigatedBy; Tuple.Data[3].v = HitLocation; Tuple.Data[4].n = DamageTypeName; Tuple.Data[5].v = Momentum; Tuple.Data[6].b = bIsUnitRuptured; Tuple.Data[7].i = HitResult; return ELR_NoInterrupt; }","title":"Listener template"},{"location":"tactical/OverrideHitEffects/#source-code-references","text":"XComUnitPawn.uc:380-400","title":"Source code references"},{"location":"tactical/OverrideKillXp/","text":"OverrideKillXp Tracking Issue: #562 Tags: events Allows listeners to override the XP values granted by a kill, including the normal kill contribution, any bonus XP from resistance orders and the like, the XP granted for assists, and any Wet Work bonus. Mods can even set these values to zero to prevent XP gain. This event is called no more than once for each kill. OverrideKillXp event Param Value EventID OverrideKillXp EventData XComLWTuple EventSource XComGameState_Unit NewGameState yes Tuple contents Index Name Type Direction 0 KillXp float inout 1 BonusKillXp float inout 2 KillAssistXp float inout 3 WetWorkXp int inout 4 Killer XComGameState_Unit in Listener template static function EventListenerReturn OnOverrideKillXp(Object EventData, Object EventSource, XComGameState GameState, Name EventID, Object CallbackObject) { local XComGameState_Unit KilledUnit; local XComLWTuple Tuple; local float KillXp; local float BonusKillXp; local float KillAssistXp; local int WetWorkXp; local XComGameState_Unit Killer; KilledUnit = XComGameState_Unit(EventSource); Tuple = XComLWTuple(EventData); KillXp = Tuple.Data[0].f; BonusKillXp = Tuple.Data[1].f; KillAssistXp = Tuple.Data[2].f; WetWorkXp = Tuple.Data[3].i; Killer = XComGameState_Unit(Tuple.Data[4].o); // Your code here Tuple.Data[0].f = KillXp; Tuple.Data[1].f = BonusKillXp; Tuple.Data[2].f = KillAssistXp; Tuple.Data[3].i = WetWorkXp; return ELR_NoInterrupt; } Source code references XComGameState_Unit.uc:6940-6959 XComGameState_Unit.uc:6749","title":"OverrideKillXp"},{"location":"tactical/OverrideKillXp/#overridekillxp","text":"Tracking Issue: #562 Tags: events Allows listeners to override the XP values granted by a kill, including the normal kill contribution, any bonus XP from resistance orders and the like, the XP granted for assists, and any Wet Work bonus. Mods can even set these values to zero to prevent XP gain. This event is called no more than once for each kill.","title":"OverrideKillXp"},{"location":"tactical/OverrideKillXp/#overridekillxp-event","text":"Param Value EventID OverrideKillXp EventData XComLWTuple EventSource XComGameState_Unit NewGameState yes","title":"OverrideKillXp event"},{"location":"tactical/OverrideKillXp/#tuple-contents","text":"Index Name Type Direction 0 KillXp float inout 1 BonusKillXp float inout 2 KillAssistXp float inout 3 WetWorkXp int inout 4 Killer XComGameState_Unit in","title":"Tuple contents"},{"location":"tactical/OverrideKillXp/#listener-template","text":"static function EventListenerReturn OnOverrideKillXp(Object EventData, Object EventSource, XComGameState GameState, Name EventID, Object CallbackObject) { local XComGameState_Unit KilledUnit; local XComLWTuple Tuple; local float KillXp; local float BonusKillXp; local float KillAssistXp; local int WetWorkXp; local XComGameState_Unit Killer; KilledUnit = XComGameState_Unit(EventSource); Tuple = XComLWTuple(EventData); KillXp = Tuple.Data[0].f; BonusKillXp = Tuple.Data[1].f; KillAssistXp = Tuple.Data[2].f; WetWorkXp = Tuple.Data[3].i; Killer = XComGameState_Unit(Tuple.Data[4].o); // Your code here Tuple.Data[0].f = KillXp; Tuple.Data[1].f = BonusKillXp; Tuple.Data[2].f = KillAssistXp; Tuple.Data[3].i = WetWorkXp; return ELR_NoInterrupt; }","title":"Listener template"},{"location":"tactical/OverrideKillXp/#source-code-references","text":"XComGameState_Unit.uc:6940-6959 XComGameState_Unit.uc:6749","title":"Source code references"},{"location":"tactical/OverrideLostSpawnIncreaseFromUse/","text":"OverrideLostSpawnIncreaseFromUse Tracking Issue: #892 Normally, each ability template has its own LostSpawnIncreasePerUse value. When the ability is activated, this value is added to the \"bucket\" responsible for spawning additional Lost waves. When the \"bucket\" is filled, a wave of Lost spawns. This LostSpawnIncreasePerUse value is constant for each ability template; it does not depend on which weapon is used for the ability or any other context. The XComGameState_Unit::OnAbilityActivated triggers a OverrideLostSpawnIncreaseFromUse event, allowing mods to override the amount of Lost-attracting noise generated by abilities. EventID: OverrideLostSpawnIncreaseFromUse EventData: XComLWTuple { Data: [ inout int LostSpawnModifier, in XComGameState_Ability ActivatedAbilityState, ] } EventSource: self (XComGameState_Unit) GameState: yes Listeners for this event must use ELD_Immediate deferral. Example of an event listener function: static function EventListenerReturn ListenerEventFunction(Object EventData, Object EventSource, XComGameState NewGameState, Name Event, Object CallbackData) { local XComLWTuple OverrideTuple; local XComGameState_Ability AbilityState; local XComGameState_Item SourceWeapon, SourceAmmo; OverrideTuple = XComLWTuple(EventData); AbilityState = XComGameState_Ability(OverrideTuple.Data[1].o); if (AbilityState.GetMyTemplateName() == 'ThrowGrenade' || AbilityState.GetMyTemplateName() == 'LaunchGrenade') { SourceWeapon = AbilityState.GetSourceWeapon(); SourceAmmo = AbilityState.GetSourceAmmo(); if (SourceWeapon != none && SourceWeapon.GetMyTemplateName() == 'ProximityMine' || SourceAmmo != none && SourceAmmo.GetMyTemplateName() == 'ProximityMine') { // Override the amount of Lost-attracting noise generated by Proximity Mine if it is thrown or launched. OverrideTuple.Data[0].i = 0; } } return ELR_NoInterrupt; } Source code references XComGameState_Unit.uc:9637-9680","title":"OverrideLostSpawnIncreaseFromUse"},{"location":"tactical/OverrideLostSpawnIncreaseFromUse/#overridelostspawnincreasefromuse","text":"Tracking Issue: #892 Normally, each ability template has its own LostSpawnIncreasePerUse value. When the ability is activated, this value is added to the \"bucket\" responsible for spawning additional Lost waves. When the \"bucket\" is filled, a wave of Lost spawns. This LostSpawnIncreasePerUse value is constant for each ability template; it does not depend on which weapon is used for the ability or any other context. The XComGameState_Unit::OnAbilityActivated triggers a OverrideLostSpawnIncreaseFromUse event, allowing mods to override the amount of Lost-attracting noise generated by abilities. EventID: OverrideLostSpawnIncreaseFromUse EventData: XComLWTuple { Data: [ inout int LostSpawnModifier, in XComGameState_Ability ActivatedAbilityState, ] } EventSource: self (XComGameState_Unit) GameState: yes Listeners for this event must use ELD_Immediate deferral. Example of an event listener function: static function EventListenerReturn ListenerEventFunction(Object EventData, Object EventSource, XComGameState NewGameState, Name Event, Object CallbackData) { local XComLWTuple OverrideTuple; local XComGameState_Ability AbilityState; local XComGameState_Item SourceWeapon, SourceAmmo; OverrideTuple = XComLWTuple(EventData); AbilityState = XComGameState_Ability(OverrideTuple.Data[1].o); if (AbilityState.GetMyTemplateName() == 'ThrowGrenade' || AbilityState.GetMyTemplateName() == 'LaunchGrenade') { SourceWeapon = AbilityState.GetSourceWeapon(); SourceAmmo = AbilityState.GetSourceAmmo(); if (SourceWeapon != none && SourceWeapon.GetMyTemplateName() == 'ProximityMine' || SourceAmmo != none && SourceAmmo.GetMyTemplateName() == 'ProximityMine') { // Override the amount of Lost-attracting noise generated by Proximity Mine if it is thrown or launched. OverrideTuple.Data[0].i = 0; } } return ELR_NoInterrupt; }","title":"OverrideLostSpawnIncreaseFromUse"},{"location":"tactical/OverrideLostSpawnIncreaseFromUse/#source-code-references","text":"XComGameState_Unit.uc:9637-9680","title":"Source code references"},{"location":"tactical/OverridePatrolBehavior/","text":"OverridePatrolBehavior Tracking Issue: #507 Tags: events The OverridePatrolBehavior event allows mods to override pods' patrol behavior. The bOverridePatrolBehavior component of the tuple should be set to true if the mod is overriding the patrol behavior and wants to bypass the default base game patrol logic. OverridePatrolBehavior event Param Value EventID OverridePatrolBehavior EventData XComLWTuple EventSource XComGameState_AIGroup NewGameState none Tuple contents Index Name Type Direction 0 bOverridePatrolBehavior bool out Listener template static function EventListenerReturn OnOverridePatrolBehavior(Object EventData, Object EventSource, XComGameState GameState, Name EventID, Object CallbackObject) { local XComGameState_AIGroup AIGroup; local XComLWTuple Tuple; local bool bOverridePatrolBehavior; AIGroup = XComGameState_AIGroup(EventSource); Tuple = XComLWTuple(EventData); // Your code here Tuple.Data[0].b = bOverridePatrolBehavior; return ELR_NoInterrupt; } Source code references XComGameState_AIGroup.uc:490-501","title":"OverridePatrolBehavior"},{"location":"tactical/OverridePatrolBehavior/#overridepatrolbehavior","text":"Tracking Issue: #507 Tags: events The OverridePatrolBehavior event allows mods to override pods' patrol behavior. The bOverridePatrolBehavior component of the tuple should be set to true if the mod is overriding the patrol behavior and wants to bypass the default base game patrol logic.","title":"OverridePatrolBehavior"},{"location":"tactical/OverridePatrolBehavior/#overridepatrolbehavior-event","text":"Param Value EventID OverridePatrolBehavior EventData XComLWTuple EventSource XComGameState_AIGroup NewGameState none","title":"OverridePatrolBehavior event"},{"location":"tactical/OverridePatrolBehavior/#tuple-contents","text":"Index Name Type Direction 0 bOverridePatrolBehavior bool out","title":"Tuple contents"},{"location":"tactical/OverridePatrolBehavior/#listener-template","text":"static function EventListenerReturn OnOverridePatrolBehavior(Object EventData, Object EventSource, XComGameState GameState, Name EventID, Object CallbackObject) { local XComGameState_AIGroup AIGroup; local XComLWTuple Tuple; local bool bOverridePatrolBehavior; AIGroup = XComGameState_AIGroup(EventSource); Tuple = XComLWTuple(EventData); // Your code here Tuple.Data[0].b = bOverridePatrolBehavior; return ELR_NoInterrupt; }","title":"Listener template"},{"location":"tactical/OverridePatrolBehavior/#source-code-references","text":"XComGameState_AIGroup.uc:490-501","title":"Source code references"},{"location":"tactical/OverrideProjectileInstance/","text":"OverrideProjectileInstance Tracking Issue: #829 Tags: events Allows listeners to override the parameters of SpawnAndConfigureNewProjectile The feature also introduces support for subclasses of X2UnifiedProjectile as custom projectile archetypes. If bPreventProjectileSpawning is set to true the projectile instance will NOT be spawned. OverrideProjectileInstance event Param Value EventID OverrideProjectileInstance EventData XComLWTuple EventSource XComGameStateContext_Ability NewGameState none Tuple contents Index Name Type Direction 0 bPreventProjectileSpawning bool out 1 ProjectileTemplate Actor in 2 InVolleyNotify AnimNotify_FireWeaponVolley in 3 InSourceWeapon XComWeapon in 4 CurrentFireAction X2Action_Fire inout 5 Unit XGUnitNativeBase in Listener template static function EventListenerReturn OnOverrideProjectileInstance(Object EventData, Object EventSource, XComGameState GameState, Name EventID, Object CallbackObject) { local XComGameStateContext_Ability AbilityContext; local XComLWTuple Tuple; local bool bPreventProjectileSpawning; local Actor ProjectileTemplate; local AnimNotify_FireWeaponVolley InVolleyNotify; local XComWeapon InSourceWeapon; local X2Action_Fire CurrentFireAction; local XGUnitNativeBase Unit; AbilityContext = XComGameStateContext_Ability(EventSource); Tuple = XComLWTuple(EventData); ProjectileTemplate = Actor(Tuple.Data[1].o); InVolleyNotify = AnimNotify_FireWeaponVolley(Tuple.Data[2].o); InSourceWeapon = XComWeapon(Tuple.Data[3].o); CurrentFireAction = X2Action_Fire(Tuple.Data[4].o); Unit = XGUnitNativeBase(Tuple.Data[5].o); // Your code here Tuple.Data[0].b = bPreventProjectileSpawning; Tuple.Data[4].o = CurrentFireAction; return ELR_NoInterrupt; } Source code references XGUnitNativeBase.uc:1614-1631","title":"OverrideProjectileInstance"},{"location":"tactical/OverrideProjectileInstance/#overrideprojectileinstance","text":"Tracking Issue: #829 Tags: events Allows listeners to override the parameters of SpawnAndConfigureNewProjectile The feature also introduces support for subclasses of X2UnifiedProjectile as custom projectile archetypes. If bPreventProjectileSpawning is set to true the projectile instance will NOT be spawned.","title":"OverrideProjectileInstance"},{"location":"tactical/OverrideProjectileInstance/#overrideprojectileinstance-event","text":"Param Value EventID OverrideProjectileInstance EventData XComLWTuple EventSource XComGameStateContext_Ability NewGameState none","title":"OverrideProjectileInstance event"},{"location":"tactical/OverrideProjectileInstance/#tuple-contents","text":"Index Name Type Direction 0 bPreventProjectileSpawning bool out 1 ProjectileTemplate Actor in 2 InVolleyNotify AnimNotify_FireWeaponVolley in 3 InSourceWeapon XComWeapon in 4 CurrentFireAction X2Action_Fire inout 5 Unit XGUnitNativeBase in","title":"Tuple contents"},{"location":"tactical/OverrideProjectileInstance/#listener-template","text":"static function EventListenerReturn OnOverrideProjectileInstance(Object EventData, Object EventSource, XComGameState GameState, Name EventID, Object CallbackObject) { local XComGameStateContext_Ability AbilityContext; local XComLWTuple Tuple; local bool bPreventProjectileSpawning; local Actor ProjectileTemplate; local AnimNotify_FireWeaponVolley InVolleyNotify; local XComWeapon InSourceWeapon; local X2Action_Fire CurrentFireAction; local XGUnitNativeBase Unit; AbilityContext = XComGameStateContext_Ability(EventSource); Tuple = XComLWTuple(EventData); ProjectileTemplate = Actor(Tuple.Data[1].o); InVolleyNotify = AnimNotify_FireWeaponVolley(Tuple.Data[2].o); InSourceWeapon = XComWeapon(Tuple.Data[3].o); CurrentFireAction = X2Action_Fire(Tuple.Data[4].o); Unit = XGUnitNativeBase(Tuple.Data[5].o); // Your code here Tuple.Data[0].b = bPreventProjectileSpawning; Tuple.Data[4].o = CurrentFireAction; return ELR_NoInterrupt; }","title":"Listener template"},{"location":"tactical/OverrideProjectileInstance/#source-code-references","text":"XGUnitNativeBase.uc:1614-1631","title":"Source code references"},{"location":"tactical/OverrideUnitFocusUI/","text":"OverrideUnitFocusUI Tracking Issue: #257 Tags: compatibility , events This focus change allows mods to change the focus UI that the vanilla game uses to display Templar Focus. This effectively creates different types of Focus, even though the game does not know about this. For example, you can create a custom soldier class with its own type of focus, tracked with a UnitValue . This imposes a few limitations on the system: A given unit only ever has a single \"type\" of focus. The rules for different focus types are expected to be so different from one another to make any conflicts a painful experience for modders and players. In particular, it means that this function should NOT be used to make any changes to the Templar Focus, as tempting as it may be. This also includes an Effect of the name TemplarFocus or an Effect Class of the type XComGameState_Effect_TemplarFocus . In order to add your custom focus types, there are two changes in XComGame you can use: A new event hook for UIUnitFlag and UITacticalHUD_SoldierInfo : Documentation for that particular hook is directly below. A change in X2AbilityCost_Focus : You may subclass that particular class and override all functions declared there ( CanAfford , ApplyCost , PreviewFocusCost ). This can be used to preview a cost for custom skills that consume focus. Again, make sure to not mix and match custom subclasses with the base class for any abilities. OverrideUnitFocusUI event Param Value EventID OverrideUnitFocusUI EventData XComLWTuple EventSource XComGameState_Unit NewGameState none Tuple contents Index Name Type Direction 0 bVisible bool inout 1 currentFocus int inout 2 maxFoxus int inout 3 color string inout 4 iconPath string inout 5 tooltipText string inout 6 focusLabel string inout Listener template static function EventListenerReturn OnOverrideUnitFocusUI(Object EventData, Object EventSource, XComGameState GameState, Name EventID, Object CallbackObject) { local XComGameState_Unit SourceUnit; local XComLWTuple Tuple; local bool bVisible; local int currentFocus; local int maxFoxus; local string color; local string iconPath; local string tooltipText; local string focusLabel; SourceUnit = XComGameState_Unit(EventSource); Tuple = XComLWTuple(EventData); bVisible = Tuple.Data[0].b; currentFocus = Tuple.Data[1].i; maxFoxus = Tuple.Data[2].i; color = Tuple.Data[3].s; iconPath = Tuple.Data[4].s; tooltipText = Tuple.Data[5].s; focusLabel = Tuple.Data[6].s; // Your code here Tuple.Data[0].b = bVisible; Tuple.Data[1].i = currentFocus; Tuple.Data[2].i = maxFoxus; Tuple.Data[3].s = color; Tuple.Data[4].s = iconPath; Tuple.Data[5].s = tooltipText; Tuple.Data[6].s = focusLabel; return ELR_NoInterrupt; } Note that if bVisible == false , the rest will be ignored and will not have valid data in it. Compatibility If you override UIUnitFlag , your code may undo the HL's changes that support this feature in the UI. See the tracking issue for code samples. Source code references CHHelpers.uc:426-470","title":"OverrideUnitFocusUI"},{"location":"tactical/OverrideUnitFocusUI/#overrideunitfocusui","text":"Tracking Issue: #257 Tags: compatibility , events This focus change allows mods to change the focus UI that the vanilla game uses to display Templar Focus. This effectively creates different types of Focus, even though the game does not know about this. For example, you can create a custom soldier class with its own type of focus, tracked with a UnitValue . This imposes a few limitations on the system: A given unit only ever has a single \"type\" of focus. The rules for different focus types are expected to be so different from one another to make any conflicts a painful experience for modders and players. In particular, it means that this function should NOT be used to make any changes to the Templar Focus, as tempting as it may be. This also includes an Effect of the name TemplarFocus or an Effect Class of the type XComGameState_Effect_TemplarFocus . In order to add your custom focus types, there are two changes in XComGame you can use: A new event hook for UIUnitFlag and UITacticalHUD_SoldierInfo : Documentation for that particular hook is directly below. A change in X2AbilityCost_Focus : You may subclass that particular class and override all functions declared there ( CanAfford , ApplyCost , PreviewFocusCost ). This can be used to preview a cost for custom skills that consume focus. Again, make sure to not mix and match custom subclasses with the base class for any abilities.","title":"OverrideUnitFocusUI"},{"location":"tactical/OverrideUnitFocusUI/#overrideunitfocusui-event","text":"Param Value EventID OverrideUnitFocusUI EventData XComLWTuple EventSource XComGameState_Unit NewGameState none","title":"OverrideUnitFocusUI event"},{"location":"tactical/OverrideUnitFocusUI/#tuple-contents","text":"Index Name Type Direction 0 bVisible bool inout 1 currentFocus int inout 2 maxFoxus int inout 3 color string inout 4 iconPath string inout 5 tooltipText string inout 6 focusLabel string inout","title":"Tuple contents"},{"location":"tactical/OverrideUnitFocusUI/#listener-template","text":"static function EventListenerReturn OnOverrideUnitFocusUI(Object EventData, Object EventSource, XComGameState GameState, Name EventID, Object CallbackObject) { local XComGameState_Unit SourceUnit; local XComLWTuple Tuple; local bool bVisible; local int currentFocus; local int maxFoxus; local string color; local string iconPath; local string tooltipText; local string focusLabel; SourceUnit = XComGameState_Unit(EventSource); Tuple = XComLWTuple(EventData); bVisible = Tuple.Data[0].b; currentFocus = Tuple.Data[1].i; maxFoxus = Tuple.Data[2].i; color = Tuple.Data[3].s; iconPath = Tuple.Data[4].s; tooltipText = Tuple.Data[5].s; focusLabel = Tuple.Data[6].s; // Your code here Tuple.Data[0].b = bVisible; Tuple.Data[1].i = currentFocus; Tuple.Data[2].i = maxFoxus; Tuple.Data[3].s = color; Tuple.Data[4].s = iconPath; Tuple.Data[5].s = tooltipText; Tuple.Data[6].s = focusLabel; return ELR_NoInterrupt; } Note that if bVisible == false , the rest will be ignored and will not have valid data in it.","title":"Listener template"},{"location":"tactical/OverrideUnitFocusUI/#compatibility","text":"If you override UIUnitFlag , your code may undo the HL's changes that support this feature in the UI. See the tracking issue for code samples.","title":"Compatibility"},{"location":"tactical/OverrideUnitFocusUI/#source-code-references","text":"CHHelpers.uc:426-470","title":"Source code references"},{"location":"tactical/PersonalitySpeech/","text":"PersonalitySpeech Tracking Issue: #317 Tags: customization The soldier speech system allows soldiers to use different voicelines in some situations based on their attitude. For example, an \"Intense\" soldier will voice react differently to killing an enemy than a \"Twitchy\" one. This behavior was hardcoded in the base game. Highlander replaces the original implementation with the PersonalitySpeech config array that takes values from XComGame.ini config file. This potentailly allows mods to replace the original personality speech patterns, as well as add new patterns for new attitudes, if a mod manages to add any. Example entry for the \"By The Book\" attitude: [XComGame.CHHelpers] +PersonalitySpeech=( Personality=\"Personality_ByTheBook\", \\\\ CharSpeeches = ( \\\\ (CharSpeech=\"Moving\", PersonalityVariant=(\"Moving_BY_THE_BOOK\")), \\\\ (CharSpeech=\"TargetKilled\", PersonalityVariant=(\"TargetKilled_BY_THE_BOOK\")), \\\\ (CharSpeech=\"Panic\", PersonalityVariant=(\"Panic_BY_THE_BOOK\")), \\\\ (CharSpeech=\"SoldierVIP\", PersonalityVariant=(\"SoldierVIP_BY_THE_BOOK\")), \\\\ (CharSpeech=\"UsefulVIP\", PersonalityVariant=(\"UsefulVIP_BY_THE_BOOK\")), \\\\ (CharSpeech=\"GenericVIP\", PersonalityVariant=(\"GenericVIP_BY_THE_BOOK\")), \\\\ (CharSpeech=\"HostileVIP\", PersonalityVariant=(\"HostileVIP_BY_THE_BOOK\")), \\\\ (CharSpeech=\"LootCaptured\", PersonalityVariant=(\"LootCaptured_BY_THE_BOOK\")), \\\\ (CharSpeech=\"HackWorkstation\", PersonalityVariant=(\"HackWorkstation_BY_THE_BOOK\")), \\\\ (CharSpeech=\"LootSpotted\", PersonalityVariant=(\"LootSpotted_BY_THE_BOOK\")), \\\\ (CharSpeech=\"TargetEliminated\", PersonalityVariant=(\"TargetEliminated_BY_THE_BOOK\")), \\\\ (CharSpeech=\"PickingUpBody\", PersonalityVariant=(\"PickingUpBody_BY_THE_BOOK\")) \\\\ )) Note: only one PersonalitySpeech entry per attitude will be taken into account, any others will be ignored. If your mod wants to replace the original speech personality config with your own, you should copy the original entry to their own config exactly as it appears in the Highlander, and replace the + at the start of the entry with a - , which will remove the entry when your mod is loaded. Then you can specify your own config entry for that attitude below. Source code references XGUnit.uc:1505-1538 XComGame.ini:60 CHHelpers.uc:139","title":"PersonalitySpeech"},{"location":"tactical/PersonalitySpeech/#personalityspeech","text":"Tracking Issue: #317 Tags: customization The soldier speech system allows soldiers to use different voicelines in some situations based on their attitude. For example, an \"Intense\" soldier will voice react differently to killing an enemy than a \"Twitchy\" one. This behavior was hardcoded in the base game. Highlander replaces the original implementation with the PersonalitySpeech config array that takes values from XComGame.ini config file. This potentailly allows mods to replace the original personality speech patterns, as well as add new patterns for new attitudes, if a mod manages to add any. Example entry for the \"By The Book\" attitude: [XComGame.CHHelpers] +PersonalitySpeech=( Personality=\"Personality_ByTheBook\", \\\\ CharSpeeches = ( \\\\ (CharSpeech=\"Moving\", PersonalityVariant=(\"Moving_BY_THE_BOOK\")), \\\\ (CharSpeech=\"TargetKilled\", PersonalityVariant=(\"TargetKilled_BY_THE_BOOK\")), \\\\ (CharSpeech=\"Panic\", PersonalityVariant=(\"Panic_BY_THE_BOOK\")), \\\\ (CharSpeech=\"SoldierVIP\", PersonalityVariant=(\"SoldierVIP_BY_THE_BOOK\")), \\\\ (CharSpeech=\"UsefulVIP\", PersonalityVariant=(\"UsefulVIP_BY_THE_BOOK\")), \\\\ (CharSpeech=\"GenericVIP\", PersonalityVariant=(\"GenericVIP_BY_THE_BOOK\")), \\\\ (CharSpeech=\"HostileVIP\", PersonalityVariant=(\"HostileVIP_BY_THE_BOOK\")), \\\\ (CharSpeech=\"LootCaptured\", PersonalityVariant=(\"LootCaptured_BY_THE_BOOK\")), \\\\ (CharSpeech=\"HackWorkstation\", PersonalityVariant=(\"HackWorkstation_BY_THE_BOOK\")), \\\\ (CharSpeech=\"LootSpotted\", PersonalityVariant=(\"LootSpotted_BY_THE_BOOK\")), \\\\ (CharSpeech=\"TargetEliminated\", PersonalityVariant=(\"TargetEliminated_BY_THE_BOOK\")), \\\\ (CharSpeech=\"PickingUpBody\", PersonalityVariant=(\"PickingUpBody_BY_THE_BOOK\")) \\\\ )) Note: only one PersonalitySpeech entry per attitude will be taken into account, any others will be ignored. If your mod wants to replace the original speech personality config with your own, you should copy the original entry to their own config exactly as it appears in the Highlander, and replace the + at the start of the entry with a - , which will remove the entry when your mod is loaded. Then you can specify your own config entry for that attitude below.","title":"PersonalitySpeech"},{"location":"tactical/PersonalitySpeech/#source-code-references","text":"XGUnit.uc:1505-1538 XComGame.ini:60 CHHelpers.uc:139","title":"Source code references"},{"location":"tactical/PlaceEvacZoneAbilityName/","text":"PlaceEvacZoneAbilityName Tracking Issue: #855 Config variable (of type name) that allows mods to override the name of the ability used for placing/throwing evac zones in tactical missions. This is because the base game hard codes the ability name used for the controller's R3 button, which is bad if a mod (like LWOTC) replaces PlaceEvacZone with a different ability. Note that this variable only affects the input system. If you want to replace the ability itself, you will still need to do the hard work of creating the new ability, giving it to soldiers, handling evac zone destruction, etc. Source code references CHHelpers.uc:191-201","title":"PlaceEvacZoneAbilityName"},{"location":"tactical/PlaceEvacZoneAbilityName/#placeevaczoneabilityname","text":"Tracking Issue: #855 Config variable (of type name) that allows mods to override the name of the ability used for placing/throwing evac zones in tactical missions. This is because the base game hard codes the ability name used for the controller's R3 button, which is bad if a mod (like LWOTC) replaces PlaceEvacZone with a different ability. Note that this variable only affects the input system. If you want to replace the ability itself, you will still need to do the hard work of creating the new ability, giving it to soldiers, handling evac zone destruction, etc.","title":"PlaceEvacZoneAbilityName"},{"location":"tactical/PlaceEvacZoneAbilityName/#source-code-references","text":"CHHelpers.uc:191-201","title":"Source code references"},{"location":"tactical/PostAliensSpawned/","text":"PostAliensSpawned Tracking Issue: #457 This event triggers right after the alien pods are added into the tactical mission's Start State, before their visualizers are spawned/visualized. Overall it can be treated as an earlier alternative to 'OnTacticalBeginPlay' event. It can be used to make arbitrary changes to units that were just added to the Start State, including Soldier VIPs that are spawned for Gather Survivors missions. For example, this is how to set up an Event Listener to modify these Soldier VIPs: // This EventFn requires an ELD_Immediate deferral. static protected function EventListenerReturn PostAliensSpawned_Listener(Object EventData, Object EventSource, XComGameState StartState, Name EventID, Object CallbackData) { local XComTacticalMissionManager MissionManager; local XComGameState_Unit UnitState; local XComGameState_AIGroup GroupState; MissionManager = `TACTICALMISSIONMGR; if (MissionManager.ActiveMission.sType == \"GatherSurvivors\") { // Cycle through Group States, which are basically Game States for pods. foreach GameState.IterateByClassType(class'XComGameState_AIGroup', GroupState) { // Check the pod for correct markings. if (GroupState.EncounterID == 'ResistanceTeamMember_VIP' && GroupState.PrePlacedEncounterTag == 'ResistanceTeamMember_01') { // Assume the pod contains only one unit and grab the Unit State for it. UnitState = XComGameState_Unit(GameState.GetGameStateForObjectID(GroupState.m_arrMembers[0].ObjectID)); if (UnitState != none) { // Make arbitrary changes to the Unit here. } } // Do the same for GroupState.PrePlacedEncounterTag == 'ResistanceTeamMember_02' here. } } return ELR_NoInterrupt; } EventID: PostAliensSpawned NewGameState: StartState Source code references X2TacticalGameRuleset.uc:2457-2497","title":"PostAliensSpawned"},{"location":"tactical/PostAliensSpawned/#postaliensspawned","text":"Tracking Issue: #457 This event triggers right after the alien pods are added into the tactical mission's Start State, before their visualizers are spawned/visualized. Overall it can be treated as an earlier alternative to 'OnTacticalBeginPlay' event. It can be used to make arbitrary changes to units that were just added to the Start State, including Soldier VIPs that are spawned for Gather Survivors missions. For example, this is how to set up an Event Listener to modify these Soldier VIPs: // This EventFn requires an ELD_Immediate deferral. static protected function EventListenerReturn PostAliensSpawned_Listener(Object EventData, Object EventSource, XComGameState StartState, Name EventID, Object CallbackData) { local XComTacticalMissionManager MissionManager; local XComGameState_Unit UnitState; local XComGameState_AIGroup GroupState; MissionManager = `TACTICALMISSIONMGR; if (MissionManager.ActiveMission.sType == \"GatherSurvivors\") { // Cycle through Group States, which are basically Game States for pods. foreach GameState.IterateByClassType(class'XComGameState_AIGroup', GroupState) { // Check the pod for correct markings. if (GroupState.EncounterID == 'ResistanceTeamMember_VIP' && GroupState.PrePlacedEncounterTag == 'ResistanceTeamMember_01') { // Assume the pod contains only one unit and grab the Unit State for it. UnitState = XComGameState_Unit(GameState.GetGameStateForObjectID(GroupState.m_arrMembers[0].ObjectID)); if (UnitState != none) { // Make arbitrary changes to the Unit here. } } // Do the same for GroupState.PrePlacedEncounterTag == 'ResistanceTeamMember_02' here. } } return ELR_NoInterrupt; } EventID: PostAliensSpawned NewGameState: StartState","title":"PostAliensSpawned"},{"location":"tactical/PostAliensSpawned/#source-code-references","text":"X2TacticalGameRuleset.uc:2457-2497","title":"Source code references"},{"location":"tactical/PostModifyNewAbilityContext/","text":"PostModifyNewAbilityContext Tracking Issue: #890 The XComGameStateContext_Ability::ActivateAbility_Internal triggers a PostModifyNewAbilityContext event, allowing mods to make changes to Ability Context. The event triggers after the ability has gathered targets using its TargetStyles, after ToHitCalc calculations, and after the ability has ran its ModifyNewContextFn delegate, if it has one. Modifying Ability Context is a powerful tool, as it allows to arbitrarily change ability's Hit Result, change its intended targets and hit location. If you yourself are adding an ability that could benefit from context modification, you should probably just use the ModifyNewContextFn delegate. This event is mostly intended for modifying Ability Context of base game abilities, or abilities added by other mods, so you don't have to risk an incompatibility by adding your own ModifyNewContextFn delegate to somebody else's ability. Listeners for this event must use ELD_Immediate deferral. EventID: PostModifyNewAbilityContext EventData: XComGameStateContext_Ability NewContext EventSource: XComGameState_Ability AbilityState NewGameState: no Source code references XComGameStateContext_Ability.uc:1518-1532","title":"PostModifyNewAbilityContext"},{"location":"tactical/PostModifyNewAbilityContext/#postmodifynewabilitycontext","text":"Tracking Issue: #890 The XComGameStateContext_Ability::ActivateAbility_Internal triggers a PostModifyNewAbilityContext event, allowing mods to make changes to Ability Context. The event triggers after the ability has gathered targets using its TargetStyles, after ToHitCalc calculations, and after the ability has ran its ModifyNewContextFn delegate, if it has one. Modifying Ability Context is a powerful tool, as it allows to arbitrarily change ability's Hit Result, change its intended targets and hit location. If you yourself are adding an ability that could benefit from context modification, you should probably just use the ModifyNewContextFn delegate. This event is mostly intended for modifying Ability Context of base game abilities, or abilities added by other mods, so you don't have to risk an incompatibility by adding your own ModifyNewContextFn delegate to somebody else's ability. Listeners for this event must use ELD_Immediate deferral. EventID: PostModifyNewAbilityContext EventData: XComGameStateContext_Ability NewContext EventSource: XComGameState_Ability AbilityState NewGameState: no","title":"PostModifyNewAbilityContext"},{"location":"tactical/PostModifyNewAbilityContext/#source-code-references","text":"XComGameStateContext_Ability.uc:1518-1532","title":"Source code references"},{"location":"tactical/RequiresTargetingActivation/","text":"RequiresTargetingActivation Tracking Issue: #476 When playing with a controller (gamepad), some abilities allow the player to press (A) again to aim the ability, which allows them to rotate the camera with the buttons that would normally cycle the ability selection. In base game this behaviour was hardcoded to work only for a few specific Targeting Methods. Highlander replaces the original implementation with a the RequiresTargetingActivation config array that takes values from XComGame.ini config file. This potentailly allows mods to use this behavior for custom Targeting Methods that do not extend any of the Targeting Methods that are already configured to use this behavior. [XComGame.CHHelpers] +RequiresTargetingActivation=X2TargetingMethod_Grenade +RequiresTargetingActivation=X2TargetingMethod_Cone Source code references UITacticalHUD_AbilityContainer.uc:171-186 XComGame.ini:51","title":"RequiresTargetingActivation"},{"location":"tactical/RequiresTargetingActivation/#requirestargetingactivation","text":"Tracking Issue: #476 When playing with a controller (gamepad), some abilities allow the player to press (A) again to aim the ability, which allows them to rotate the camera with the buttons that would normally cycle the ability selection. In base game this behaviour was hardcoded to work only for a few specific Targeting Methods. Highlander replaces the original implementation with a the RequiresTargetingActivation config array that takes values from XComGame.ini config file. This potentailly allows mods to use this behavior for custom Targeting Methods that do not extend any of the Targeting Methods that are already configured to use this behavior. [XComGame.CHHelpers] +RequiresTargetingActivation=X2TargetingMethod_Grenade +RequiresTargetingActivation=X2TargetingMethod_Cone","title":"RequiresTargetingActivation"},{"location":"tactical/RequiresTargetingActivation/#source-code-references","text":"UITacticalHUD_AbilityContainer.uc:171-186 XComGame.ini:51","title":"Source code references"},{"location":"tactical/ShouldCivilianRun/","text":"ShouldCivilianRun Tracking Issue: #666 Tags: events Triggers a 'ShouldCivilianRun' event that allows listeners to determine whether neutrals should run in reaction to another unit moving by them. Returns true if the given neutral unit should run, false otherwise. ShouldCivilianRun event Param Value EventID ShouldCivilianRun EventData XComLWTuple EventSource XComGameState_Unit NewGameState none Tuple contents Index Name Type Direction 0 MovedUnit XComGameState_Unit in 1 AIAttacksCivilians bool in 2 ShouldRun bool inout Listener template static function EventListenerReturn OnShouldCivilianRun(Object EventData, Object EventSource, XComGameState GameState, Name EventID, Object CallbackObject) { local XComGameState_Unit Civilian; local XComLWTuple Tuple; local XComGameState_Unit MovedUnit; local bool AIAttacksCivilians; local bool ShouldRun; Civilian = XComGameState_Unit(EventSource); Tuple = XComLWTuple(EventData); MovedUnit = XComGameState_Unit(Tuple.Data[0].o); AIAttacksCivilians = Tuple.Data[1].b; ShouldRun = Tuple.Data[2].b; // Your code here Tuple.Data[2].b = ShouldRun; return ELR_NoInterrupt; } Source code references X2TacticalGameRuleset.uc:1687-1697","title":"ShouldCivilianRun"},{"location":"tactical/ShouldCivilianRun/#shouldcivilianrun","text":"Tracking Issue: #666 Tags: events Triggers a 'ShouldCivilianRun' event that allows listeners to determine whether neutrals should run in reaction to another unit moving by them. Returns true if the given neutral unit should run, false otherwise.","title":"ShouldCivilianRun"},{"location":"tactical/ShouldCivilianRun/#shouldcivilianrun-event","text":"Param Value EventID ShouldCivilianRun EventData XComLWTuple EventSource XComGameState_Unit NewGameState none","title":"ShouldCivilianRun event"},{"location":"tactical/ShouldCivilianRun/#tuple-contents","text":"Index Name Type Direction 0 MovedUnit XComGameState_Unit in 1 AIAttacksCivilians bool in 2 ShouldRun bool inout","title":"Tuple contents"},{"location":"tactical/ShouldCivilianRun/#listener-template","text":"static function EventListenerReturn OnShouldCivilianRun(Object EventData, Object EventSource, XComGameState GameState, Name EventID, Object CallbackObject) { local XComGameState_Unit Civilian; local XComLWTuple Tuple; local XComGameState_Unit MovedUnit; local bool AIAttacksCivilians; local bool ShouldRun; Civilian = XComGameState_Unit(EventSource); Tuple = XComLWTuple(EventData); MovedUnit = XComGameState_Unit(Tuple.Data[0].o); AIAttacksCivilians = Tuple.Data[1].b; ShouldRun = Tuple.Data[2].b; // Your code here Tuple.Data[2].b = ShouldRun; return ELR_NoInterrupt; }","title":"Listener template"},{"location":"tactical/ShouldCivilianRun/#source-code-references","text":"X2TacticalGameRuleset.uc:1687-1697","title":"Source code references"}]}